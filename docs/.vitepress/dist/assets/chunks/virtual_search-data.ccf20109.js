const t={map:'[{"abstract":["1.0"],"一":["1.1","4.1","5.1","9.1"],"二":["1.2","4.8","5.2","9.2"],"literal":["1.3"],"identifier":["1.4"],"statement":["1.5"],"declaration":["1.6"],"expression":["1.7"],"class":["1.8"],"modules":["1.9"],"program":["1.10"],"file":["1.11"],"ast":["1.12","1.13"],"总结":["1.14","4.47","9.30","13.5","50.21"],"三":["1.15","4.17","5.3","9.10"],"四":["1.18","4.21","5.4","9.22"],"babel":["2.0"],"bundle":["3.0"],"五":["4.28","5.5"],"六":["4.35","5.6"],"参考资料":["4.48","5.9"],"函数式编程":["5.0"],"七":["5.7"],"八":["5.8"],"imagemin":["6.0"],"页面加载完成后事件":["7.0"],"window":["7.1"],"domcontentloaded":["7.2"],"body":["7.3"],"readystate":["7.4"],"数组长度做计数":["8.0"],"数组长度实现加减乘除":["8.1"],"add":["8.2"],"subtract":["8.3"],"multiply":["8.4"],"divide":["8.5"],"数组长度实现计数":["8.6"],"strlen":["8.7"],"greaterthan":["8.8"],"fibonacci":["8.9"],"typescript":["9.0","47.0","49.0","50.0"],"协变":["9.7"],"逆变":["9.8"],"不变":["9.9"],"元组":["9.12"],"接口":["9.13"],"枚举":["9.14"],"条件":["9.17","49.1"],"推导":["9.18","49.2"],"联合":["9.19","49.3"],"交叉":["9.20","49.4"],"映射类型":["9.21","49.5"],"isany":["9.23"],"isequal":["9.24"],"isunion":["9.25","13.2"],"isnever":["9.26"],"istuple":["9.27"],"uniontointersection":["9.28"],"getoptional":["9.29"],"模式匹配提取":["10.0"],"提取第一个元素":["10.2"],"提取最后一个元素":["10.3"],"poparr":["10.4"],"shiftarr":["10.5"],"startswith":["10.7"],"replace":["10.8"],"trim":["10.9","48.2"],"getparameters":["10.11","48.4"],"getreturntype":["10.12","48.5"],"getthisparametertype":["10.13","48.6"],"getinstancetype":["10.15","48.8"],"getconstructorparameters":["10.16"],"索引类型":["10.17"],"重新构造做变换":["11.0"],"重新构造":["11.1"],"数组类型的重新构造":["11.2"],"push":["11.3"],"unshift":["11.4"],"zip":["11.5"],"字符串类型的重新构造":["11.6"],"capitalizestr":["11.7"],"camelcase":["11.8"],"dropsubstr":["11.9"],"函数类型的重新构造":["11.10"],"appendargument":["11.11"],"索引类型的重新构造":["11.12"],"mapping":["11.13"],"uppercasekey":["11.14"],"record":["11.15","50.11"],"toreadonly":["11.16"],"topartial":["11.17"],"tomutable":["11.18"],"torequired":["11.19"],"filterbyvaluetype":["11.20"],"递归复用":["12.0"],"promise":["12.1"],"deeppromisevaluetype":["12.2"],"数组类型的递归":["12.3"],"reversearr":["12.4"],"includes":["12.5"],"removeitem":["12.6"],"buildarray":["12.7"],"字符串类型的递归":["12.8"],"replaceall":["12.9"],"stringtounion":["12.10"],"reversestr":["12.11"],"对象类型的递归":["12.12"],"deepreadonly":["12.13"],"分布式条件类型":["13.0"],"camelcaseunion":["13.1"],"bem":["13.3"],"allcombinations":["13.4"],"二叉树的定义":["14.0"],"满二叉树":["14.1"],"完全二叉树":["14.2"],"二叉搜索树":["14.3"],"平衡二叉树":["14.4"],"b":["14.5","14.6","14.7"],"红黑树":["14.8"],"堆":["14.9"],"前序遍历":["14.10"],"后序遍历":["14.11"],"中序遍历":["14.12"],"层序遍历":["14.13"],"镜像二叉树":["14.14"],"重建二叉树":["14.15"],"二叉树深度":["14.16"],"二叉树节点总数":["14.17"],"判断二叉树子结构":["14.18"],"bundler":["15.0"],"文件操作函数":["16.0"],"watchfile":["16.1"],"api":["16.2"],"return":["16.3"],"options":["16.4"],"封装":["18.0"],"字符串大小写转换":["19.0"],"截取":["20.0"],"时间格式化":["21.0"],"冒泡排序":["22.0"],"算法描述":["22.1","23.1","24.1","25.1","27.1","28.1","29.1","30.1","31.1","32.1"],"动图演示":["22.2","24.2","25.2","27.2","28.2","29.2","30.2","31.2","32.2"],"代码演示":["22.3","23.2","24.3","25.3","27.3","28.3","29.3","30.3","36.1","37.1","38.1","40.1","41.1","43.1","44.1","45.1"],"桶排序":["23.0"],"算法分析":["23.3","24.4","27.4","28.4","30.4","31.4","32.4"],"计数排序":["24.0"],"堆排序":["25.0"],"十大经典排序":["26.0"],"插入排序":["27.0"],"归并排序":["28.0"],"快速排序":["29.0"],"基数排序":["30.0"],"选择排序":["31.0"],"代码实现":["31.3","32.3"],"希尔排序":["32.0"],"css":["33.0"],"js":["34.0","39.6"],"yarn":["35.0"],"button":["36.0"],"属性":["36.2","37.2","38.2","40.2","41.2","43.2","45.2","46.2"],"类型":["36.3","40.7","41.3","45.6"],"不可用状态":["36.4"],"图标":["36.5","40.9","46.6"],"特效":["36.6"],"icon":["37.0"],"名称":["37.3","46.3"],"尺寸":["37.4"],"颜色":["37.5"],"旋转":["37.6"],"图标列表":["37.7"],"image":["38.0"],"图片加载地址":["38.3"],"图片加载失败":["38.4"],"ranui":["39.0"],"feature":["39.1"],"situation":["39.2"],"import":["39.3"],"usage":["39.4"],"html":["39.5"],"jsx":["39.7"],"vue":["39.8"],"tsx":["39.9"],"component":["39.10"],"compatibility":["39.11"],"相关资源":["39.12"],"协议和标准":["39.13"],"input":["40.0"],"标签":["40.3"],"占位":["40.4"],"禁用":["40.5","46.4"],"值":["40.6"],"密码输入框":["40.8"],"数字输入框":["40.10"],"name":["40.11"],"status":["40.12"],"事件":["40.13","46.9"],"onchange":["40.14","46.10"],"oninput":["40.15"],"message":["41.0"],"方法":["41.4"],"preview":["43.0"],"资源地址":["43.3"],"是否可关闭":["43.4"],"skeleton":["44.0"],"tab":["45.0","46.0"],"标签名":["45.3"],"活跃标签":["45.4"],"不可操作":["45.5"],"对齐方式":["45.7"],"代码展示":["46.1"],"标识":["46.5"],"风格":["46.7"],"对齐":["46.8"],"tuple":["47.1"],"interface":["47.2"],"enum":["47.3"],"void":["47.4"],"never":["47.5"],"any":["47.6"],"unknown":["47.7"],"类型的装饰":["47.8"],"模式匹配":["48.0"],"数组类型":["48.1"],"函数":["48.3"],"构造器":["48.7"],"parameters":["50.1"],"returntype":["50.2"],"constructorparameters":["50.3"],"instancetype":["50.4"],"thisparametertype":["50.5"],"omitthisparameter":["50.6"],"partial":["50.7"],"required":["50.8"],"readonly":["50.9"],"pick":["50.10"],"exclude":["50.12"],"extract":["50.13"],"omit":["50.14"],"awaited":["50.15"],"nonnullable":["50.16"],"uppercase":["50.17"],"lowercase":["50.18"],"capitalize":["50.19"],"uncapitalize":["50.20"]},{"0":["1.17","23.2","24.3","30.3"],"1":["1.7","1.16","4.2","4.3","4.4","4.5","4.6","4.7","4.9","4.18","4.22","4.26","4.29","4.36","4.37","4.45","5.2","5.8","8.4","8.9","9.3","9.11","9.30","10.0","10.1","10.2","11.3","11.5","12.4","12.5","18.1","19.1","20.1","21.1","23.2","31.1","33.1","34.1","34.4","35.1","39.1","39.12","39.13","41.4","45.6","45.7","47.0","48.1"],"2":["1.7","1.17","4.9","4.10","4.11","4.12","4.13","4.14","4.15","4.16","4.19","4.23","4.30","4.37","4.45","8.2","8.9","9.4","9.15","10.0","10.2","10.6","11.3","11.5","12.4","12.5","14.0","18.2","19.2","20.2","21.2","33.2","34.2","34.4","35.2","39.12","48.1"],"3":["1.9","4.11","4.18","4.19","4.20","4.24","4.31","4.38","4.45","8.2","8.3","8.5","8.9","9.5","9.16","10.2","10.10","11.0","11.3","12.4","12.5","18.3","19.3","20.3","21.3","33.3","34.3","35.3","48.1"],"4":["4.12","4.22","4.23","4.24","4.25","4.26","4.27","4.32","4.39","4.45","9.1","9.6","10.14","12.4","12.5","19.1","34.4","35.4"],"5":["4.6","4.13","4.26","4.29","4.30","4.31","4.32","4.33","4.34","4.40","5.8","8.4","8.9","12.4","12.5","12.7","34.5","35.5"],"6":["4.7","4.14","4.27","4.34","4.36","4.37","4.38","4.39","4.40","4.41","4.42","4.43","4.44","4.45","4.46","34.6"],"7":["4.15","4.42","34.7"],"8":["4.16","4.43","8.9","34.8"],"9":["4.44","8.5","34.9"],"10":["4.45","34.10"],"11":["4.46","34.11"],"12":["34.12"],"13":["8.9","34.13"],"14":["34.14"],"15":["34.15"],"16":["34.16"],"17":["34.17"],"18":["34.18","39.9"],"19":["34.19","34.20"],"20":["34.21"],"21":["8.9"],"23":["4.0"],"34":["8.9"],"50":["37.5"],"100":["23.2","45.1","45.5","45.6","45.7"],"3000":["41.4"],"11111":["45.7"],"syntax":["1.0","1.1"],"abstract":["1.1","4.24"],"tree":["1.1","14.0"],"抽象语法树的作用":["1.1"],"源码是一串按照语法格式来组织的字符串":["1.1"],"人能够认识":["1.1"],"常见的":["1.2"],"ast":["1.2","1.8","1.9","1.11","1.14"],"是字面量的意思":["1.3"],"比如":["1.3","1.5","5.6","8.2","8.3","9.28","10.15","10.17","11.13","13.4"],"identifer":["1.4"],"是标识符的意思":["1.4"],"变量名":["1.4","1.16"],"属性名":["1.4","40.11"],"是语句":["1.5"],"它是可以独立执行的单位":["1.5"],"break":["1.5"],"continue":["1.5"],"debugger":["1.5"],"return":["1.5","5.5","5.8","10.13","21.1","29.3"],"声明语句是一种特殊的语句":["1.6"],"它执行的逻辑是在作用域内声明一个变量":["1.6"],"函数":["1.6","9.3"],"class":["1.6","1.17","4.33","5.8","9.21","10.13","11.12","25.3","49.5"],"是表达式":["1.7"],"特点是执行完以后有返回值":["1.7"],"这是和语句":["1.7"],"statement":["1.7"],"的区别":["1.7"],"下面是一些常见的表达式":["1.7"],"js":["1.7","4.33","4.38","4.46","5.1","5.2","5.5","5.8","7.2","7.4","9.20","19.1","20.1","22.3","31.3","32.3","34.4","34.5","34.8","34.9","34.10","34.11","34.12","34.14","34.15","34.20","34.21","39.3"],"的语法也有专门的":["1.8"],"节点来表示":["1.8"],"整个":["1.8"],"es":["1.9"],"module":["1.9"],"是语法级别的模块规范":["1.9"],"所以也有专门的":["1.9"],"节点":["1.9"],"import":["1.9","39.6","39.9"],"有":["1.9"],"种语法":["1.9"],"named":["1.9"],"directive":["1.10"],"是代表整个程序的节点":["1.10"],"comment":["1.11"],"babel":["1.11","9.14","47.3"],"的":["1.11","10.17"],"可视化查看工具":["1.12"],"这么多":["1.12"],"我们都要记住么":["1.12"],"不需要":["1.12"],"的公共属性":["1.13"],"每种":["1.13"],"都有自己的属性":["1.13"],"但是它们也有一些公共的属性":["1.13"],"type":["1.13","9.4","9.17","9.21","9.24","9.26","9.29","10.2","10.4","10.7","10.8","10.9","10.11","10.12","10.16","10.17","11.3","11.5","11.9","11.11","11.13","11.15","11.20","12.2","12.4","12.6","12.9","12.11","12.13","13.1","13.2","19.1","36.3","39.9","39.10","40.7","40.10","41.3","45.6","45.7","46.7","48.1","48.2","48.4","48.5","49.5"],"了解了这些节点":["1.14"],"就能知道平时写的代码是怎么用":["1.14"],"表示的":["1.14"],"编写词法分析器":["1.15"],"tokenizer":["1.15","1.17"],"词法分析器":["1.15"],"也叫分词器":["1.15"],"它的作用是将代码划分为一个个词法单元":["1.15"],"确定":["1.16"],"token":["1.16","1.17"],"的类型和规则":["1.16"],"增加":["1.16"],"的类型":["1.16"],"ts":["1.16","1.17","9.5","9.7","9.8","9.11","9.13","9.14","9.21","9.24","9.26","9.29","10.0","10.2","10.3","10.4","10.5","10.7","10.8","10.9","10.11","10.12","10.13","10.15","10.16","10.17","11.3","11.5","11.9","11.11","11.12","11.13","11.15","11.20","12.2","12.4","12.6","12.9","12.11","12.13","13.0","13.1","13.2","18.1","18.2","21.1","23.2","24.3","25.3","27.3","28.3","29.3","30.3","47.2","47.3","48.0","48.1","48.2","48.4","48.5","49.5"],"export":["1.16","1.17","18.1"],"enum":["1.16","9.14"],"tokentype":["1.16"],"let":["1.16","5.5","5.8","9.8","23.2","24.3","30.3"],"assign":["1.16"],"function":["1.16","4.46","5.2","5.5","9.1","9.5","18.1","19.1","20.1","22.3","31.3","34.20"],"identifier":["1.16"],"leftparen":["1.16"],"代码字符扫描":["1.17"],"在扫描字符的过程":["1.17"],"我们需要对不同的字符各自进行不同的处理":["1.17"],"具体的策略如下":["1.17"],"当前字符为分隔符":["1.17"],"如空格":["1.17"],"直接跳过":["1.17"],"不处理":["1.17"],"当前字符为字母":["1.17"],"需要继续扫描":["1.17"],"获取完整的单词":["1.17"],"如果单词为语法关键字":["1.17"],"则新建相应关键字的":["1.17"],"否则视为普通的变量名":["1.17"],"当前字符为单字符":["1.17"],"如":["1.17"],"则新建单字符对应的":["1.17"],"private":["1.17"],"tokens":["1.17"],"currentindex":["1.17"],"number":["1.17","9.1","21.1","23.2","24.3","25.3","28.3","29.3","30.3"],"编写语法分析器":["1.18"],"parser":["1.18","2.0"],"在解析出词法":["1.18"],"核心库主要是":["2.0"],"对源码进行":["2.0"],"parse":["2.0"],"可以通过":["2.0"],"plugins":["2.0"],"sourcetype":["2.0"],"等来指定":["2.0"],"的本质就是输入":["3.0"],"种经典设计模式":["4.0"],"设计模式":["4.0","4.17"],"design":["4.0"],"pattern":["4.0","4.22","4.23","4.24","4.25","4.26","4.27","4.29","4.30","4.31","4.32","4.33","4.34","4.36","4.37","4.38","4.39","4.40","4.41","4.42","4.43","4.44","4.46"],"是一套被反复使用":["4.0"],"多数人知晓的":["4.0"],"经过分类编目的":["4.0"],"代码设计经验的总结":["4.0"],"使用设计模式是为了可重用代码":["4.0"],"让代码更容易被他人理解并且保证代码可靠性":["4.0"],"在":["4.0","9.5","9.21","49.5"],"可复用面向对象软件的基础":["4.0","4.17"],"一书中所介绍的":["4.0"],"uml":["4.1"],"类图":["4.1"],"每个模式都有相应的对象结构图":["4.1"],"关联":["4.6"],"六大原则":["4.8","4.16"],"开闭原则":["4.9"],"一个软件实体应当对扩展开放":["4.9"],"对修改关闭":["4.9"],"里氏替换原则":["4.10","9.7","9.8"],"所有引用基类对象的地方能够透明地使用其子类的对象":["4.10"],"里氏代换原则告诉我们":["4.10"],"在软件中将一个基类对象替换成它的子类对象":["4.10"],"程序将不会产生任何错误和异常":["4.10"],"反过来则不成立":["4.10"],"依赖倒置原则":["4.11"],"抽象不应该依赖于具体类":["4.11"],"单一职责原则":["4.12"],"一个类只负责一个功能领域中的相应职责":["4.12"],"或者可以定义为":["4.12"],"迪米特法则":["4.13"],"最少知道原则":["4.13"],"一个软件实体应当尽可能少地与其他实体发生相互作用":["4.13"],"接口分离原则":["4.14"],"合成复用原则":["4.15"],"六大之外的":["4.15"],"模式分类":["4.17"],"创建型":["4.18","4.21"],"创建型模式":["4.18"],"creational":["4.18"],"结构型":["4.19","4.28"],"结构型模式":["4.19"],"行为型":["4.20","4.35"],"行为型模式":["4.20"],"简单工厂模式":["4.22"],"simple":["4.22","4.33"],"factory":["4.22","4.23","4.24","4.33"],"专门定义一个类":["4.22"],"工厂类":["4.22"],"来负责创建其他类的实例":["4.22"],"可以根据创建方法的参数来返回不同类的实例":["4.22"],"工厂方法模式":["4.23"],"method":["4.23"],"抽象工厂模式":["4.24"],"抽象工厂模式并不直接生成实例":["4.24"],"而是用于对产品类簇的创建":["4.24"],"提供一个创建一系列相关或相互依赖对象的接口":["4.24"],"而无须指定它们具体的类":["4.24"],"举例":["4.24","4.26","4.27","4.31","4.33","4.36","4.38","4.40","4.43","4.44","4.45","4.46"],"抽象工厂和工厂方法不同的地方在于":["4.24"],"生产产品的工厂是抽象的":["4.24"],"可口可乐公司生产可乐的同时":["4.24"],"单例模式":["4.25"],"singleton":["4.25"],"生成器模式":["4.26"],"builder":["4.26"],"也叫创建者模式":["4.26"],"它将一个复杂对象的构建与它的表示分离":["4.26"],"使得同样的构建过程可以创建不同的表示":["4.26"],"工厂模式主要是为了创建对象实例或者类簇":["4.26"],"抽象工厂":["4.26"],"关心的是最终产出":["4.26"],"创建":["4.26"],"的是什么":["4.26"],"而不关心创建的过程":["4.26"],"而建造者模式关心的是创建这个对象的整个过程":["4.26"],"甚至于创建对象的每一个细节":["4.26"],"生成器模式的主要角色如下":["4.26"],"生成器":["4.26"],"接口生命再所有类型生成器中通用的产品构造步骤":["4.26"],"原型模式":["4.27"],"prototype":["4.27"],"用原型实例指向创建对象的类":["4.27"],"使用于创建新的对象的类的共享原型的属性与方法":["4.27"],"原型模式就像复印技术":["4.27"],"装饰模式":["4.29"],"decorator":["4.29"],"向一个现有的对象添加新的功能":["4.29"],"同时又不改变其结构的设计模式被称为装饰器模式":["4.29"],"外观模式":["4.30"],"facade":["4.30"],"外观模式定义了一个高层接口":["4.30"],"为子系统中的一组接口提供一个统一的接口":["4.30"],"代理模式":["4.31"],"proxy":["4.31"],"为某个对象提供一个代理":["4.31"],"并由这个代理对象控制对原对象的访问":["4.31"],"代理模式像一个房屋中介":["4.31"],"买家只能通过中介来买房":["4.31"],"代理具备被代理类的所有功能":["4.31"],"就像房东有卖房功能":["4.31"],"中介也具有卖房功能":["4.31"],"享元模式":["4.32"],"flyweight":["4.32"],"享元模式是一种优化程序性能的模式":["4.32"],"本质为减少对象创建的个数":["4.32"],"运用共享技术复用大量细粒度的对象":["4.32"],"降低程序内存的占用":["4.32"],"提高程序的性能":["4.32"],"桥接模式":["4.33"],"将抽象部分与它的实现部分分离":["4.33"],"使它们都可以独立地变化":["4.33"],"球和人都可以进行运动":["4.33"],"但球有运动和颜色":["4.33"],"人可以运动和说话":["4.33"],"对共同部分进行抽象":["4.33"],"speed":["4.33"],"适配器模式":["4.34"],"adapter":["4.34"],"职责链模式":["4.36"],"chain":["4.36"],"of":["4.36","5.8"],"responsibility":["4.36"],"避免请求发送者与接收者耦合在一起":["4.36"],"让多个对象都有可能接收请求":["4.36"],"将这些对象连接成一条链":["4.36"],"并且沿着这条链传递请求":["4.36"],"直到有对象处理它为止":["4.36"],"职责链模式是一种对象行为型模式":["4.36"],"类似多米诺骨牌":["4.36"],"通过请求第一个条件":["4.36"],"会持续执行后续的条件":["4.36"],"直到返回结果为止":["4.36"],"场景":["4.36"],"某电商针对已付过定金的用户有优惠政策":["4.36"],"在正式购买后":["4.36"],"已经支付过":["4.36"],"命令模式":["4.37"],"command":["4.37"],"将一个请求封装为一个对象":["4.37"],"从而让我们可用不同的请求对客户进行参数化":["4.37"],"命令模式是一种对象行为型模式":["4.37"],"其别名为动作":["4.37"],"action":["4.37"],"模式或事务":["4.37"],"transaction":["4.37"],"模式":["4.37"],"命令模式由三种角色构成":["4.37"],"发布者":["4.37"],"解释器模式":["4.38"],"interpreter":["4.38"],"定义一个语言的文法":["4.38"],"并且建立一个解释器来解释该语言中的句子":["4.38"],"这里的":["4.38"],"语言":["4.38"],"是指使用规定格式和语法的代码":["4.38"],"解释器模式是一种类行为型模式":["4.38"],"给定一个语言":["4.38"],"定义它的文法的一种表示":["4.38"],"并定义一个解释器":["4.38"],"该解释器使用该表示来解释语言中的句子":["4.38"],"迭代器模式":["4.39"],"iterator":["4.39"],"一个相对简单的模式":["4.39"],"目前绝大多数语言都内置了迭代器":["4.39"],"以至于大家都不觉得这是一种设计模式":["4.39"],"迭代器并不只迭代数组":["4.39"],"迭代器可以中止":["4.39"],"提供一种方法来访问聚合对象":["4.39"],"中介者模式":["4.40"],"mediator":["4.40"],"对象和对象之间借助第三方中介者进行通信":["4.40"],"用一个中介对象":["4.40"],"中介者":["4.40"],"来封装一系列的对象交互":["4.40"],"中介者使各对象不需要显式地相互引用":["4.40"],"从而使其耦合松散":["4.40"],"而且可以独立地改变它们之间的交互":["4.40"],"中介者模式又称为调停者模式":["4.40"],"它是一种对象行为型模式":["4.40"],"中介者模式将一个网状的系统结构变成一个以中介者对象为中心的星形结构":["4.40"],"在这个星型结构中":["4.40"],"使用中介者对象与其他对象的一对多关系来取代原有对象之间的多对多关系":["4.40"],"所有成员通过中介者交互":["4.40"],"方便拓展新的成员":["4.40"],"例如下面的例子":["4.40"],"备忘录模式":["4.41"],"memento":["4.41"],"在不破坏封装的前提下":["4.41"],"捕获一个对象的内部状态":["4.41"],"并在该对象之外保存这个状态":["4.41"],"观察者模式":["4.42"],"observer":["4.42"],"定义对象之间的一种一对多依赖关系":["4.42"],"使得每当一个对象状态发生改变时":["4.42"],"其相关依赖对象皆得到通知并被自动更新":["4.42"],"观察者模式的别名包括发布":["4.42"],"状态模式":["4.43"],"state":["4.43"],"允许一个对象在其内部状态改变时改变它的行为":["4.43"],"对象看起来似乎修改了它的类":["4.43"],"其别名为状态对象":["4.43"],"objects":["4.43"],"for":["4.43","5.2","23.2","24.3","30.3"],"states":["4.43"],"其实就是用一个对象或者数组记录一组状态":["4.43"],"每个状态对应一个实现":["4.43"],"实现的时候根据状态挨个去运行实现":["4.43"],"状态模式是一种对象行为型模式":["4.43"],"策略模式":["4.44"],"strategy":["4.44"],"定义一些列算法":["4.44"],"把他们封装起来":["4.44"],"并且可以相互替换":["4.44"],"就是把看似毫无联系的代码提取封装":["4.44"],"复用":["4.44"],"使之更容易被理解和拓展":["4.44"],"常见的用于一次":["4.44"],"if":["4.44","34.8"],"判断":["4.44"],"switch":["4.44","34.9"],"枚举":["4.44","47.3"],"数据字典等流程判断语句中":["4.44"],"也称为政策模式":["4.44"],"policy":["4.44"],"策略模式是一种对象行为型模式":["4.44"],"使用策略模式时":["4.44"],"我们可以定义一些策略类":["4.44"],"每一个策略类中封装一种具体的算法":["4.44"],"在这里":["4.44"],"每一个封装算法的类我们都可以称之为一种策略":["4.44"],"模板方法模式":["4.45"],"定义一个操作中算法的框架":["4.45"],"而将一些步骤延迟到子类中":["4.45"],"模板方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤":["4.45"],"模板方法模式的使用场景":["4.45"],"模板方法模式常被架构师用于搭建项目的框架":["4.45"],"架构师定好了框架的骨架":["4.45"],"程序员继承框架的结构之后":["4.45"],"负责往里面填空":["4.45"],"钩子方法":["4.45"],"各种框架中的钩子函数往往在初始化时就规定各个钩子函数的名称以及执行时机":["4.45"],"对于使用者只需要在钩子函数中注入自定义逻辑代码即可":["4.45"],"回调函数":["4.45"],"回调函数在特定的时机执行":["4.45"],"但是具体的操作交给具体的函数实现":["4.45"],"把变化的部分封装成一个函数剩下的就成了模板":["4.45"],"模板方法模式具体应用又分为三类":["4.45"],"抽象方法":["4.45"],"一个抽象方法由抽象类声明":["4.45"],"由其具体子类实现":["4.45"],"具体方法":["4.45"],"一个具体方法由一个抽象类或具体类声明并实现":["4.45"],"其子类可以进行覆盖也可以直接继承":["4.45"],"一个钩子方法由一个抽象类或具体类声明并实现":["4.45"],"而其子类可能会加以扩展":["4.45"],"通常在父类中给出的实现是一个空实现":["4.45"],"并以该空实现作为方法的默认实现":["4.45"],"当然钩子方法也可以提供一个非空的默认实现":["4.45"],"通过在子类中实现的钩子方法对父类方法的执行进行约束":["4.45"],"实现子类对父类行为的反向控制":["4.45"],"泡一杯咖啡":["4.45"],"先我们先来泡一杯咖啡":["4.45"],"一般来说":["4.45"],"泡咖啡的步骤通常如下":["4.45"],"先把水煮沸":["4.45"],"用沸水冲泡咖啡":["4.45"],"把咖啡倒进杯子":["4.45"],"访问者模式":["4.46"],"visitor":["4.46"],"提供一个作用于某对象结构中的各元素的操作表示":["4.46"],"它使我们可以在不改变各元素的类的前提下定义作用于这些元素的新操作":["4.46"],"访问者模式是一种对象行为型模式":["4.46"],"访问者模式是一种较为复杂的行为型设计模式":["4.46"],"它包含访问者和被访问元素两个主要组成部分":["4.46"],"这些被访问的元素通常具有不同的类型":["4.46"],"且不同的访问者可以对它们进行不同的访问操作":["4.46"],"访问者模式使得用户可以在不修改现有系统的情况下扩展系统的功能":["4.46"],"为这些不同类型的元素增加新的操作":["4.46"],"在使用访问者模式时":["4.46"],"被访问元素通常不是单独存在的":["4.46"],"它们存储在一个集合中":["4.46"],"这个集合被称为":["4.46"],"对象结构":["4.46"],"访问者通过遍历对象结构实现对其中存储的元素的逐个操作":["4.46"],"dom事件绑定":["4.46"],"var":["4.46","22.3","31.3","34.5"],"bindevent":["4.46"],"dom":["4.46"],"系统地学习设计模式后":["4.47"],"study":["4.48"],"plan":["4.48"],"javascript":["4.48","9.5","9.6"],"设计模式统计":["4.48"],"es6":["4.48"],"概述":["5.0","5.3"],"functional":["5.0"],"programming":["5.0"],"fp":["5.0"],"就是编程规范之一":["5.0"],"我们常听说的编程规范还有面向对象编程":["5.0"],"函数基本知识":["5.1"],"函数可以储存在变量中":["5.1"],"函数可以作为参数":["5.1"],"高阶函数":["5.2"],"higher":["5.2"],"order":["5.2"],"可以把函数作为参数传递给另一个函数":["5.2"],"可以把函数作为另一个函数的返回结果":["5.2"],"函数作为参数":["5.2"],"foreach":["5.2"],"array":["5.2","5.6","23.2","24.3","25.3","27.3","28.3","29.3","30.3","32.3"],"fn":["5.2","5.8"],"闭包":["5.3"],"有权访问另一个函数作用域中的变量的函数":["5.3"],"本质":["5.3"],"函数执行的时候会入栈":["5.3"],"纯函数":["5.4"],"概念":["5.4"],"相同的输入永远会得到相同的输出":["5.4"],"而且没有任何可观察的副作用":["5.4"],"类似数学中的函数":["5.4"],"y":["5.4"],"f":["5.4","5.6"],"x":["5.4","5.6","5.8"],"例子":["5.4"],"slice":["5.4"],"函数就是纯函数":["5.4"],"柯里化":["5.5"],"haskell":["5.5"],"brooks":["5.5"],"curry":["5.5"],"解决上述硬编码的问题":["5.5"],"checkage":["5.5"],"min":["5.5"],"age":["5.5","9.13"],"函数的组合":["5.6"],"纯函数和柯里化很容易让我们写出洋葱代码":["5.6"],"h":["5.6"],"g":["5.6","12.10","35.4"],"获取数组的最后一个元素并转化为大写字母":["5.6"],"toupper":["5.6"],"first":["5.6"],"revers":["5.6"],"函数的组合可以让我们把细粒度的函数":["5.6"],"重新组合成一个新的函数":["5.6"],"lodash":["5.6"],"中的组合函数":["5.6"],"point":["5.7"],"free":["5.7"],"functor":["5.8"],"函子":["5.8"],"为什么要了解函子":["5.8"],"br":["5.8","21.0"],"目前没有解决如何在函数式编程中":["5.8"],"把副作用控制在可控的范围内":["5.8"],"异常处理":["5.8"],"异步操作等等":["5.8"],"容器":["5.8"],"包含值和值的变形关系":["5.8"],"这个变形关系就是函数":["5.8"],"是一个特殊的容器":["5.8"],"通过一个普通对象来实现":["5.8"],"该对象具有":["5.8"],"map":["5.8"],"方法":["5.8"],"方法可以运行一个函数对值进行处理":["5.8"],"变形关系":["5.8"],"functor函子":["5.8"],"container":["5.8"],"函子内部要有一个值":["5.8"],"constructor":["5.8","10.13","25.3"],"value":["5.8","11.5","11.13","11.14","12.2","40.6","48.1"],"这个值是传入进来的":["5.8"],"且不对外公布":["5.8"],"this":["5.8","10.13","25.3","48.6"],"map方法":["5.8"],"接受一个处理值的函数":["5.8"],"去处理这个值":["5.8"],"并且要把处理的值":["5.8"],"传给一个新的函子":["5.8"],"最后返回这个新的函子":["5.8"],"new":["5.8","10.15","23.2","48.8"],"新建一个函子":["5.8"],"r":["5.8","36.1","37.1","37.5","38.4","39.10","40.8","40.14","40.15","41.3","45.1","45.3","45.4","45.5","45.6","45.7","46.1","46.3","46.4","46.5","46.6"],"of方法用来返回一个函子对象":["5.8"],"static":["5.8"],"传入值":["5.8"],"返回一个新的函子对象":["5.8"],"函数式编程与异步编程":["5.9"],"图片压缩源码分析":["6.0"],"onload":["7.1","7.3"],"document":["7.4"],"类型系统不是图灵完备":["8.0"],"各种逻辑都能写么":["8.0"],"但好像没发现数值相关的逻辑":["8.0"],"没错":["8.0"],"数值相关的逻辑比较绕":["8.0"],"被我单独摘了出来":["8.0"],"就是这节要讲的内容":["8.0"],"我们知道了数值计算要转换为对数组类型的操作":["8.2"],"那么加法的实现很容易想到":["8.2"],"构造两个数组":["8.2"],"然后合并成一个":["8.2"],"取":["8.2"],"length":["8.2","8.7","23.2","25.3"],"就是构造一个长度为":["8.2"],"加法是构造数组":["8.3"],"那减法怎么做呢":["8.3"],"减法是从数值中去掉一部分":["8.3"],"很容易想到可以通过数组类型的提取来做":["8.3"],"是":["8.3","13.3","45.4"],"unknown":["8.3","12.6","48.1"],"我们把加法转换为了数组构造":["8.4"],"把减法转换为了数组提取":["8.4"],"那乘法怎么做呢":["8.4"],"为了解释乘法":["8.4"],"我去翻了下小学教材":["8.4"],"找到了这样一张图":["8.4","8.5"],"乘以":["8.4"],"就相当于":["8.4"],"乘法是递归的累加":["8.5"],"那除法不就是递归的累减么":["8.5"],"我再去翻了下小学教材":["8.5"],"我们有":["8.5"],"个苹果":["8.5"],"分给美羊羊":["8.5"],"个":["8.5"],"数组长度可以取":["8.7"],"来得到":["8.7"],"但是字符串类型不能取":["8.7"],"所以我们来实现一个求字符串长度的高级类型":["8.7"],"能够做计数了":["8.8"],"那也就能做两个数值的比较":["8.8"],"我们往一个数组类型中不断放入元素取长度":["8.8"],"如果先到了":["8.8"],"a":["8.8","9.24","9.28","13.2","13.4","14.18","35.5","39.2"],"那就是":["8.8"],"b":["8.8","9.24","9.28","13.2","13.4"],"大":["8.8"],"否则是":["8.8"],"谈到了数值运算":["8.9"],"就不得不提起经典的":["8.9"],"数列的计算":["8.9"],"数列是":["8.9"],"的类型系统":["9.0"],"类型是什么":["9.1"],"类型具体点来说就是指":["9.1"],"boolean":["9.1"],"string":["9.1","9.13","10.8","10.13","11.20","12.9","13.1","21.1","47.2"],"等基础类型和":["9.1"],"object":["9.1"],"等复合类型":["9.1"],"它们是编程语言提供的对不同内容的抽象":["9.1"],"不同类型变量占据的内存大小不同":["9.1"],"类型的变量会分配":["9.1"],"类型系统的分类":["9.2"],"简单的类型系统":["9.3"],"变量":["9.3"],"类等都可以声明类型":["9.3"],"支持泛型的类型系统":["9.4"],"泛型的英文是":["9.4"],"generic":["9.4"],"通用的类型":["9.4"],"它可以代表任何一种类型":["9.4"],"也叫做类型参数":["9.4"],"它给类型系统增加了一些灵活性":["9.4"],"在整体比较固定":["9.4"],"支持类型编程的类型系统":["9.5"],"java":["9.5"],"里面":["9.5"],"拿到了对象的类型就能找到它的类":["9.5"],"进一步拿到各种信息":["9.5"],"所以类型系统支持泛型就足够了":["9.5"],"但是在":["9.5"],"对象可以字面量的方式创建":["9.5"],"还可以灵活的增删属性":["9.5"],"拿到对象并不能确定什么":["9.5"],"所以要支持对传入的类型参数做进一步的处理":["9.5"],"对传入的类型参数":["9.5"],"泛型":["9.5"],"做各种逻辑运算":["9.5"],"产生新的类型":["9.5"],"这就是类型编程":["9.5"],"比如上面那个":["9.5"],"getprops":["9.5"],"的函数":["9.5"],"类型可以这样写":["9.5"],"类型安全和型变":["9.6"],"typescript":["9.6","9.10","9.17","9.21","11.0","11.1","11.15","13.0","13.5","47.8","48.0","49.1","49.5"],"给":["9.6"],"covariant":["9.7"],"对具体成员的输出参数进行一次类型转换":["9.7"],"且类型转换的准则是":["9.7","9.8"],"其中协变是很好理解的":["9.7"],"比如我们有两个":["9.7"],"interface":["9.7","9.13","10.15","48.8"],"contravariant":["9.8"],"是对具体成员的输入参数进行一次类型转换":["9.8"],"我们有这样两个函数":["9.8"],"printhobbies":["9.8"],"cat":["9.8"],"void":["9.8"],"console":["9.8","40.14"],"log":["9.8"],"hobbies":["9.8"],"printname":["9.8"],"animal":["9.8"],"invariant":["9.9"],"逆变和协变都是型变":["9.9"],"是针对父子类型而言的":["9.9"],"非父子类型自然就不会型变":["9.9"],"也就是不变":["9.9"],"非父子类型之间不会发生型变":["9.9"],"只要类型不一样就会报错":["9.9"],"那类型之间的父子关系是怎么确定的呢":["9.9"],"好像也没有看到":["9.9"],"支持的类型":["9.11"],"静态类型系统的目的是把类型检查从运行时提前到编译时":["9.11"],"那":["9.11"],"类型系统中肯定要把":["9.11"],"可以描述函数":["9.13","47.2"],"对象":["9.13","9.21","47.2","49.5"],"构造器的结构":["9.13","47.2"],"iperson":["9.13","47.2"],"name":["9.13","10.13","11.5","34.5","34.14","37.3","37.5","47.2"],"是一系列值的复合":["9.14","47.3"],"transpiler":["9.14","47.3"],"postcss":["9.14"],"terser":["9.14"],"prettier":["9.14"],"类型的装饰":["9.15"],"extends":["9.17","9.24","10.7","10.8","10.11","11.20","12.6","12.9","13.1","13.2","48.1","49.1"],"里的条件判断是":["9.17","49.1"],"叫做条件类型":["9.17"],"conditional":["9.17"],"infer":["9.18","10.2","13.1","48.1","49.2"],"如何提取类型的一部分呢":["9.18","49.2"],"答案是":["9.18","49.2"],"比如提取元组类型的第一个元素":["9.18","49.2"],"联合类型":["9.19","49.3"],"交叉类型":["9.20","49.4"],"intersection":["9.20","49.4"],"类似":["9.20","49.4"],"中的与运算符":["9.20"],"但是作用于类型":["9.20"],"对应的类型是索引类型":["9.21","49.5"],"index":["9.21","10.17","29.3","45.4","49.5"],"那么如何对索引类型作修改呢":["9.21","49.5"],"答案是映射类型":["9.21","49.5"],"maptype":["9.21","49.5"],"t":["9.21","9.26","12.13","18.1","48.1","49.5"],"key":["9.21","11.14","12.13","45.4","46.5","49.5"],"in":["9.21","12.13","49.5"],"keyof":["9.21","12.13","49.5"],"判断类型的类型":["9.22"],"如何判断一个类型是":["9.23"],"any":["9.23","9.30","18.1","48.1"],"类型呢":["9.23"],"之前我们实现":["9.24"],"是这样写的":["9.24"],"还记得怎么判断":["9.25"],"union":["9.25"],"never":["9.26","13.2","48.1"],"在条件类型中也比较特殊":["9.26"],"如果条件类型左边是类型参数":["9.26"],"并且传入的是":["9.26"],"那么直接返回":["9.26"],"testnever":["9.26"],"元组类型怎么判断呢":["9.27"],"类型之间是有父子关系的":["9.28"],"更具体的那个是子类型":["9.28"],"和":["9.28","48.1"],"的交叉类型":["9.28"],"如何提取索引类型中的可选索引呢":["9.29"],"这也要利用可选索引的特性":["9.29"],"可选索引的值为":["9.29"],"undefined":["9.29"],"和值类型的联合类型":["9.29"],"过滤可选索引":["9.29"],"就要构造一个新的索引类型":["9.29"],"过程中做过滤":["9.29"],"类型与任何类型的交叉都是":["9.30"],"也就是":["9.30"],"结果是":["9.30"],"字符串可以和正则做模式匹配":["10.0"],"找到匹配的部分":["10.0"],"提取子组":["10.0"],"之后可以用":["10.0"],"等引用匹配的子组":["10.0"],"abc":["10.0"],"replace":["10.0","12.9"],"数组类型想提取第一个元素的类型怎么做呢":["10.2","48.1"],"arr":["10.2","12.4","12.6","22.3","25.3","31.3","34.5","48.1"],"用它来匹配一个模式类型":["10.2","48.1"],"提取第一个元素的类型到通过":["10.2","48.1"],"声明的局部变量里返回":["10.2","48.1"],"可以提取第一个元素":["10.3"],"当然也可以提取最后一个元素":["10.3"],"修改下模式类型就行":["10.3"],"我们分别取了首尾元素":["10.4"],"当然也可以取剩余的数组":["10.4"],"比如取去掉了最后一个元素的数组":["10.4"],"同理可得":["10.5"],"的实现":["10.5"],"判断字符串是否以某个前缀开头":["10.7"],"也是通过模式匹配":["10.7"],"startwith":["10.7"],"str":["10.7","10.8","11.9","12.9","13.1","19.1"],"字符串可以匹配一个模式类型":["10.8"],"提取想要的部分":["10.8"],"自然也可以用这些再构成一个新的类型":["10.8"],"比如实现字符串替换":["10.8"],"replacestr":["10.8","12.9"],"from":["10.8","12.9","39.9"],"能够匹配和替换字符串":["10.9","48.2"],"那也就能实现去掉空白字符的":["10.9","48.2"],"不过因为我们不知道有多少个空白字符":["10.9","48.2"],"所以只能一个个匹配和去掉":["10.9","48.2"],"需要递归":["10.9","48.2"],"先实现":["10.9","48.2"],"trimright":["10.9","48.2"],"函数类型可以通过模式匹配来提取参数的类型":["10.11","48.4"],"func":["10.11"],"能提取参数类型":["10.12"],"同样也可以提取返回值类型":["10.12"],"方法里可以调用":["10.13","48.6"],"比如这样":["10.13","12.13"],"dong":["10.13","11.8","12.10"],"hello":["10.13"],"i":["10.13","23.2","24.1","24.3","30.3"],"m":["10.13"],"构造器类型可以用":["10.15","48.8"],"声明":["10.15","48.8"],"使用":["10.15","11.14","39.4","48.8"],"xx":["10.15"],"的语法":["10.15"],"getinstancetype":["10.16"],"是提取构造器返回值类型":["10.16"],"那同样也可以提取构造器的参数类型":["10.16"],"索引类型也同样可以用模式匹配提取某个索引的值的类型":["10.17"],"这个用的也挺多的":["10.17"],"react":["10.17","39.9"],"d":["10.17","12.10"],"里的":["10.17"],"propswithref":["10.17"],"的高级类型":["10.17","12.9"],"就是通过模式匹配提取了":["10.17"],"ref":["10.17","39.9"],"的值的类型":["10.17"],"类型编程主要的目的就是对类型做各种转换":["11.0"],"那么如何对类型做修改呢":["11.0"],"类型系统支持":["11.0"],"种可以声明任意类型的变量":["11.0"],"有这样一个元组类型":["11.3","12.4"],"tuple":["11.3","11.5"],"我想给这个元组类型再添加一些类型":["11.3"],"可以在后面添加":["11.4"],"有这样两个元组":["11.5"],"tuple1":["11.5"],"tuple2":["11.5"],"我们想把它们合并成这样的元组":["11.5"],"思路很容易想到":["11.5"],"提取元组中的两个元素":["11.5"],"构造成新的元组":["11.5"],"我们想把一个字符串字面量类型的":["11.7"],"guang":["11.7"],"转为首字母大写的":["11.7"],"需要用到字符串类型的提取和重新构造":["11.7"],"我们再来实现":["11.8"],"到":["11.8"],"dongdongdong":["11.8"],"可以修改自然也可以删除":["11.9"],"我们再来做一个删除一段字符串的案例":["11.9"],"删除字符串中的某个子串":["11.9"],"之前我们分别实现了参数和返回值的提取":["11.11"],"那么重新构造就是用这些提取出的类型做下修改":["11.11"],"构造一个新的类型即可":["11.11"],"比如在已有的函数类型上添加一个参数":["11.11"],"索引类型是聚合多个元素的类型":["11.12"],"对象等都是索引类型":["11.12"],"比如这就是一个索引类型":["11.12"],"映射的过程中可以对":["11.13"],"做下修改":["11.13"],"除了可以对":["11.14"],"做修改":["11.14"],"也可以对":["11.14"],"as":["11.14"],"这叫做重映射":["11.14"],"提供了内置的高级类型":["11.15"],"来创建索引类型":["11.15"],"索引类型的索引可以添加":["11.16"],"readonly":["11.16","11.18","12.13"],"的修饰符":["11.16"],"代表只读":["11.16"],"同理":["11.17","11.19"],"索引类型还可以添加可选修饰符":["11.17"],"可以添加":["11.18"],"也可以去掉可选修饰符":["11.19"],"可以在构造新索引类型的时候根据值的类型做下过滤":["11.20"],"obj":["11.20"],"record":["11.20"],"递归是把问题分解为一系列相似的小问题":["12.0"],"通过函数不断调用自身来解决这一个个小问题":["12.0"],"直到满足结束条件":["12.0"],"的递归复用":["12.1"],"先用":["12.2"],"promise":["12.2","16.3","18.0","48.0"],"热热身":["12.2"],"实现一个提取不确定层数的":["12.2"],"中的":["12.2"],"类型的高级类型":["12.2"],"ttt":["12.2"],"我们把它反过来":["12.4"],"也就是变成":["12.4"],"既然递归可以做循环用":["12.5"],"那么像查找元素这种自然也就可以实现":["12.5"],"比如查找":["12.5"],"中是否存在":["12.5"],"是就返回":["12.5"],"可以查找自然就可以删除":["12.6"],"只需要改下返回结果":["12.6"],"构造一个新的数组返回":["12.6"],"我们学过数组类型的构造":["12.7"],"如果构造的数组类型元素个数不确定":["12.7"],"也需要递归":["12.7"],"比如传入":["12.7"],"和元素类型":["12.7"],"构造一个长度为":["12.7"],"学模式匹配的时候":["12.9"],"我们实现过一个":["12.9"],"我们想把字符串字面量类型的每个字符都提取出来组成联合类型":["12.10"],"也就是把":["12.10"],"转为":["12.10"],"o":["12.10","26.0"],"n":["12.10","31.1"],"我们实现了数组的反转":["12.11"],"自然也可以实现字符串类型的反转":["12.11"],"同样是递归提取和构造":["12.11"],"对象类型的递归":["12.13"],"也可以叫做索引类型的递归":["12.13"],"我们之前实现了索引类型的映射":["12.13"],"给索引加上了":["12.13"],"的修饰":["12.13"],"toreadonly":["12.13"],"如果这个索引类型层数不确定呢":["12.13"],"当类型参数为联合类型":["13.0"],"并且在条件类型左边直接引用该类型参数的时候":["13.0"],"会把每一个元素单独传入来做类型运算":["13.0"],"最后再合并成联合类型":["13.0"],"这种语法叫做分布式条件类型":["13.0"],"比如这样一个联合类型":["13.0"],"camelcase":["13.1"],"我们实现过":["13.1"],"就是提取字符串中的字符":["13.1"],"首字母大写以后重新构造一个新的":["13.1"],"判断联合类型我们会这样写":["13.2"],"false":["13.2","36.6"],"true":["13.2"],"当传入联合类型时":["13.2"],"会返回":["13.2"],"isunionresult":["13.2"],"css":["13.3","33.2","39.12"],"命名规范":["13.3"],"用":["13.3"],"block":["13.3","36.3","36.4","39.2","39.10","41.3"],"element":["13.3"],"modifier":["13.3"],"的形式来描述某个区块下面的某个元素的某个状态的样式":["13.3"],"那么我们可以写这样一个高级类型":["13.3"],"传入":["13.3","15.0"],"我们再来实现一个全组合的高级类型":["13.4"],"也是联合类型相关的":["13.4"],"希望传入":["13.4"],"的时候":["13.4"],"能够返回所有的组合":["13.4"],"ba":["13.4"],"ab":["13.4"],"这种全组合问题的实现思路就是两两组合":["13.4"],"组合出的字符串再和其他字符串两两组和":["13.4"],"联合类型中的每个类型都是相互独立的":["13.5"],"对它做了特殊处理":["13.5"],"在计算机科学中":["14.0"],"二叉树":["14.0"],"binary":["14.0"],"是每个节点最多只有两个分支":["14.0"],"即不存在分支度大于":["14.0"],"的节点":["14.0"],"的树结构":["14.0"],"通常分支被称作":["14.0"],"一棵深度为":["14.1","14.2"],"k":["14.2"],"树":["14.5","14.6","14.7"],"树是":["14.7"],"红黑树是一种平衡二叉查找树的变体":["14.8"],"遍历":["14.9"],"常见算法题":["14.13"],"输入两棵二叉树":["14.18"],"的使用":["15.0"],"观察一个文件是否改变":["16.1"],"参数":["16.4","18.3","19.3","21.3"],"allsettled":["18.0"],"代码实现":["18.1","19.1","20.1","21.1"],"usedictoptions":["18.1"],"options":["18.1"],"const":["18.1","23.2","24.3","27.3","28.3","29.3","30.3","34.11","39.9"],"optionsdata":["18.1"],"使用方法":["18.2"],"参数说明":["18.3","19.3","21.3"],"changecase":["19.1"],"url":["20.0","34.14"],"yyyy":["21.0"],"description":["21.1","29.3","32.3"],"时间格式化":["21.1"],"param":["21.1","29.3","32.3"],"datetime":["21.1"],"时间戳":["21.1"],"fmt":["21.1"],"时间格式":["21.1"],"说明":["21.3"],"必填":["21.3"],"bubble":["22.0"],"比较相邻的元素":["22.1"],"冒泡排序":["22.2","34.4"],"bubblesort":["22.3"],"len":["22.3","31.3"],"bucket":["23.0"],"设置一个定量的数组当作空桶":["23.1"],"count":["23.2","24.0"],"list":["23.2","24.3","27.3","28.3","29.1","29.3","30.3"],"max":["23.2","24.3","30.3"],"countlist":["23.2"],"桶排序最好情况下使用线性时间":["23.3"],"sort":["24.0","28.0","30.0","31.0"],"找出待排序的数组中最大和最小的元素":["24.1"],"统计数组中每个值为":["24.1"],"计数排序":["24.2"],"getmax":["24.3","30.3"],"计数排序是一个稳定的排序算法":["24.4"],"当输入的元素是":["24.4"],"heap":["25.0","25.3"],"将初始待排序关键字序列":["25.1"],"r1":["25.1"],"r2":["25.1"],"rn":["25.1"],"构建成大顶堆":["25.1"],"此堆为初始的无序区":["25.1"],"将堆顶元素":["25.1"],"堆排序":["25.2"],"size":["25.3","37.4","37.5"],"十种常见排序算法可以分为两大类":["26.0"],"比较类排序":["26.0"],"通过比较来决定元素间的相对次序":["26.0"],"由于其时间复杂度不能突破":["26.0"],"nlogn":["26.0"],"因此也称为非线性时间比较类排序":["26.0"],"insert":["27.0","27.3"],"从第一个元素开始":["27.1"],"该元素可以认为已经被排序":["27.1"],"插入排序":["27.2"],"插入排序在实现上":["27.4"],"merge":["28.0"],"把长度为":["28.1"],"归并排序":["28.2"],"combine":["28.3"],"left":["28.3","29.3","39.2"],"right":["28.3","29.3","36.3","36.4","39.10","41.3"],"归并排序是一种稳定的排序方法":["28.4"],"quick":["29.0"],"快速排序使用分治法来把一个串":["29.1"],"快速排序":["29.2"],"设置基准值pivot":["29.3"],"partition":["29.3"],"radix":["30.0"],"取得数组中的最大数":["30.1"],"基数排序":["30.2"],"基数排序基于分配排序":["30.4"],"所以是稳定的":["30.4"],"但基数排序的性能比桶排序要略差":["30.4"],"每一次关键字的桶分配都需要":["30.4"],"selection":["31.0"],"个记录的直接选择排序可经过":["31.1"],"趟直接选择排序得到有序结果":["31.1"],"具体算法描述如下":["31.1"],"初始状态":["31.1"],"选择排序":["31.2"],"selectionsort":["31.3"],"表现最稳定的排序算法之一":["31.4"],"shell":["32.0","35.4"],"先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序":["32.1"],"具体算法描述":["32.1"],"选择一个增量序列":["32.1"],"希尔排序":["32.2","32.3"],"是简单插入排序的改进版":["32.3"],"它与插入排序的不同之处在于":["32.3"],"它会优先比较距离较远的元素":["32.3"],"希尔排序又叫缩小增量排序":["32.3"],"希尔排序的核心在于间隔序列的设定":["32.4"],"开发技巧":["33.0","34.0"],"禁止选中文本":["33.2"],"截取字符串":["34.1"],"去除末尾最后一个逗号":["34.2"],"桌面通知":["34.3"],"实现思路":["34.4"],"比较相邻的两个元素":["34.4"],"如果前一个比后一个大":["34.4"],"则交换位置":["34.4"],"比较完第一轮的时候":["34.4"],"根据数组中某一项进行排序":["34.5"],"禁用":["34.6"],"禁用鼠标右键":["34.7"],"判断逻辑优化":["34.8"],"逻辑优化":["34.9"],"数组合并":["34.10"],"扩展运算符简写":["34.10"],"longhand":["34.10"],"根据数组对象属性查找特定对象":["34.11"],"将对象转换为对象数组":["34.12"],"在数组中查找最大值和最小值":["34.13"],"下载文件":["34.14","34.15"],"downloadfile":["34.14"],"xlsx":["34.15"],"添加ajax参数":["34.15"],"responsetype":["34.15"],"arraybuffer":["34.15"],"data":["34.15","38.4"],"取消冒泡":["34.19"],"获得滚动条的滚动距离":["34.20"],"生成随机数范围":["34.21"],"的安装和使用":["35.0"],"特点":["35.2","39.1"],"常用命令":["35.4"],"安装yarn":["35.4"],"npm":["35.4","35.5"],"install":["35.4"],"yarn":["35.4","35.5"],"安装成功后":["35.4"],"查看版本号":["35.4"],"version":["35.4"],"创建文件夹":["35.4"],"md":["35.4"],"进入yarn文件夹":["35.4"],"cd":["35.4"],"初始化项目":["35.4"],"同npm":["35.4"],"init":["35.4"],"执行输入信息后":["35.4"],"会生成package":["35.4"],"json文件":["35.4"],"与":["35.5"],"命令比较":["35.5"],"在你安装":["35.5"],"按钮":["36.0"],"按钮有四种类型":["36.3"],"div":["36.3","36.4","37.1","37.3","37.4","37.5","37.6","37.7","39.10","40.1","41.1","41.3","43.1","44.1","45.1","45.3","45.5","45.6","45.7"],"style":["36.3","36.4","37.1","37.3","37.4","37.5","37.6","37.7","39.2","39.10","40.1","41.1","41.3","43.1","44.1","45.1","45.3","45.5","45.6","45.7"],"display":["36.3","36.4","37.1","37.3","37.4","37.5","37.6","39.2","39.10","41.1","41.3"],"inline":["36.3","36.4","39.2","39.10","41.1","41.3"],"margin":["36.3","36.4","39.2","39.10","41.3","43.1","44.1"],"8px":["36.3","36.4","39.10","41.3"],"bottom":["36.3","39.10","41.3"],"12px":["36.3","39.10","41.3"],"disabled":["36.4","40.5","45.5","46.4"],"添加":["36.4"],"属性即可让按钮处于不可用状态":["36.4"],"同时按钮样式也会改变":["36.4"],"icon":["36.5","37.1","37.5","40.9","46.6"],"当需要在":["36.5"],"button":["36.5","36.6","39.10","41.3"],"内嵌入":["36.5"],"时":["36.5"],"可以设置":["36.5"],"属性":["36.5","45.6","46.4"],"或者直接在":["36.5"],"effect":["36.6"],"如果需要纯净的":["36.6"],"可以加上":["36.6"],"图标":["37.0","45.0"],"flex":["37.1","37.3","37.4","37.5","37.6"],"根据名称选择不同的图标":["37.3"],"align":["37.4","45.7","46.8"],"items":["37.4"],"color":["37.5"],"lock":["37.5"],"spin":["37.6"],"设置":["37.6"],"开启旋转":["37.6"],"传入数字控制旋转的速度":["37.6"],"数字越小旋转越快":["37.6"],"图片":["38.0"],"xml":["38.1"],"src":["38.3","38.4","39.2","43.3"],"fallback":["38.4"],"配置的图片加载失败":["38.4"],"兜底的图片地址":["38.4"],"下面是默认加载失败图片":["38.4"],"img":["38.4","39.2"],"image":["38.4"],"基于":["39.0","39.1"],"项目情况":["39.2"],"4px":["39.2"],"href":["39.2"],"https":["39.2"],"github":["39.2"],"com":["39.2"],"chaxus":["39.2"],"ran":["39.2"],"shields":["39.2"],"io":["39.2"],"导入方式":["39.3"],"支持按需引入":["39.3"],"syntheticevent":["39.9"],"useref":["39.9"],"ranui":["39.9"],"filepreview":["39.9"],"overview":["39.10"],"primary":["39.10"],"主要按钮":["39.10"],"兼容性":["39.11"],"优秀的组件设计":["39.12"],"在线生成":["39.12"],"渐变色":["39.12"],"输入框":["40.0"],"label":["40.3","45.3","45.7","46.1","46.3","46.6"],"提供类似于":["40.3"],"placeholder":["40.4"],"与原生":["40.4"],"通过":["40.5","48.1"],"支持密码明文和密文切换":["40.8"],"可以设置一个":["40.9"],"类似于原生":["40.10"],"input":["40.10","40.14","40.15"],"状态":["40.12"],"error":["40.12"],"默认色值":["40.12"],"ff4d4f":["40.12"],"event":["40.13","46.9"],"文本改变的时候触发":["40.14"],"输入时触发":["40.15"],"全局提示":["41.0"],"不同的提示类型":["41.3"],"onclick":["41.3"],"message":["41.3","41.4"],"info":["41.3","41.4"],"这是一条提示":["41.3"],"组件提供了一些静态方法":["41.4"],"使用方式和参数如下":["41.4"],"可以只传一个参数":["41.4"],"提示的内容":["41.4"],"默认提示":["41.4"],"毫秒":["41.4"],"文件预览":["43.0"],"width":["43.1","44.1","45.1","45.5","45.6","45.7"],"100px":["43.1","44.1"],"closeable":["43.4"],"骨架屏":["44.0"],"骨架长度跟随父级元素的长度":["44.1"],"tabs":["45.1","45.4","45.5","45.6","45.7","46.1","46.6"],"tab":["45.3","45.4","45.7","46.1","46.3","46.4","46.5","46.6"],"的属性":["45.3","45.4"],"设置标签的名称":["45.3"],"active":["45.4","45.5","46.5"],"标签的唯一标识":["45.4"],"rankey":["45.4"],"用于确定同一个":["45.4"],"下":["45.4"],"的唯一值":["45.4"],"如果":["45.4"],"没有设置":["45.4"],"默认等于":["45.4"],"不采用":["45.4"],"字段是防止":["45.4"],"设置不可点击的标签":["45.5"],"c":["45.5"],"设置标签页的种类":["45.6"],"如果不设置":["45.6"],"默认为":["45.6"],"flat":["45.6"],"设置标签的对齐方式":["45.7"],"默认":["45.7"],"start":["45.7"],"line":["45.7"],"tab1":["45.7","46.1","46.6"],"每个":["46.3","46.4","46.5","46.6"],"需要指定一个名称":["46.3"],"用于显示标签头":["46.3"],"可以指定":["46.4","46.6"],"用来禁用该标签页":["46.4"],"需要指定一个标识":["46.5"],"没有会默认以序列号为":["46.5"],"作用在":["46.5"],"配合":["46.6"],"实现图标加文字的效果":["46.6"],"home":["46.6"],"切换完成时触发":["46.10"],"类型系统中的类型":["47.0"],"基本类型":["47.0"],"元组":["47.1"],"接口":["47.2"],"代表空":["47.4"],"代表不可达":["47.5"],"是任意类型":["47.6"],"是未知类型":["47.7"],"除了描述类型的结构外":["47.8"],"的类型也同样可以做模式匹配":["48.0"],"比如这样一个":["48.0"],"类型":["48.0"],"getarrayfirstitem":["48.1"],"类型参数":["48.1"],"约束为只能是数组类型":["48.1"],"数组元素是":["48.1"],"也就是可以是任何值":["48.1"],"函数同样也可以做类型匹配":["48.3"],"用对象":["48.6"],"方法名的方式调用的时候":["48.6"],"构造器和函数的区别是":["48.7"],"类型系统中的类型运算":["49.0"],"内置的高级类型":["50.0"],"构造器类型和函数类型的区别就是可以被":["50.3"],"提取了构造器参数的类型":["50.4"],"比如用模式匹配可以实现":["50.21"],"parameters":["50.21"],"returntype":["50.21"]},{"0":["4.38","8.5","8.9","22.3","24.4","26.0","28.3","37.6"],"1":["4.44","9.17","9.26","14.0","25.1","29.3","45.4"],"2":["4.3","4.26","4.44","8.3","9.17","9.26","26.0"],"3":["1.7","4.4","4.26","4.37","4.44","9.21","12.2","34.4","39.12","49.5"],"4":["4.5","4.44","39.12"],"5":["38.4"],"7":["37.6"],"8":["9.1"],"18":["5.5"],"22":["5.5"],"23":["4.17"],"30":["37.4"],"50":["4.36","37.1","37.3","37.6"],"100":["4.36","45.3","45.4"],"200":["4.36"],"500":["4.36"],"1111":["9.14"],"1959":["32.0"],"11111":["45.1","45.5","45.6"],"22222":["45.6","45.7"],"33333":["45.7"],"tree":["1.0"],"但是计算机并不认识":["1.1"],"想让计算机认识就要转成一种数据结构":["1.1"],"通过不同的对象来保存不同的数据":["1.1"],"并且按照依赖关系组织起来":["1.1"],"这种数据结构就是抽象语法树":["1.1"],"节点":["1.2"],"let":["1.3","1.15","1.17","5.2","29.3"],"name":["1.3","4.27","4.40","9.7","9.8","10.15","11.12","20.1","34.11","37.1","37.4","37.6"],"value":["1.3","1.16","35.4","40.14","40.15","48.0"],"中":["1.3","5.1"],"参数名等各种声明和引用的名字":["1.4"],"都是":["1.4"],"我们知道":["1.4"],"或者":["1.5","10.13","48.6"],"if":["1.5","4.36","4.43","4.46","21.1","23.2","24.3","28.3","30.3","34.20","39.9"],"语句":["1.5"],"while":["1.5","1.17","23.2","28.3"],"for":["1.5","22.3","29.3","31.3"],"还有声明语句":["1.5"],"表达式语句等":["1.5"],"import":["1.6","39.7"],"export":["1.6","21.1"],"等":["1.6","4.43"],"比如下面这些语句都是声明语句":["1.6"],"a":["1.7","1.9","4.40","4.44","9.9","9.20","10.0","12.13","13.0","45.5"],"function":["1.7","1.15","4.27","4.36","4.40","4.44","4.45","5.6","10.11","10.12","11.11","15.0","34.4","34.14","34.21","48.4","48.5"],"class":["1.7","4.24","4.26","4.38","9.13","13.3","47.2"],"this":["1.7","1.17","4.33","4.38","4.40","4.45","40.14","40.15"],"的内容是":["1.8"],"classbody":["1.8"],"属性是":["1.8"],"classproperty":["1.8"],"js":["1.9","1.15","4.31","4.36","4.39","4.40","4.44","4.45","5.6","9.11","34.1","34.2","34.3","34.6","34.7","34.13","34.16","34.18","34.19","49.4"],"c":["1.9","4.40","10.0","12.13","13.0","13.2","13.4","24.1","35.5"],"d":["1.9","12.13","35.5"],"from":["1.9"],"default":["1.9","36.6"],"它有":["1.10","1.11"],"body":["1.10","39.5"],"属性代表程序体":["1.10"],"存放":["1.10","4.38"],"最外层节点是":["1.11"],"program":["1.11"],"可以通过":["1.12"],"axtexplorer":["1.12"],"net":["1.12","1.14"],"这个网站来可视化的查看":["1.12"],"这个网站可以查看代码":["1.12"],"parse":["1.12"],"节点的类型":["1.13"],"start":["1.13","1.16"],"end":["1.13","1.16","37.4"],"loc":["1.13"],"和":["1.13","5.6","13.4","14.18","35.5","39.12"],"代表该节点在源码中的开始和结束下标":["1.13"],"当然也不需要记":["1.14"],"可以用":["1.14"],"astexpoler":["1.14"],"可视化的查看":["1.14"],"便于进行后续的语法分析":["1.15"],"比如下面的这段代码":["1.15"],"foo":["1.15"],"rightparen":["1.16"],"leftcurly":["1.16"],"rightcurly":["1.16"],"type":["1.16","4.22","4.46","8.2","8.8","9.18","9.20","10.3","10.5","11.0","11.1","11.7","11.8","11.12","11.14","11.17","11.19","12.5","12.7","12.10","13.0","13.3","34.11","36.4","36.6","48.0","49.1","49.2"],"string":["1.16","1.17","9.7","9.11","9.29","10.7","10.9","10.15","10.17","11.7","11.9","11.12","11.15","12.2","12.10","12.11","12.13","27.3","47.0","48.2"],"number":["1.16","8.8","9.7","9.11","9.13","9.20","9.26","11.15","32.3","40.10","47.0","47.2"],"raw":["1.16"],"定义":["1.16"],"类型到规则的映射":["1.16"],"const":["1.16","1.17","4.27","4.36","4.40","4.44","9.13","9.14","10.13","18.2","21.1","32.3","34.10","34.12","34.13","39.6","47.2"],"tokens":["1.16"],"source":["1.17"],"constructor":["1.17","4.33","4.38"],"input":["1.17","39.9","40.8","40.12"],"tokenize":["1.17"],"length":["1.17","8.0","8.3","8.4","12.7","22.3","24.3","27.3","28.3","30.3","31.3"],"currentchar":["1.17"],"startindex":["1.17","23.2"],"根据语法规则进行":["1.17"],"分组":["1.17"],"循环内部":["1.17"],"token":["1.18","4.41"],"之后":["1.18"],"我们就可以进入语法分析阶段了":["1.18"],"在这个阶段":["1.18"],"语法":["2.0"],"功能是把源码转成":["2.0"],"ast":["2.0"],"traverse":["2.0"],"通过":["2.0","10.2"],"visitor":["2.0"],"函数对遍历到的":["2.0"],"转换":["3.0"],"输出":["3.0"],"不过设计模式并不仅仅只有这":["4.0"],"种":["4.0"],"随着软件开发行业的发展":["4.0"],"越来越多的新模式不断诞生并得以应用":["4.0"],"有经验的开发者在学习设计模式可以和过往的经验互相印证":["4.0"],"更容易理解这些设计模式":["4.0"],"设计模式一般包含模式名称":["4.0"],"问题":["4.0"],"目的":["4.0"],"解决方案":["4.0"],"效果等组成要素":["4.0"],"问题描述了应该在何时使用模式":["4.0"],"它包含了设计中存在的问题以及问题存在的原因":["4.0"],"同时为了展示对象间的交互细节":["4.1"],"有些时候会用到":["4.1"],"图来介绍其如何运行":["4.1"],"组合":["4.4","13.4"],"聚合":["4.5"],"关联关系是用一条直线表示的":["4.6"],"它描述不同类的对象之间的结构关系":["4.6"],"它是一种静态关系":["4.6"],"通常与运行状态无关":["4.6"],"依赖":["4.7"],"依赖关系是用一套带箭头的虚线表示的":["4.7"],"如":["4.7"],"即软件实体应尽量在不修改原有代码的情况下进行扩展":["4.9"],"任何软件都需要面临一个很重要的问题":["4.9"],"即它们的需求会随时间的推移而发生变化":["4.9"],"当软件系统需要面对新的需求时":["4.9"],"我们应该尽量保证系统的设计框架是稳定的":["4.9"],"如果一个软件实体使用的是一个子类对象的话":["4.10"],"那么它不一定能够使用基类对象":["4.10"],"例如":["4.10","4.29"],"我喜欢动物":["4.10"],"那我一定喜欢狗":["4.10"],"因为狗是动物的子类":["4.10"],"但是我喜欢狗":["4.10"],"不能据此断定我喜欢动物":["4.10"],"具体类应当依赖于抽象":["4.11"],"换言之":["4.11"],"要针对接口编程":["4.11"],"而不是针对实现编程":["4.11"],"依赖倒转原则要求我们在程序代码中传递参数时或在关联关系中":["4.11"],"就一个类而言":["4.12"],"应该只有一个引起它变化的原因":["4.12"],"单一职责原则告诉我们":["4.12"],"一个类不能太":["4.12"],"累":["4.12"],"如果一个系统符合迪米特法则":["4.13"],"那么当其中某一个模块发生修改时":["4.13"],"就会尽量少地影响其他模块":["4.13"],"扩展会相对容易":["4.13"],"这是对软件实体之间通信的限制":["4.13"],"使用多个专门的接口":["4.14"],"而不使用单一的总接口":["4.14"],"即客户端不应该依赖那些它不需要的接口":["4.14"],"尽量使用对象组合":["4.15"],"而不是继承来达到复用的目的":["4.15"],"合成复用原则就是在一个新的对象里通过关联关系":["4.15"],"包括组合关系和聚合关系":["4.15"],"来使用一些已有的对象":["4.15"],"学习心得":["4.16"],"六大原则中":["4.16"],"开闭原则":["4.16"],"里氏替换原则":["4.16"],"一书中设计模式有":["4.17"],"个":["4.17","24.4"],"pattern":["4.18","4.19","4.20"],"对类的实例化过程进行了抽象":["4.18"],"能够将模块中对象的创建和对象的使用分离":["4.18"],"为了使结构更加清晰":["4.18"],"外界对于这些对象只需要知道它们共同的接口":["4.18"],"structural":["4.19"],"描述如何将类或者对":["4.19"],"象结合在一起形成更大的结构":["4.19"],"就像搭积木":["4.19"],"behavioral":["4.20"],"是对在不同的对象之间划分责任和算法的抽象化":["4.20"],"行为型模式不仅仅关注类和对象的结构":["4.20"],"被创建的实例通常都具有共同的父类":["4.22"],"举例":["4.22","4.23","4.25","4.30","4.32","4.39","4.41"],"简单工厂模式像一个代工厂":["4.22"],"一个工厂可以生产多种产品":["4.22"],"举个例子":["4.22"],"一个饮料加工厂同时帮百事可乐和可口可乐生产":["4.22"],"加工厂根据输入参数":["4.22"],"来生产不同的产品":["4.22"],"ts":["4.22","4.24","4.26","4.27","8.2","8.7","8.8","9.17","9.18","9.20","9.25","11.0","11.4","11.7","11.8","11.14","11.16","11.17","11.18","11.19","12.5","12.7","12.10","13.3","48.8","49.2"],"可乐抽象类":["4.22"],"又称为工厂模式":["4.23"],"工厂父类负责定义创建产品对象的公共接口":["4.23"],"而工厂子类则负责生成具体的产品对象":["4.23"],"即通过不同的工厂子类来创建不同的产品对象":["4.23"],"工厂方法和简单工厂有一些区别":["4.23"],"简单工厂是由一个代工厂生产不同的产品":["4.23"],"也需要生产装可乐的瓶子和箱子":["4.24"],"瓶子和箱子也是可口可乐专属定制的":["4.24"],"同样百事可乐公司也会有这个需求":["4.24"],"这个时候我们的工厂不仅仅是生产可乐饮料的工厂":["4.24"],"还必须同时生产同一主题的瓶子和箱子":["4.24"],"所以它是一个抽象的主题工厂":["4.24"],"专门生产同一主题的不同商品":["4.24"],"可乐抽象类和派生类":["4.24"],"cola":["4.24"],"cocacola":["4.24"],"extends":["4.24","8.8","9.5","9.9","9.18","9.26","9.29","10.2","10.3","10.4","10.5","10.9","10.12","10.16","10.17","11.5","11.7","11.8","11.9","11.11","11.13","11.14","11.15","12.5","12.7","12.10","12.11","12.13","48.2","48.4","48.5","49.2"],"pepsicola":["4.24"],"单例模式确保某一个类只有一个实例":["4.25"],"并提供一个访问它的全剧访问点":["4.25"],"单例模式下":["4.25"],"对应类只能生成一个实例":["4.25"],"就像一个王国只能有一个国王":["4.25"],"具体生成器":["4.26"],"提供构造过程的不同实现":["4.26"],"具体生成器也可以构造不遵循通用接口的产品":["4.26"],"产品":["4.26"],"是最终生成的对象":["4.26"],"由不同生成器构造的产品无需属于同一类层次构造或接口":["4.26"],"指挥者":["4.26"],"定义调用构造步骤的顺序":["4.26"],"这样你就可以创建和服用特定的产品配置":["4.26"],"客户端":["4.26"],"必须将某个生成器对象与主管类关联":["4.26"],"一般情况下":["4.26"],"你只需要通过指挥者类构造函数的参数进行一次性关联即可":["4.26"],"抽象建造者":["4.26"],"abstract":["4.26"],"public":["4.26"],"根据原对象复印出一个新对象":["4.27"],"并根据需求对新对象进行微调":["4.27"],"因为不是构造函数":["4.27"],"所以不用大写":["4.27"],"car":["4.27"],"drive":["4.27"],"马自达":["4.27"],"它是作为现有的类的一个包装":["4.29"],"可以将装饰器理解为游戏人物购买的装备":["4.29"],"lol":["4.29"],"中的英雄刚开始游戏时只有基础的攻击力和法强":["4.29"],"但是在购买的装备后":["4.29"],"在触发攻击和技能时":["4.29"],"能够享受到装备带来的输出加成":["4.29"],"使得子系统更容易使用":["4.30"],"不仅简化类中的接口":["4.30"],"而且实现调用者和接口的解耦":["4.30"],"外观模式又称为门面模式":["4.30"],"它是一种结构型设计模式模式":["4.30"],"外观模式提供了简单明确的接口":["4.30"],"但是在内部众多子系统功能进行整合":["4.30"],"就像图片缓存":["4.30"],"此外代理实例还可以帮助被代理实例进行一些额外处理":["4.31"],"比如中介可以帮助房东筛选优质买家的功能":["4.31"],"帮助房东":["4.31"],"pass":["4.31"],"掉一些不符合条件的买家":["4.31"],"还有消息队列也是该模式":["4.31"],"参考":["4.31"],"koa":["4.31"],"中的代理模式":["4.31"],"把":["4.31"],"response":["4.31"],"上的一些属性和方法代理出来":["4.31"],"方便使用":["4.31"],"以下情况可以使用享元模式":["4.32"],"有大量相似的对象":["4.32"],"占用了大量内存":["4.32"],"对象中大部分状态可以抽离为外部状态":["4.32"],"音乐服务根据收费划分出免费用户和会员用户":["4.32"],"免费用户只能听部分免费音乐":["4.32"],"会员用户可以听全部的音乐":["4.32"],"并且可以下载":["4.32"],"虽然权限上二者间有一些区别":["4.32"],"运动模块":["4.33"],"x":["4.33","34.8"],"y":["4.33"],"run":["4.33"],"console":["4.33","4.36","4.45","5.8","40.15"],"log":["4.33","4.36","4.45","5.8","40.14","40.15"],"运动起来":["4.33"],"适配器模式是用来解决两个接口不兼容的情况":["4.34"],"不需要改变已有的接口":["4.34"],"通过包装一层的方式":["4.34"],"实现两个接口正常协作":["4.34"],"当我们试图调用模块或者对象的某个接口时":["4.34"],"却发现这个接口的格式并不符合目前的需求":["4.34"],"元定金的用户会收到":["4.36"],"元的优惠券":["4.36"],"元定金的用户可以收到":["4.36"],"元优惠券":["4.36"],"没有支付过定金的用户只能正常购买":["4.36"],"order500":["4.36"],"ordertype":["4.36"],"pay":["4.36"],"stock":["4.36"],"true":["4.36","9.24","12.5","43.4"],"invoker":["4.37"],"发出命令":["4.37"],"调用命令对象":["4.37"],"不知道如何执行与谁执行":["4.37"],"接收者":["4.37"],"receiver":["4.37"],"提供对应接口处理请求":["4.37"],"不知道谁发起请求":["4.37"],"命令对象":["4.37"],"接收命令":["4.37"],"调用接收者对应接口处理发布者的请求":["4.37"],"和接收者":["4.37"],"context":["4.38"],"list":["4.38","32.3","35.4"],"终结符表达式":["4.38"],"sum":["4.38"],"非终结符表达式":["4.38"],"运算结果":["4.38"],"get":["4.38","35.4"],"return":["4.38","5.6","9.5","19.1","24.3","30.3","32.3"],"set":["4.38","35.4"],"而不用暴露这个对象的内部表示":["4.39"],"其别名为游标":["4.39"],"cursor":["4.39"],"迭代器模式是一种对象行为型模式":["4.39"],"迭代器帮助请求方获取数据":["4.39"],"避免直接操作数据聚合类":["4.39"],"使数据聚合类专注存储数据":["4.39"],"具体应用有分页等功能":["4.39"],"分页功能的迭代器将专门负责操作分页数据":["4.39"],"将操作逻辑和数据源分离":["4.39"],"var":["4.39","4.45","20.1","34.4","34.14"],"一场测试结束后":["4.40"],"公布结果":["4.40"],"告知解答出题目的人挑战成功":["4.40"],"否则挑战失败":["4.40"],"在这段代码中":["4.40"],"b":["4.40","4.44","10.0","12.13","13.0","14.18","19.1","46.5"],"之间没有直接发生关系":["4.40"],"而是通过另外的":["4.40"],"playermiddle":["4.40"],"对象建立链接":["4.40"],"姑且将之当成是中介者模式了":["4.40"],"player":["4.40"],"以便日后对象使用或者对象恢复到以前的某个状态":["4.41"],"它是一种对象行为型模式":["4.41"],"其别名为":["4.41"],"备忘录模式提供了一种状态恢复的实现机制":["4.41"],"使得用户可以方便地回到一个特定的历史步骤":["4.41"],"当新的状态无效或者存在问题时":["4.41"],"可以使用暂时存储起来的备忘录将状态复原":["4.41"],"订阅":["4.42"],"publish":["4.42"],"subscribe":["4.42"],"模式":["4.42"],"模型":["4.42"],"视图":["4.42"],"model":["4.42"],"view":["4.42"],"源":["4.42"],"监听器":["4.42"],"状态模式用于解决复杂对象的状态转换以及不同状态下行为的封装问题":["4.43"],"当系统中某个对象存在多个状态":["4.43"],"这些状态之间可以进行转换":["4.43"],"所以对象在不同状态下具有不同行为时可以使用状态模式":["4.43"],"状态模式将一个对象的状态从该对象中分离出来":["4.43"],"封装到专门的状态类中":["4.43"],"使得对象状态可以灵活变化":["4.43"],"比如超级玛丽":["4.43"],"就可能同时有好几个状态比如":["4.43"],"跳跃":["4.43"],"移动":["4.43"],"射击":["4.43"],"蹲下":["4.43"],"如果对这些动作一个个进行处理判断":["4.43"],"需要多个":["4.43"],"根据传入不同的策略类":["4.44"],"使环境类执行不同策略类中的算法":["4.44"],"在游戏中":["4.44"],"我们每玩完一局游戏都有对用户进行等级评价":["4.44"],"比如":["4.44","9.1","9.17","39.3","49.1"],"s":["4.44","48.2"],"级":["4.44"],"倍经验":["4.44"],"其他":["4.44"],"用函数来表达如下":["4.44"],"改为策略模式":["4.44"],"分成两个函数来写":["4.44"],"加糖和牛奶":["4.45"],"我们用":["4.45"],"es5":["4.45"],"来得到一杯香浓的咖啡吧":["4.45"],"coffee":["4.45"],"prototype":["4.45"],"boilwater":["4.45"],"水煮开了":["4.45"],"brewcoffeegriends":["4.45"],"pourincup":["4.45"],"addsugarandmilk":["4.45"],"封装":["4.45"],"将实现的细节交给类的内部":["4.45"],"init":["4.45"],"fn":["4.46"],"data":["4.46","34.9","34.10","34.11","34.12"],"addeventlistener":["4.46"],"false":["4.46","9.24","12.5"],"else":["4.46"],"attachevent":["4.46"],"on":["4.46"],"e":["4.46","12.13","39.9"],"在ie中this指向":["4.46"],"你可以在过往的开发经历中发现":["4.47"],"系列之我们来聊聊装饰器":["4.48"],"设计模式之生成器模式":["4.48"],"https":["4.48"],"juejin":["4.48"],"im":["4.48"],"面向过程编程":["5.0"],"面向对象的编程思维方式":["5.0"],"把现实世界中的事物抽象成程序世界的类和对象":["5.0"],"通过封装":["5.0"],"继承和多态演示事物事件的联系":["5.0"],"函数编程的思维方式":["5.0"],"把现实世界的事物和事物之间的":["5.0"],"函数可以作为返回值":["5.1"],"在":["5.1","14.7"],"javascript":["5.1"],"item":["5.2","12.6"],"of":["5.2"],"filter":["5.2"],"result":["5.2","12.6","12.11"],"当执行完后会移除栈":["5.3"],"但是堆上的作用域成员因为被外部引用而不能释放":["5.3"],"因此内部函数依然可以访问外部函数的成员":["5.3"],"栈":["5.3"],"栈会自动分配内存":["5.3"],"对一个数组":["5.4"],"相同的输入永远得到相同的输出":["5.4"],"splice":["5.4"],"就是非纯函数":["5.4"],"相同的输入可能会得到不同的结果":["5.4"],"因为会改变原数组":["5.4"],"函数式编程不会保留计算中间的结果":["5.4"],"所以变量不可变":["5.4"],"无状态":["5.4"],"可以把一个函数的执行结果交给另一个函数去执行":["5.4"],"纯函数可以缓存":["5.4"],"因为相同的输入必然有相同的输出":["5.4"],"checkage18":["5.5"],"es6":["5.5"],"进行简化":["5.5"],"当一个函数有多个参数的时候":["5.5"],"可以先传递一部分":["5.5"],"flow":["5.6"],"flowright":["5.6"],"都可以组合多个函数":["5.6"],"是从左到右执行":["5.6"],"是从右到左执行":["5.6"],"自己实现一个":["5.6"],"函数":["5.6","9.4","10.10"],"composeright":["5.6"],"args":["5.6","10.11","10.16"],"我们可以把数据处理的过程定义成与数据无关的合成运算":["5.7"],"不需要用到代表数据的那个参数":["5.7"],"只要把简单的运算步骤合成到一起":["5.7"],"打印出来的是一个函子":["5.8"],"不是值":["5.8"],"永远不会把这个值取出来":["5.8"],"需要改变这个值的时候":["5.8"],"使用map方法传入一个函数去处理":["5.8"],"进行链式调用":["5.8"],"总结":["5.8"],"函数式编程的运算不直接操作值":["5.8"],"而是由函子完成":["5.8"],"函子就是一个实现了":["5.8"],"契约的对象":["5.8"],"我们可以把函子想象成一个盒子":["5.8"],"这个盒子里封装了一个值":["5.8"],"想要处理盒子中的值":["5.8"],"我们需要给盒子的":["5.8"],"方法传递一个处理值的函数":["5.8"],"纯函数":["5.8"],"由这个函数对值进行处理":["5.8"],"最终":["5.8"],"方法返回一个包含新值的盒子":["5.8"],"maybe":["5.8"],"我们在编程过程中可能会遇到很多的错误":["5.8"],"需要对这些错误进行相应的处理":["5.8"],"函子的作用就是可以对外部的空值情况做处理":["5.8"],"控制副作用在允许的范围之内":["5.8"],"maybe函子":["5.8"],"isnothing":["5.8"],"null":["5.8","39.9"],"函数式编程初探":["5.9"],"document":["7.2","34.6","34.7","39.9"],"fun":["7.3"],"onreadystatechange":["7.4"],"一个文档的":["7.4"],"这是类型体操的第四个套路":["8.0"],"typescript":["8.0","9.5","9.14","9.15","10.0","11.3","12.0"],"类型系统没有加减乘除运算符":["8.0"],"怎么做数值运算呢":["8.0"],"不知道大家有没有注意到数组类型取":["8.0"],"的数组类型":["8.2","8.3"],"再构造一个长度为":["8.2"],"然后合并成一个数组":["8.2"],"构造多长的数组是不确定的":["8.2"],"需要递归构造":["8.2"],"这个我们实现过":["8.2"],"提取出":["8.3"],"个元素之后":["8.3"],"剩下的数组再取":["8.3"],"也就是说乘法就是多个加法结果的累加":["8.4"],"那么我们在加法的基础上":["8.4"],"多加一个参数来传递中间结果的数组":["8.4"],"算完之后再取一次":["8.4"],"就能实现乘法":["8.4"],"分给懒羊羊":["8.5"],"分给沸羊羊":["8.5"],"最后剩下":["8.5"],"所以":["8.5"],"字符串长度不确定":["8.7"],"明显要用递归":["8.7"],"每次取一个并计数":["8.7"],"直到取完":["8.7"],"就是字符串长度":["8.7"],"num1":["8.8"],"num2":["8.8"],"countarr":["8.8"],"这样的数列":["8.9"],"有当前的数是前两个数的和的规律":["8.9"],"f":["8.9","12.13"],"n":["8.9","10.9","14.2","23.3","24.4","25.1","28.1","30.4","48.2"],"个字节的内存":["9.1"],"而":["9.1","48.1"],"类型的变量则会分配":["9.1"],"给变量声明了不同的类型就代表了会占据不同的内存空间":["9.1"],"不同类型变量可做的操作不同":["9.1"],"类型可以做加减乘除等运算":["9.1"],"就不可以":["9.1"],"复合类型中不同类型的对象可用的方法不同":["9.1"],"date":["9.1"],"编译器会基于声明的类型做类型检查":["9.3"],"类型不匹配时会报错":["9.3"],"这是最基础的类型系统":["9.3"],"能保证类型安全":["9.3"],"但有些死板":["9.3"],"比如一个":["9.3"],"部分变量的类型有变化的情况下":["9.4"],"可以减少很多重复代码":["9.4"],"比如上面的":["9.4"],"add":["9.4"],"有了泛型之后就可以这样写":["9.4"],"java":["9.4","9.9"],"t":["9.4","9.5","10.9","11.15","48.2","48.4","48.5"],"getpropvalue":["9.5"],"object":["9.5","11.13","11.14","18.1","47.0"],"key":["9.5","9.29","11.13","11.20","18.1","35.4"],"keyof":["9.5","9.29","10.17","11.20"],"obj":["9.5","9.13","9.29","11.12","11.13","11.14","12.13"],"这里的":["9.5"],"就是对类型参数":["9.5"],"的类型运算":["9.5"],"的类型系统就是第三种":["9.5"],"添加了一套静态类型系统":["9.6"],"是为了保证类型安全的":["9.6"],"也就是保证变量只能赋同类型的值":["9.6"],"对象只能访问它有的属性":["9.6"],"方法":["9.6"],"animal":["9.7"],"age":["9.7","11.12","34.5","47.2"],"cat":["9.7"],"的参数":["9.8"],"guang":["9.8","12.13","13.3"],"是":["9.8"],"参数":["9.8","15.0","16.3","20.0","20.3"],"person":["9.8","9.13","10.15","47.2","48.8"],"的子类型":["9.8","9.28"],"那么问题来了":["9.8"],"能赋值给":["9.8"],"么":["9.8"],"的继承":["9.9"],"像":["9.9"],"里面的类型都是通过":["9.9"],"继承的":["9.9"],"如果":["9.9"],"类型系统":["9.10"],"的运行时类型拿过来":["9.11"],"也就是":["9.11"],"boolean":["9.11","47.0"],"tuple":["9.12","9.18","49.2"],"implements":["9.13","47.2"],"typescriptcompiler":["9.14"],"tsc":["9.14"],"此外":["9.14"],"还支持字面量类型":["9.14"],"也就是类似":["9.14"],"aaaa":["9.14"],"除了描述类型的结构外":["9.15"],"的类型系统还支持描述类型的属性":["9.15","47.8"],"类型运算":["9.16"],"res":["9.17"],"first":["9.18","10.2","12.6","48.1"],"unknown":["9.18","10.2","10.4","11.5","12.5"],"union":["9.19","13.0","49.3"],"类似":["9.19","49.3"],"代表对类型做合并":["9.20"],"objtype":["9.20"],"是查询索引类型中所有的索引":["9.21","49.5"],"叫做索引查询":["9.21","49.5"],"是取索引类型某个索引的值":["9.21","49.5"],"叫做索引访问":["9.21","49.5"],"是用于遍历联合类型的运算符":["9.21","49.5"],"比如我们把一个索引类型的值变成":["9.21","49.5"],"个元素的数组":["9.21","49.5"],"要根据它的特性来":["9.23"],"类型与任何类型的交叉都是":["9.23"],"问题出在":["9.24"],"any":["9.24","9.29","10.16","11.20","12.2"],"类型么":["9.25"],"要根据它遇到条件类型时会分散成单个传入做计算的特性":["9.25"],"当":["9.26"],"为":["9.26"],"时":["9.26"],"它和数组有什么区别呢":["9.27"],"元组类型的":["9.27"],"就是联合类型":["9.28"],"因为更具体":["9.28"],"如果允许父类型赋值给子类型":["9.28"],"就叫做":["9.28"],"record":["9.29","12.2"],"in":["9.29","11.13","11.20","27.4"],"as":["9.29","11.20"],"pick":["9.29"],"可以用这个特性判断":["9.30"],"类型":["9.30","16.4","18.3","19.3","21.3"],"联合类型作为类型参数出现在条件类型左侧时":["9.30"],"会分散成单个类型传入":["9.30"],"最后合并":["9.30"],"never":["9.30","10.2"],"作为类型参数出现在条件类型左侧时":["9.30"],"的类型也同样可以做模式匹配":["10.0"],"数组类型":["10.1"],"getfirst":["10.2"],"类型参数":["10.2","11.0"],"getlastvalue":["10.3"],"arr":["10.3","10.4","10.5","11.3","12.5","30.1","34.4"],"infer":["10.4","10.8","10.9","10.11","10.17","11.0","11.5","12.6","12.9","48.2"],"rest":["10.4","10.9","12.6","13.1","48.2"],"字符串类型":["10.6"],"prefix":["10.7","10.8","12.9"],"to":["10.8","12.9"],"str":["10.9","11.7","11.8","12.10","12.11"],"func":["10.12","11.11"],"new":["10.13","10.16","50.3"],"用对象":["10.13"],"方法名的方式调用的时候":["10.13"],"就指向那个对象":["10.13","48.6"],"但是方法也可以用":["10.13","48.6"],"call":["10.13","48.6"],"apply":["10.13"],"调用":["10.13"],"构造器类型":["10.14"],"personconstructor":["10.15"],"constructortype":["10.16"],"p":["10.17","48.0"],"r":["10.17","25.1","31.1","36.3","36.4","36.6","37.3","37.4","37.6","38.1","40.12","43.1","44.1"],"undefined":["10.17"],"叫做类型别名":["11.0"],"其实就是声明一个变量存储某个类型":["11.0"],"的":["11.1"],"怎么做呢":["11.3","12.10"],"类型变量不支持修改":["11.3"],"我们可以构造一个新的元组类型":["11.3"],"同样也可以在前面添加":["11.4"],"one":["11.5"],"other":["11.5"],"onefirst":["11.5"],"onesecond":["11.5"],"otherfirst":["11.5"],"的变换":["11.8"],"同样是提取和重新构造":["11.8"],"substr":["11.9"],"arg":["11.11"],"比如把索引类型的":["11.14"],"变为大写":["11.14"],"k":["11.15","14.1"],"symbol":["11.15"],"那我们就可以实现给索引类型添加":["11.16"],"修饰的高级类型":["11.16"],"修饰":["11.18"],"当然也可以去掉":["11.18"],"valuetype":["11.20"],"就完成了问题的求解":["12.0"],"的高级类型支持类型参数":["12.0"],"可以做各种类型运算逻辑":["12.0"],"这里是":["12.2"],"层":["12.2"],"类型是索引类型":["12.2"],"数量不确定":["12.2","12.5"],"一涉及到这个就要想到用递归来做":["12.2"],"每次只处理一层的提取":["12.2"],"然后剩下的到下次递归做":["12.2"],"这个学完了提取和构造很容易写出来":["12.4"],"否则返回":["12.5"],"从长度不固定的数组中查找某个元素":["12.5"],"这时候就应该想到递归":["12.5"],"的该元素类型构成的数组":["12.7"],"suffix":["12.9"],"很明显也是提取和构造":["12.10"],"dong":["12.13"],"数量":["12.13"],"层数":["12.13"],"不确定":["12.13"],"类型体操中应该自然的想到递归":["12.13"],"我们在之前的映射上加入递归的逻辑":["12.13"],"我们想把其中的":["13.0"],"大写":["13.0"],"就可以这样写":["13.0"],"left":["13.1"],"right":["13.1","41.1"],"uppercase":["13.1"],"提取":["13.1"],"左右的字符":["13.1"],"把右边字符大写之后构造成新的字符串":["13.1"],"当传入其他类型时":["13.2"],"这就是分布式条件类型带来的认知成本":["13.2"],"我们先来看这样一个类型":["13.2"],"返回构造出的":["13.3"],"名":["13.3"],"这样使用":["13.3"],"bemresult":["13.3"],"aaa":["13.3"],"bbb":["13.3"],"warning":["13.3","39.10","41.4"],"success":["13.3","41.4"],"它的实现就是三部分的合并":["13.3"],"就是":["13.4"],"也就是遇到字符串类型":["13.5"],"条件类型的时候会把每个类型单独传入做计算":["13.5"],"最后把每个类型的计算结果合并成联合类型":["13.5"],"条件类型左边是联合类型的时候就会触法这种处理":["13.5"],"左子树":["14.0"],"或":["14.0"],"右子树":["14.0"],"二叉树的分支具有左右次序":["14.0"],"不能随意颠倒":["14.0"],"sup":["14.0"],"二叉树的性质":["14.0"],"在二叉树的第":["14.0"],"且有":["14.1"],"的有":["14.2"],"bst":["14.3"],"又称二叉查找树或二叉排序树":["14.3"],"avl":["14.4"],"树的变体":["14.7"],"它的左右子树高差有可能大于":["14.8"],"options":["15.0"],"build":["15.0","39.2"],"说明":["16.3","16.4","18.3","19.3"],"方法接受一个数组作为参数":["18.0"],"reactive":["18.1"],"optionskey":["18.1"],"keys":["18.1"],"apilists":["18.1"],"map":["18.1"],"optionsdata":["18.2"],"usedictoptions":["18.2"],"param":["18.2"],"必填":["18.3","19.3"],"switch":["19.1"],"case":["19.1"],"replace":["19.1"],"w":["19.1"],"g":["19.1"],"使用方法":["19.2","20.2","21.2"],"默认值":["19.3","21.3"],"geturlparam":["20.1"],"构造一个含有目标参数的正则表达式对象":["20.1"],"参数说明":["20.3"],"mm":["21.0","21.1"],"dd":["21.0","21.1"],"timeformat":["21.1"],"yyyy":["21.1"],"如果为null":["21.1"],"则格式化当前时间":["21.1"],"datetime":["21.3"],"时间戳":["21.3"],"否":["21.3"],"sort":["22.0","23.0","25.0","27.0","29.0","32.0"],"冒泡排序是一种简单的排序算法":["22.0"],"如果第一个比第二个大":["22.1"],"就交换它们两个":["22.1"],"i":["22.3","25.3","29.3","31.1"],"遍历输入数据":["23.1"],"o":["23.3","30.4"],"counting":["24.0"],"的元素出现的次数":["24.1"],"存入数组":["24.1"],"与最后一个元素":["25.1"],"交换":["25.1"],"此时得到新的无序区":["25.1"],"buildmaxheap":["25.3"],"swap":["25.3"],"j":["25.3"],"非比较类排序":["26.0"],"不通过比较来决定元素间的相对次序":["26.0"],"它可以突破基于比较排序的时间下界":["26.0"],"以线性时间运行":["26.0"],"因此也称为线性时间非比较类排序":["26.0"],"排序分类":["26.0"],"表现稳定的排序算法":["27.0"],"取出下一个元素":["27.1"],"在已经排序的元素序列中从后向前扫描":["27.1"],"通常采用":["27.4"],"归并排序是建立在归并操作上的一种有效的排序算法":["28.0"],"该算法是采用分治法":["28.0"],"和选择排序一样":["28.4"],"分为两个子串":["29.1"],"sub":["29.1"],"lists":["29.1"],"pivot":["29.3"],"基数排序是按照低位先排序":["30.0"],"然后收集":["30.0"],"并取得位数":["30.1"],"getdigit":["30.3"],"num":["30.3"],"的时间复杂度":["30.4"],"而且分配之后得到新的关键字序列又需要":["30.4"],"无序区为":["31.1"],"有序区为空":["31.1"],"第":["31.1"],"minindex":["31.3"],"temp":["31.3"],"因为无论什么数据进去都是":["31.4"],"t1":["32.1"],"t2":["32.1"],"tk":["32.1"],"其中":["32.1"],"shell":["32.3"],"既可以提前设定好间隔序列":["32.4"],"也可以动态的定义间隔序列":["32.4"],"定位居中":["33.1"],"css":["33.1","33.3"],"dom":["33.2"],"moz":["33.2"],"user":["33.2","46.6"],"文本超出部分以省略号形式出现":["33.3"],"截取字符串":["34.2"],"最后一个元素是最大的元素":["34.4"],"这时候最后一个元素是最大的":["34.4"],"所以最后一个元素就不需要参与比较大小":["34.4"],"bsort":["34.4"],"len":["34.4"],"ll":["34.5"],"xx":["34.5","48.8"],"f12":["34.6"],"longhand":["34.8","34.9"],"abc":["34.8","34.11"],"case1":["34.9"],"joining":["34.10"],"arrays":["34.10"],"using":["34.10"],"concat":["34.10"],"test1":["34.11","34.12"],"filename":["34.14","34.15"],"application":["34.15"],"vnd":["34.15"],"openxmlformats":["34.15"],"officedocument":["34.15"],"spreadsheetml":["34.15"],"sheet格式的文件":["34.15"],"文件名":["34.15"],"数据类型检测":["34.16"],"数组去重":["34.17"],"字符串去重":["34.18"],"取消冒泡的兼容代码":["34.19"],"getscrolloffset":["34.20"],"window":["34.20"],"pagex0ffset":["34.20"],"setrandom":["34.21"],"min":["34.21","40.10"],"简介":["35.1"],"速度快":["35.2"],"安全":["35.2"],"安装":["35.3"],"yarn的配置项":["35.4"],"显示所有配置项":["35.4"],"config":["35.4"],"显示某配置项":["35.4"],"删除某配置项":["35.4"],"delete":["35.4"],"设置配置项":["35.4"],"global":["35.4"],"安装包":["35.4"],"安装package":["35.4"],"json里所有包":["35.4"],"的时候需要安装依赖":["35.5"],"很多依赖不会指定版本号":["35.5"],"默认会安装最新的版本":["35.5"],"这样就会出现问题":["35.5"],"按钮用于开始一个即时操作":["36.0"],"button":["36.1","36.3","36.4","39.3","39.6"],"primary":["36.3","36.4"],"主要按钮":["36.3","36.4"],"bottom":["36.4"],"12px":["36.4"],"内使用":["36.5"],"组件":["36.5"],"如果想控制":["36.5"],"具体的位置":["36.5"],"只能直接使用":["36.5"],"而非":["36.5"],"屏蔽点击时候的水波纹特效":["36.6"],"语义化的矢量图形":["37.0"],"lock":["37.1","37.3","37.4"],"size":["37.1","37.3","37.6"],"icon":["37.3","37.4","37.6","40.8"],"red":["37.5"],"loading":["37.6"],"color":["37.6"],"1e90ff":["37.6"],"display":["37.7"],"flex":["37.7"],"align":["37.7"],"图片的地址":["38.3"],"png":["38.4"],"base64":["38.4"],"ivborw0kggoaaaansuheugaaamiaaaddcayaaadqvc6uaaabrwldq1bjq0mguhjvzmlszqaakjfjygassswoygfhygdizsspcnj3uoiijfjgf8lawsdcimogwmccmfxc4bgq4anuwgcjucg3awymipqylsis7ppoq3qddfcvjv3jod1boqvtpqrgskkttgbsf4a4lbmgqisbgtefyfyulykastuabjeiokoa7dkgdjqevqhetokwj4dvhaq5a9k3ggyb5ixeobmml4bsnsqk8xqkntreeobxcfxxuqg1mjc0dyhgxnjbswpfcyh2zi":["38.4"],"olmpmzyhrcasguqqcz16yno6ckygraqmdkmwhqj":["38.4"],"faicloxghqqxajihbeugw5suissqpbobtqpdlcilevjyzmpbhmdbsayhileqeo4dxg0txmrerhm29nygbddr":["38.4"],"dgrjynrky":["38.4"],"l7":["38.4"],"39v":["38.4"],"y4dmn":["38.4"],"web":["39.0","39.1"],"components":["39.1"],"开发":["39.1"],"actions":["39.2"],"workflow":["39.2"],"status":["39.2"],"ci":["39.2"],"yml":["39.2"],"alt":["39.2"],"ranui":["39.3","39.6","39.7"],"对于一些全局展示的组件":["39.3"],"大多数情况都可以像原生的":["39.4"],"template":["39.8"],"htmldivelement":["39.9"],"uploadfile":["39.9"],"current":["39.9"],"createelement":["39.9"],"setattribute":["39.9"],"file":["39.9"],"警告按钮":["39.10"],"text":["39.10"],"文本按钮":["39.10"],"不支持":["39.11"],"优秀设计作品":["39.12"],"有":["39.12","43.3"],"psd":["39.12"],"sketch":["39.12"],"rfcs":["39.13"],"通过鼠标或键盘输入内容":["40.0"],"width":["40.1","45.3","45.4"],"300px":["40.1"],"metiral":["40.3"],"design":["40.3"],"一致":["40.4"],"可以禁用输入框":["40.5"],"禁用后该按钮上的事件失效":["40.5"],"设置或返回输入框的":["40.6"],"目前支持":["40.7"],"来表示标签标识":["40.9"],"支持":["40.10","43.0"],"max":["40.10"],"step":["40.10"],"跟":["40.11"],"div":["40.12","45.4"],"常见的回调事件":["40.13"],"全局展示操作反馈信息":["41.0"],"block":["41.1"],"margin":["41.1"],"8px":["41.1"],"信息提示":["41.3"],"这是一条提示":["41.4"],"error":["41.4"],"top":["43.1","44.1"],"10px":["43.1","44.1"],"preview":["43.1"],"id":["43.1"],"默认为":["43.4"],"在需要等待加载内容的位置提供一个占位图形组合":["44.0"],"skeleton":["44.1"],"标签页":["45.0"],"tab":["45.1","45.5","45.6"],"label":["45.1","45.5","45.6","46.4"],"tab1":["45.1","45.3","45.5","45.6","46.3","46.4"],"tabs":["45.3","46.3","46.4","46.5"],"是保留字段":["45.4"],"用于设置活跃的标签":["45.4"],"等于":["45.4"],"的标签为活跃标签":["45.4"],"style":["45.4"],"rankey":["45.5"],"tab2":["45.6","45.7","46.1","46.6"],"tab3":["45.7","46.6"],"xml":["45.7"],"上":["46.5"],"可以指定切换到具体标签页":["46.5"],"也可以指定初始值":["46.5"],"message":["46.6"],"风格有":["46.7"],"postcss":["47.3"],"terser":["47.3"],"prettier":["47.3"],"可以是":["47.4"],"比如函数抛异常的时候":["47.5"],"任何类型都可以赋值给它":["47.6","47.7"],"比如是否可选":["47.8"],"我们想提取":["48.0"],"的区别":["48.1"],"都代表任意类型":["48.1"],"但是":["48.1"],"只能接收任意类型的值":["48.1"],"除了可以接收任意类型的值":["48.1"],"也可以赋值给任意类型":["48.1"],"除了":["48.1"],"类型体操中经常用":["48.1"],"接受和匹配任何类型":["48.1"],"而很少把任何类型赋值给某个类型变量":["48.1"],"对":["48.1"],"做模式匹配":["48.1"],"把我们要提取的第一个元素的类型放到通过":["48.1"],"声明的":["48.1"],"局部变量里":["48.1"],"后面的元素可以是任何类型":["48.1"],"用":["48.1"],"接收":["48.1"],"然后把局部变量":["48.1"],"返回":["48.1"],"当类型参数":["48.1"],"比如提取参数":["48.3"],"构造器是用于创建对象的":["48.7"],"的语法":["48.8"],"叫做条件类型":["49.1"],"conditional":["49.1"],"firsttupleitem":["49.2"],"中的与运算符":["49.4"],"但是作用于类型":["49.4"],"maptoarray":["49.5"],"用于提取函数类型的参数类型":["50.1"],"用于提取函数类型的返回值类型":["50.2"],"自然也可以提取构造器返回值的类型":["50.4"],"constructorparameters":["50.21"],"instancetype":["50.21"],"thisparametertype":["50.21"],"用模式匹配":["50.21"]},{"0":["4.39","19.1","31.3","34.4","39.9"],"1":["1.6","1.17","4.20","8.3","9.4","9.5","9.14","9.21","9.23","14.8","18.2","18.3","22.3","27.3","30.3","31.3","32.1","34.10","34.13","49.5"],"2":["4.36","5.2","9.5","9.21","25.3","31.1","34.10","39.1","39.13","41.4","45.7","49.5"],"3":["1.16","4.27","5.2","10.8","26.0","31.1","34.10"],"4":["5.2","34.10"],"5":["5.2"],"10":["21.1","30.3"],"16":["34.5"],"18":["9.13","47.2"],"24":["34.5"],"50":["39.10"],"1000":["21.1"],"11111":["45.3","45.4"],"22222":["45.1","45.3","45.4","45.5"],"33333":["45.4","45.6"],"之所以叫":["1.1"],"抽象":["1.1"],"语法树是因为数据结构中省略掉了一些无具体意义的分隔符比如":["1.1"],"等":["1.1"],"就是一个字符串字面量":["1.3"],"stringliteral":["1.3"],"js":["1.4","1.5","1.6","4.30","4.34","4.37","4.41","4.43","5.4","9.19","19.2","20.2","34.17","40.15","49.3"],"中的标识符只能包含字母或数字或下划线":["1.4"],"或美元符号":["1.4"],"且不能以数字开头":["1.4"],"这是":["1.4"],"我们写的每一条可以独立执行的代码都是语句":["1.5"],"语句末尾一般会加一个分号分隔":["1.5"],"或者用换行分隔":["1.5"],"下面这些我们经常写的代码":["1.5"],"每一行都是一个":["1.5"],"const":["1.6","4.31","5.6","25.3","39.7","40.15","47.3"],"a":["1.6","1.17","4.7","9.4","9.5","9.14","9.21","13.5","46.5","48.4","49.5"],"function":["1.6","4.25","4.34","4.39","5.1","5.4","12.13","34.6","34.7","34.15","34.16","34.17","34.18","34.19"],"super":["1.7"],"b":["1.7","1.9","9.4","9.5","9.9","9.21","45.5","49.5"],"它们对应的":["1.7"],"ast":["1.7"],"如图":["1.7"],"细心的同学可能会问":["1.7"],"identifier":["1.7"],"和":["1.7","2.0","9.1","9.30","10.2","11.5","11.15","39.3"],"方法是":["1.8"],"classmethod":["1.8"],"通过":["1.8","10.11","11.5"],"kind":["1.8"],"属性来区分是":["1.8"],"namespaced":["1.9"],"as":["1.9","28.3"],"这":["1.9"],"种语法都对应":["1.9"],"importdeclaration":["1.9"],"但是":["1.9","10.2"],"statement":["1.10"],"数组":["1.10","1.15"],"就是具体执行的语句的集合":["1.10"],"comments":["1.11"],"tokens":["1.11"],"等属性":["1.11"],"分别存放":["1.11"],"以后的":["1.12"],"可以切换":["1.12"],"的语言和用的":["1.12"],"parser":["1.12"],"而":["1.13"],"属性是一个对象":["1.13"],"有":["1.13"],"line":["1.13"],"column":["1.13"],"属性分别记录开始和结束的行列号":["1.13"],"节点可能同时有多种类型":["1.14"],"确定一种":["1.14"],"节点是什么类型主要看它的特点":["1.14"],"在经过分词之后":["1.15"],"代码会被切分为如下的":["1.15"],"token":["1.15"],"generator":["1.16"],"record":["1.16","12.13"],"args":["1.16","10.12","11.11","48.4","48.5"],"any":["1.16","10.2","12.13","18.2"],"return":["1.16","1.17","4.36","4.44","4.46","5.2","5.4","9.4","18.1","23.2","34.20"],"isalpha":["1.17"],"char":["1.17"],"boolean":["1.17","9.6","9.20","11.12"],"z":["1.17"],"处理空格":["1.17"],"if":["1.17","5.2","5.8","29.3","34.6","34.21"],"continue":["1.17"],"我们会依次遍历":["1.18"],"对代码进行语法结构层面的分析":["1.18"],"最后的目标是生成":["1.18"],"进行处理":["2.0"],"分为":["2.0"],"enter":["2.0"],"exit":["2.0"],"两个阶段":["2.0"],"具体操作":["2.0"],"使用":["2.0"],"path":["2.0","16.4"],"在机器上直接运行的代码":["3.0"],"往往都难以维护和理解":["3.0"],"我们需要将开发者方便理解和维护的代码":["3.0"],"解决方案描述了一个设计模式的组成成分":["4.0"],"以及这些组成成分之间的相互关系":["4.0"],"各自的职责和协作方式":["4.0"],"通常解决方案通过":["4.0"],"uml":["4.0"],"类图和核心代码来进行描述":["4.0"],"效果描述了模式的优缺点以及在使用模式时应权衡的问题":["4.0"],"为什么要学习设计模式":["4.0"],"设计模式来源众多专家的经验和智慧":["4.0"],"它们是从许多优秀的软件系统中总结出的成功的":["4.0"],"能够实现可维护性复用的设计方案":["4.0"],"使用这些方案将可以让我们避免做一些重复性的工作":["4.0"],"设计模式提供了一套通用的设计词汇和一种通用的形式来方便开发人员之间沟通和交流":["4.0"],"使得设计方案更加通俗易懂":["4.0"],"大部分设计模式都兼顾了系统的可重用性和可扩展性":["4.0"],"这使得我们可以更好地重用一些已有的设计方案":["4.0"],"这里不会将":["4.1"],"的各种元素都提到":["4.1"],"只想讲讲类图中各个类之间的关系":["4.1"],"继承":["4.2"],"实现":["4.3"],"与聚合关系一样":["4.4"],"组合关系同样表示整体由部分构成的语义":["4.4"],"聚合关系用于表示实体对象之间的关系":["4.5"],"表示整体由部分构成的语义":["4.5"],"一般由常识等因素决定的":["4.6"],"它一般用来定义对象之间静态的":["4.6"],"天然的结构":["4.6"],"所以":["4.6","9.26"],"依赖于":["4.7"],"如果一个软件设计符合开闭原则":["4.9"],"那么可以非常方便地对系统进行扩展":["4.9"],"而且在扩展时无须修改现有代码":["4.9"],"使得软件系统在拥有适应性和灵活性的同时具备较好的稳定性和延续性":["4.9"],"随着软件规模越来越大":["4.9"],"因为我并不喜欢老鼠":["4.10"],"虽然它也是动物":["4.10"],"例如有两个类":["4.10"],"一个类为":["4.10"],"baseclass":["4.10"],"另一个是":["4.10"],"subclass":["4.10"],"类":["4.10"],"并且":["4.10"],"尽量引用层次高的抽象层类":["4.11"],"即使用接口和抽象类进行变量类型声明":["4.11"],"参数类型声明":["4.11"],"方法返回类型声明":["4.11"],"以及数据类型的转换等":["4.11"],"在软件系统中":["4.12"],"一个类":["4.12"],"大到模块":["4.12"],"小到方法":["4.12"],"承担的职责越多":["4.12"],"迪米特法则要求限制软件实体之间通信的宽度和深度":["4.13"],"迪米特法则可降低系统的耦合度":["4.13"],"使类与类之间保持松散的耦合关系":["4.13"],"迪米特法则要求我们在设计系统时":["4.13"],"应该尽量减少对象之间的交互":["4.13"],"根据接口隔离原则":["4.14"],"当一个接口太大时":["4.14"],"我们需要将它分割成一些更细小的接口":["4.14"],"使用该接口的客户端仅需知道与之相关的方法即可":["4.14"],"使之成为新对象的一部分":["4.15"],"新对象通过委派调用已有对象的方法达到复用功能的目的":["4.15"],"简而言之":["4.15"],"复用时要尽量使用组合":["4.15"],"聚合关系":["4.15"],"依赖倒置原则":["4.16"],"联系比较紧密":["4.16"],"后两者是实现开闭原则重要前提":["4.16"],"使用中通过抽象化设计具有很好的可拓展性和可维护性":["4.16"],"它们各具特色":["4.17"],"每个模式都为某一个可重复的设计问题提供了一套解决方案":["4.17"],"根据它们的用途":["4.17"],"设计模式可分为创建型":["4.17"],"而不清楚其具体的实现细节":["4.18"],"使整个系统的设计更加符合单一职责原则":["4.18"],"简单工厂模式":["4.18"],"simple":["4.18"],"可以通过":["4.19","5.1"],"简单积木的组合形成复杂的":["4.19"],"功能更为强大的结构":["4.19"],"结构型模式可以分为类结构型模式和对象结构型模式":["4.19"],"类结构型模式关心类的组合":["4.19"],"而且重点关注它们之间的相互作用":["4.20"],"通过行为型模式":["4.20"],"可以更加清晰地划分类与对象的职责":["4.20"],"并研究系统在运行时实例对象之间的交互":["4.20"],"interface":["4.22","47.8"],"cola":["4.22","4.23"],"可口可乐产品类":["4.22"],"cocacola":["4.22"],"extends":["4.22","4.26","8.2","8.3","8.4","8.7","8.9","11.3","12.2","12.4","13.0","13.4","13.5"],"百事可乐产品类":["4.22"],"pepsicola":["4.22"],"而工厂方法是对工厂进行抽象化":["4.23"],"不同产品都由专门的具体工厂来生产":["4.23"],"可口可乐工厂专门生产可口可乐":["4.23"],"百事可乐工厂专门生产百事可乐":["4.23"],"ts":["4.23","4.25","4.29","4.32","8.0","8.3","8.4","8.5","8.9","13.4","21.2","47.8","49.1","49.4"],"工厂抽象类":["4.23"],"class":["4.23","4.25","4.29","4.37","4.43","4.45"],"瓶子抽象类和派生类":["4.24"],"bottle":["4.24"],"cocacolabottle":["4.24"],"pepsicolabottle":["4.24"],"箱子抽象类和派生类":["4.24"],"box":["4.24"],"一旦王国里的事务多起来":["4.25"],"这唯一的国王也容易职责过重":["4.25"],"buildparta":["4.26"],"void":["4.26"],"buildpartb":["4.26"],"buildpartc":["4.26"],"buildproduct":["4.26"],"product":["4.26"],"具体建造者":["4.26"],"concretebuilder":["4.26"],"private":["4.26"],"使用object":["4.27"],"create创建一个新车x":["4.27"],"anothercar":["4.27"],"object":["4.27","9.11","12.13"],"create":["4.27"],"somecar":["4.27"],"丰田佳美":["4.27"],"我们可以理解为购买的装备给英雄的攻击和技能的相关方法进行了装饰":["4.29"],"举例":["4.29","4.34","4.37","4.42"],"装饰模式贴合开闭原则":["4.29"],"在不改变原有类的情况下":["4.29"],"对父类进行改造或新增功能":["4.29"],"装饰类":["4.29"],"annotation":["4.29"],"内部包含了涉及到其他子系统的如缓存":["4.30"],"下载等处理":["4.30"],"外观模式将这些复杂的逻辑都隐藏了":["4.30"],"在兼容浏览器事件绑定":["4.30"],"你只需要调一个":["4.30"],"addmyevent":["4.30"],"接口就可以了":["4.30"],"达到解耦合的目的":["4.30"],"delegation":["4.31"],"delegate":["4.31"],"require":["4.31"],"delegates":["4.31"],"prototype":["4.31","4.40"],"module":["4.31"],"exports":["4.31"],"method":["4.31"],"attachment":["4.31"],"但是他们所享受的音乐来是自于同一个音乐库":["4.32"],"这样所有的音乐都只需要保存一份就可以了":["4.32"],"另外如果出现音乐库里没有的音乐时":["4.32"],"则需要新增该音乐":["4.32"],"然后其他服务也可以享受新增的音乐":["4.32"],"相当于享元池或缓存池的功能":["4.32"],"享元模式区保证共享内部状态如音乐库":["4.32"],"而外部状态根据不同需求定制如各种访问权限":["4.32"],"使用中不能去改变内部状态":["4.32"],"以达到共享的目的":["4.32"],"color":["4.33","39.10"],"着色模块":["4.33"],"cl":["4.33"],"draw":["4.33"],"绘制颜色":["4.33"],"speak":["4.33"],"则可以用适配器模式":["4.34"],"事件绑定兼容各浏览器":["4.34"],"addevent":["4.34"],"ele":["4.34","8.2","11.3","12.7"],"500元定金预购":["4.36"],"得到100元优惠劵":["4.36"],"else":["4.36","4.43","5.8","28.3"],"nextsuccess":["4.36"],"order200":["4.36"],"200元定金预购":["4.36"],"得到50元優惠卷":["4.36"],"各自独立":["4.37"],"将请求封装成命令对象":["4.37"],"请求的具体执行由命令对象":["4.37"],"调用接收者":["4.37"],"对应接口执行":["4.37"],"和之前代理模式中的举例有些相似":["4.37"],"不过命令模式的本质是对命令进行封装":["4.37"],"将发出命令的责任和执行命令的责任分割开":["4.37"],"例如遥控器是一个调用者":["4.37"],"不同按钮代表不同的命令":["4.37"],"而电视是接收者":["4.37"],"newvalue":["4.38"],"add":["4.38","4.40","9.3"],"expression":["4.38"],"push":["4.38","5.2","28.3"],"plusexpression":["4.38"],"interpret":["4.38"],"each":["4.39"],"arr":["4.39","8.2","12.7","34.13"],"callback":["4.39"],"for":["4.39","27.3","32.3","34.4"],"i":["4.39","14.0","27.3","31.3","34.4"],"len":["4.39"],"length":["4.39","8.8","9.27","21.1","32.3","34.4","39.9"],"win":["4.40"],"lose":["4.40"],"将就用下这个demo":["4.40"],"这个函数充当中介者":["4.40"],"当前很多软件都提供了撤销操作":["4.41"],"其中就使用了备忘录模式":["4.41"],"当我们开发一个分页组件的时候":["4.41"],"点击下一页获取新的数据":["4.41"],"但是当点击上一页时":["4.41"],"又重新获取数据":["4.41"],"造成无谓的流量浪费":["4.41"],"这时可以对数据进行缓存":["4.41"],"备忘录模式伪代码":["4.41"],"source":["4.42"],"listener":["4.42"],"模式或从属者":["4.42"],"dependents":["4.42"],"观察者模式是一种对象行为型模式":["4.42"],"观察者模式是使用频率最高的设计模式之一":["4.42"],"它用于建立一种对象与对象之间的依赖关系":["4.42"],"一个对象发生改变时将自动通知其他对象":["4.42"],"或者":["4.43"],"switch":["4.43"],"不仅丑陋不说":["4.43"],"而且在遇到有组合动作的时候":["4.43"],"实现就会变的更为复杂":["4.43"],"这里可以使用状态模式来实现":["4.43"],"状态模式的思路是":["4.43"],"首先创建一个状态对象或者数组":["4.43"],"内部保存状态变量":["4.43"],"然后内部封装好每种动作对应的状态":["4.43"],"然后状态对象返回一个接口对象":["4.43"],"它可以对内部的状态修改或者调用":["4.43"],"supermarry":["4.43"],"constructor":["4.43","4.45"],"experience":["4.44"],"getexperience可以复用":["4.44"],"getexperience":["4.44"],"level":["4.44"],"in":["4.44","11.14","11.15"],"strategylevel":["4.44"],"new":["4.45","5.1","20.1","21.1","34.7","34.14","34.15"],"泡一壶茶":["4.45"],"其实呢":["4.45"],"泡茶的步骤跟泡咖啡的步骤相差不大":["4.45"],"大致是这样的":["4.45"],"把水煮沸":["4.45"],"用沸水浸泡茶叶":["4.45"],"把茶水倒进杯子":["4.45"],"加柠檬":["4.45"],"来":["4.45"],"咱用":["4.45"],"es6":["4.45"],"来泡茶":["4.45"],"tea":["4.45"],"把水烧开":["4.45"],"steepteabag":["4.45"],"浸泡茶叶":["4.45"],"倒进杯子":["4.45"],"addlemon":["4.45"],"window":["4.46"],"使用call改变this的指向":["4.46"],"call":["4.46"],"id":["4.46","46.4"],"document":["4.46","39.6"],"getelementbyid":["4.46"],"demo":["4.46"],"click":["4.46","39.9"],"this":["4.46"],"指向dom对象":["4.46"],"style":["4.46","36.5"],"background":["4.46"],"red":["4.46"],"设计模式是无处不在的":["4.47"],"user":["4.48","36.6","39.10"],"57f8ffda2e958a005581e3c0":["4.48"],"posts":["4.48"],"design":["4.48"],"联系":["5.0"],"抽象到程序世界":["5.0"],"对运算过程进行抽象":["5.0"],"程序的本质":["5.0"],"根据输入":["5.0"],"通过某种运算":["5.0"],"获得相应的输出":["5.0"],"函数式编程中的函数不是指程序中的":["5.0"],"函数就是一个普通的对象":["5.1"],"测试":["5.2"],"会自动释放":["5.3"],"存放基本数据类型":["5.3"],"占据固定大小的空间":["5.3"],"栈的溢出":["5.3"],"递归调用方法":["5.3"],"memoize函数":["5.4"],"memoize":["5.4"],"fn":["5.4","5.6"],"let":["5.4","27.3","32.3"],"cache":["5.4"],"key":["5.4","11.17","11.19"],"json":["5.4"],"先调用它":["5.5"],"并返回一个函数":["5.5"],"这部分参数以后保持不变":["5.5"],"然后返回一个新的函数接受剩下的参数":["5.5"],"返回结果":["5.5"],"lodash":["5.5"],"中的柯里化函数":["5.5"],"func":["5.5","40.14"],"功能":["5.5"],"创建一个函数":["5.5"],"该函数接受一个或多个":["5.5"],"的参数":["5.5"],"如果该函数所有的参数都被传递":["5.5"],"则返回函数的结果":["5.5"],"否则":["5.5"],"value":["5.6","10.0","18.1"],"reverse":["5.6"],"reduce":["5.6"],"acc":["5.6"],"箭头函数":["5.6"],"compose":["5.6"],"在使用这种模式之前我们需要定义一些辅助的基本运算函数":["5.7"],"不需要指明处理的数据":["5.7"],"只需要合成运算过程":["5.7"],"undefined":["5.8","9.11","47.0","47.4"],"问题":["5.8"],"如果多次调用":["5.8"],"中间出现了":["5.8"],"空值的情况":["5.8"],"最后会返回包含":["5.8"],"的函子":["5.8"],"虽然":["5.8"],"函子可以处理空值的情况":["5.8"],"但不知道是哪一步出现了空值":["5.8"],"either":["5.8"],"两者中的任意一个":["5.8"],"类似于":["5.8","39.12"],"的处理":["5.8"],"异常会让函数变的不纯":["5.8"],"函子可以用来做异常处理":["5.8"],"either函子":["5.8"],"left":["5.8","11.8","25.3"],"right":["5.8","11.8","36.5"],"函数式编程入门教程":["5.9"],"addeventlistener":["7.2"],"可以是以下之一":["7.4"],"loading":["7.4","39.10"],"加载":["7.4"],"就是数值":["8.0"],"比如":["8.0","9.6","9.14"],"type":["8.0","8.3","8.4","8.5","8.7","8.9","9.5","9.25","10.0","10.15","11.4","11.16","11.18","13.4","40.8","43.1","49.4"],"num1":["8.0","8.3","8.4"],"unknown":["8.0","8.2","8.8","8.9","10.3","10.5","10.11","10.12","11.3","12.2","12.4","12.7","48.4","48.5","49.2"],"buildarray":["8.2"],"number":["8.2","8.3","8.4","9.6","11.0","11.12","12.7","13.3"],"就是":["8.3","9.9","50.4"],"所以减法的实现是这样的":["8.3"],"multiplication":["8.4"],"num2":["8.4"],"resultarr":["8.4"],"除法的实现就是被减数不断减去减数":["8.5"],"直到减为":["8.5"],"记录减了几次就是结果":["8.5"],"也就是这样的":["8.5"],"str":["8.7","19.3","48.2"],"string":["8.7","9.14","11.8","11.14","13.0","13.4","19.3","48.8"],"countarr":["8.7"],"false":["8.8","9.17","10.7","43.4"],"true":["8.8","9.17","10.7","12.6"],"也就是递归的加法":["8.9"],"在":["8.9","9.28"],"typescript":["8.9","9.28"],"类型编程里用构造数组来实现这种加法":["8.9"],"fibonacciloop":["8.9"],"prevarr":["8.9"],"currentarr":["8.9"],"regexp":["9.1","20.1"],"变量的类型不同代表可以对该变量做的操作就不同":["9.1"],"有了类型":["9.1"],"那我们的操作必须和类型相匹配":["9.1"],"否则就会报错":["9.1"],"这就是类型检查":["9.1"],"如果能保证对某种类型只做该类型允许的操作":["9.1"],"这就叫做类型安全":["9.1"],"类型检查可以在运行时做":["9.1"],"也可以运行之前的编译期做":["9.1"],"这是两种不同的类型":["9.1"],"前者叫做动态类型检查":["9.1"],"后者叫做静态类型检查":["9.1"],"两种类型检查各有优缺点":["9.1"],"函数既可以做整数加法":["9.3"],"又可以做浮点数加法":["9.3"],"却需要声明两个函数":["9.3"],"c":["9.3","9.5","9.20"],"int":["9.3"],"支持对类型参数做各种逻辑处理":["9.5"],"可以写很复杂的类型逻辑":["9.5"],"类型逻辑可以多复杂":["9.5"],"类型逻辑是对类型参数的各种处理":["9.5"],"可以实现很多强大的功能":["9.5"],"比如这个":["9.5"],"parsequerystring":["9.5"],"的类型":["9.5","10.0","10.17","48.0"],"res":["9.5","9.21","49.5"],"它可以对传入的字符串的类型参数做解析":["9.5"],"返回解析以后的结果":["9.5"],"等于":["9.5"],"类型的值不能赋值给":["9.6"],"类型的变量":["9.6"],"hobbies":["9.7"],"这里":["9.7"],"是":["9.7","19.3"],"测试一下发现是这样的":["9.8"],"那":["9.9"],"的子类型":["9.9"],"这种叫做名义类型系统":["9.9"],"nominal":["9.9"],"bigint":["9.11","47.0"],"symbol":["9.11","47.0"],"null":["9.11"],"这些类型":["9.11"],"就是元素个数和类型固定的数组类型":["9.12","47.1"],"guang":["9.13"],"函数":["9.13","47.2"],"sayhello":["9.13","47.2"],"这种值也可以做为类型":["9.14"],"其中":["9.14","45.0"],"字符串的字面量类型有两种":["9.14"],"一种是普通的字符串字面量":["9.14"],"aaa":["9.14","9.24"],"另一种是模版字面量":["9.14"],"它的意思是以":["9.14"],"比如是否可选":["9.15"],"是否只读等":["9.15","47.8"],"我们知道了":["9.16"],"这就是":["9.17"],"类型系统里的":["9.17"],"t":["9.18","11.16","11.17","11.18","11.19","48.0","49.1","49.2"],"r":["9.18","39.5","39.8","40.1","40.3","40.4","40.5","40.9","40.10","41.1","45.0"],"里的或运算符":["9.19","49.3"],"注意":["9.20"],"同一类型可以合并":["9.20"],"不同的类型没法合并":["9.20"],"会被舍弃":["9.20"],"也就是":["9.23"],"的判断上":["9.24"],"isequalresult":["9.24"],"因为":["9.24"],"testneverresult":["9.26"],"要判断":["9.26"],"类型":["9.26","10.0","16.3"],"就不能直接":["9.26"],"是数字字面量":["9.27"],"逆变":["9.28"],"如果允许子类型赋值给父类型":["9.28"],"协变":["9.28"],"关于逆变":["9.28"],"协变等概念的详细解释可以看原理篇":["9.28"],"never":["9.29","10.4","10.11","10.12","11.20"],"类型参数":["9.29","10.9","10.11","11.3","11.20","48.2"],"为待处理的索引类型":["9.29"],"类型约束为索引为":["9.29"],"值为任意类型的索引类型":["9.29"],"会直接返回":["9.30"],"truetype":["9.30"],"falsetype":["9.30"],"的联合类型":["9.30"],"比如这样一个":["10.0"],"promise":["10.0","11.0","15.0"],"p":["10.0","11.15","12.2"],"我们想提取":["10.0"],"约束为只能是数组类型":["10.2"],"数组元素是":["10.2"],"unkown":["10.2"],"也就是可以是任何值":["10.2"],"的区别":["10.2"],"都代表任意类型":["10.2"],"infer":["10.3","10.5","10.12","10.16","11.1","11.7","11.8","11.9","11.11","12.2","12.4","12.5","12.10","12.11","48.4","48.5"],"如果是空数组":["10.4"],"就直接返回":["10.4"],"否则匹配剩余的元素":["10.4"],"放到":["10.4"],"字符串类型也同样可以做模式匹配":["10.6"],"需要声明字符串":["10.7"],"匹配的前缀":["10.7"],"两个类型参数":["10.7","11.5"],"suffix":["10.8","11.9"],"声明要替换的字符串":["10.8"],"待替换的字符串":["10.8"],"替换成的字符串":["10.8"],"个类型参数":["10.8"],"是要":["10.9","48.2"],"的字符串":["10.9","48.2"],"如果":["10.9","26.0","48.2"],"匹配字符串":["10.9"],"空白字符":["10.9"],"空格":["10.9"],"函数同样也可以做类型匹配":["10.10"],"是要匹配的函数类型":["10.11"],"returntype":["10.12","11.11"],"构造器和函数的区别是":["10.14"],"这里的":["10.15"],"返回的是":["10.15"],"类型的实例对象":["10.15"],"这个也可以通过模式匹配取出来":["10.15"],"parameterstype":["10.16"],"exclude":["10.17"],"我们简化一下那个高级类型":["10.17"],"提取":["10.17"],"props":["10.17"],"里":["10.17"],"ttt":["11.0"],"用于类型的提取":["11.0"],"然后存到一个变量里":["11.0"],"类型参数声明的变量都不能修改":["11.1"],"是要修改的数组":["11.3"],"othersecond":["11.5"],"是两个元组":["11.5"],"类型是":["11.5"],"代表":["11.5"],"个任意类型的元素构成的元组":["11.5"],"分别提取":["11.5"],"first":["11.7","12.5","12.11"],"rest":["11.7","12.5","12.11"],"prefix":["11.9"],"gender":["11.12"],"索引类型可以添加修饰符":["11.12"],"readonly":["11.12"],"keyof":["11.13","11.14"],"uppercase":["11.14"],"指定索引和值的类型分别为":["11.15"],"为要处理的索引类型":["11.20"],"返回新的类型":["12.0"],"和函数调用是对应的":["12.0"],"自然也支持递归":["12.0"],"直到结束条件":["12.2"],"所以高级类型是这样的":["12.2"],"valuetype":["12.2"],"one":["12.4","12.10"],"two":["12.4","12.10"],"three":["12.4","12.10"],"finditem":["12.5"],"isequal":["12.5","12.6"],"它能把一个字符串中的某个字符替换成另一个":["12.9"],"但是如果有多个这样的字符就处理不了了":["12.9"],"如果不确定有多少个":["12.9"],"字符":["12.9"],"怎么处理呢":["12.9"],"在类型体操里":["12.9"],"遇到数量不确定的问题":["12.9"],"four":["12.10"],"uppercasea":["13.0"],"item":["13.0"],"余下的字符串递归处理":["13.1"],"camelcaseresult":["13.1"],"aa":["13.1"],"aaaaaa":["13.1"],"如果是对字符串数组做":["13.1"],"那就要递归处理每一个元素":["13.1"],"testunion":["13.2"],"testunionresult":["13.2"],"传入联合类型":["13.2"],"但传入的是数组":["13.3"],"要递归遍历取出每一个元素来和其他部分组合":["13.3"],"这样太麻烦了":["13.3"],"而如果是联合类型就不用递归遍历了":["13.3"],"因为联合类型遇到字符串也是会单独每个元素单独传入做处理":["13.3"],"数组转联合类型可以这样写":["13.3"],"union":["13.3"],"然后组合出来的字符串再和其他字符串组合":["13.4"],"任何两个类型的组合有四种":["13.4"],"combination":["13.4"],"叫做分布式条件类型":["13.5"],"有两点特别要注意":["13.5"],"层上最多有":["14.0"],"个结点":["14.0"],"深度为":["14.0"],"h":["14.0"],"2k":["14.1"],"个结点的二叉树":["14.2"],"对树中的结点按从上至下":["14.2"],"它或者是一棵空树":["14.3"],"一定是二叉搜索树":["14.4"],"树属于多叉树又名平衡多路查找树":["14.5"],"树是":["14.6"],"树的非根和非叶子结点再增加指向兄弟的指针":["14.7"],"树定义了非叶子结点关键字个数至少为":["14.7"],"判断":["14.18"],"描述":["16.3"],"默认值":["16.4","18.3"],"数组的每个成员都是一个":["18.0"],"对象":["18.0"],"api":["18.1"],"toraw":["18.1"],"params":["18.1"],"param":["18.3","24.3"],"word":["19.1"],"substring":["19.1"],"touppercase":["19.1"],"tolowercase":["19.1"],"需要转换的字符串":["19.3"],"截取地址栏中":["20.0"],"reg":["20.1"],"说明":["20.3"],"必填":["20.3"],"年":["21.0","32.0"],"date":["21.1","21.3"],"如果datetime长度为10或者13":["21.1"],"则为秒和毫秒的时间戳":["21.1"],"如果超过13位":["21.1"],"则为其他的时间格式":["21.1"],"tostring":["21.1"],"当前时间":["21.3"],"fmt":["21.3"],"时间格式":["21.3"],"br":["21.3"],"yyyy":["21.3"],"它重复地走访过要排序的数列":["22.0"],"对每一对相邻元素作同样的工作":["22.1"],"从开始第一对到结尾的最后一对":["22.1"],"高效与否的关键在于这个分桶函数":["23.0"],"并且把数据一个一个放到对应的桶里去":["23.1"],"getmax":["23.2"],"桶排序的时间复杂度":["23.3"],"取决与对各个桶之间数据进行排序的时间复杂度":["23.3"],"就是一种牺牲内存空间来换取低时间复杂度的排序算法":["24.0"],"同时它也是一种不基于比较的算法":["24.0"],"的第":["24.1"],"项":["24.1"],"对所有的计数累加":["24.1"],"description":["24.3","30.3"],"计数排序":["24.3"],"count":["24.3"],"到":["24.4"],"k":["24.4"],"之间的整数时":["24.4"],"heapsort":["25.0"],"和新的有序区":["25.1"],"且满足":["25.1"],"heaphandler":["25.3"],"算法复杂度":["26.0"],"相关概念":["26.0"],"稳定":["26.0"],"因为无论什么数据进去都是":["27.0"],"o":["27.0","31.4"],"如果该元素":["27.1"],"已排序":["27.1"],"place":["27.4"],"排序":["27.4"],"divide":["28.0"],"and":["28.0"],"的输入序列分成两个长度为":["28.1"],"shift":["28.3"],"归并排序的性能不受输入数据的影响":["28.4"],"但表现比选择排序好的多":["28.4"],"快速排序的基本思想":["29.0"],"具体算法描述如下":["29.1"],"从数列中挑出一个元素":["29.1"],"称为":["29.1"],"temp":["29.3"],"再按照高位排序":["30.0"],"然后再收集":["30.0"],"为原始数组":["30.1"],"digit":["30.3"],"while":["30.3"],"基数排序":["30.3"],"假如待排数据可以分为":["30.4"],"d":["30.4"],"个关键字":["30.4"],"是一种简单直观的排序算法":["31.0"],"它的工作原理":["31.0"],"趟排序":["31.1"],"开始时":["31.1"],"n2":["31.4"],"ti":["32.1"],"tj":["32.1"],"gap":["32.3"],"math":["32.3"],"floor":["32.3"],"动态定义间隔序列的算法是":["32.4"],"算法":["32.4"],"dom":["33.1","33.3"],"position":["33.1"],"select":["33.2"],"none":["33.2"],"webkit":["33.2"],"white":["33.3"],"并且返回一个新的字符串":["34.1","34.2"],"strjoin":["34.1","34.2"],"只有chrome":["34.3"],"firefox浏览器支持桌面api":["34.3"],"notification":["34.3"],"yy":["34.5"],"zz":["34.5"],"onkeydown":["34.6"],"oncontextmenu":["34.7"],"def":["34.8"],"ghi":["34.8"],"test1":["34.9"],"break":["34.9"],"case2":["34.9"],"test2":["34.9","34.11","34.12"],"test":["34.10"],"cde":["34.11","34.12"],"abc":["34.12"],"test3":["34.12"],"x":["34.14","34.20"],"xmlhttprequest":["34.14"],"open":["34.14"],"get":["34.14"],"downloadxlsx":["34.15"],"var":["34.15"],"blob":["34.15"],"checktype":["34.16"],"uniq":["34.18"],"stopbubble":["34.19"],"e":["34.19"],"pagexoffset":["34.20"],"max":["34.21"],"arguments":["34.21"],"yarn":["35.1","35.2"],"可靠":["35.2"],"缓存了每个下载过的包":["35.2"],"shell":["35.3"],"npm":["35.3","39.2"],"并将包及它的所有依赖项保存进yarn":["35.4"],"lock":["35.4","39.10","40.8"],"安装一个包的单一版本":["35.4"],"flat":["35.4"],"强制重新下载所有包":["35.4"],"force":["35.4"],"只安装dependencies里的包":["35.4"],"production":["35.4"],"不读取或生成yarn":["35.4"],"no":["35.4"],"lockfile":["35.4"],"不生成yarn":["35.4"],"pure":["35.4"],"比如今天安装模块的时候":["35.5"],"是某一个版本":["35.5"],"而当以后":["35.5"],"warning":["36.3","36.4","41.3"],"警告按钮":["36.3","36.4"],"div":["36.5","39.4"],"display":["36.5"],"inline":["36.5"],"block":["36.5"],"margin":["36.5"],"8px":["36.5"],"fase":["36.6"],"icon":["36.6","39.10"],"默认按钮":["36.6","39.10"],"eye":["37.1","37.3"],"1e90ff":["37.5","39.10"],"f44336":["37.5"],"items":["37.7"],"center":["37.7","45.7"],"img":["38.1"],"lgehanwdrkl1auo":["38.4"],"pmgaaadhlwelmtu0akgaaaagaaydpaaqaaaabaaaaggaaaaaaaqacaaqaaaabaaaawqadaaqaaaabaaaawwaaaad9b":["38.4"],"hnaaahlkleqvr4ae3dp3ptwbsgcbgzm6gckqlibrv0dhrjfarq0eut8lh4bnru0nhr0uefvdilfrv7tzrksompy8uyktk":["38.4"],"zewqfkw":["38.4"],"9znv4yvjynlv4uliv2dbodibf4qp3":["38.4"],"arucrabefaobegghggqaqzqkanyeaqbaqaaskiaqjekaeeegjmbelaobegghggqaqzqkanyeaqbaqaaskiaqjekaeeegjmbelaobegghggqaqzqkanyeaqbaqaaskiaqjekaeeegjmbelaobegghggqaqzqkanyeaqbaqaaskiaqjekaeeegjmbelaobegghggqaqzqkanyeaqbaqaaskiaqjekaeeegjmbelaobegghggqaqzqkanyeaqbaqaaskiaqjekaeeegjmbelaobegghggqaqzqkanyeaqbaqaaskiaqjekaeeegjmbelaobegghggqaqzqkanyeaqbaqaaskiaqjekaeeegjmbelaobegghggqaqzqkanyeaqbaqaaskiaqjekaeeegjmbelaobegghggqaqzqkanyeaqbaqaaskiaqjekaeeegjmbelaobegghggqaqzqkanyeaqbaqaaskiaqjekaeeegjmbelaobegghggqaqzqkanyeaqbaqaaskiaqjekaeeegjmbelaobegghgg0aj8i0jo4ozsrpv69wv":["38.4"],"hi2qphr0qnvf39":["38.4"],"ii97sorih4f3z58":["38.4"],"u7du3sxx7xt7z2enevhmzfqe":["38.4"],"osn2apsapj09tsrb":["38.4"],"xki":["38.4"],"components":["39.0"],"能做到跨框架复用":["39.1"],"统一所有情况":["39.1"],"v":["39.2"],"ranui":["39.2"],"svg":["39.2"],"preview":["39.3"],"message":["39.3"],"需要加载一些额外的样式":["39.3"],"标签一样使用":["39.4"],"createelement":["39.6"],"onchange":["39.9"],"files":["39.9"],"src":["39.9"],"flex":["39.10"],"name":["39.10","48.8"],"size":["39.10"],"spin":["39.10"],"ie":["39.11"],"3d":["39.12"],"ui":["39.12"],"设计":["39.12"],"版的":["39.12"],"figma":["39.12"],"是最基础的表单域的包装":["40.0"],"输入框":["40.1"],"的输入体验":["40.3"],"input":["40.3","40.4","40.5","40.9"],"label":["40.5","45.4","46.5"],"属性值":["40.6"],"password":["40.7","40.8"],"属性":["40.10"],"支持键盘上下键切换数字":["40.10"],"form":["40.11"],"xml":["40.12","45.6"],"html":["40.14","46.6"],"bottom":["41.1"],"12px":["41.1"],"button":["41.1","43.1"],"警告提示":["41.3"],"toast":["41.4"],"也可以传一个对象":["41.4"],"设置提示内容":["41.4"],"关闭延时":["41.4"],"关闭时触发的回调函数":["41.4"],"docx":["43.0"],"primary":["43.1"],"地址即可打开弹窗":["43.3"],"没有":["43.3"],"可以关闭":["43.4"],"设置成":["43.4"],"tab2":["45.1","45.3","45.4","45.5","46.3","46.4","46.5"],"tab1":["45.4","46.5"],"tab3":["45.4","45.5","45.6"],"content":["46.4"],"text":["46.7"],"obj":["47.2"],"typescriptcompiler":["47.3"],"tsc":["47.3"],"此外":["47.3"],"返回值就是":["47.5"],"它也可以赋值给任何类型":["47.6"],"但是它不可以赋值给别的类型":["47.7"],"可以这样做":["48.0"],"getpromisevalue":["48.0"],"为":["48.1"],"时":["48.1"],"result":["48.1"],"可以提取第一个元素":["48.1"],"当然也可以提取最后一个元素":["48.1"],"修改下模式类型就行":["48.1"],"getarraylastitem":["48.1"],"返回值的类型":["48.3"],"apply":["48.6"],"调用":["48.6"],"调用的时候":["48.6"],"所以可以被":["48.7"],"personconstructor":["48.8"],"istwo":["49.1"],"代表对类型做合并":["49.4"],"example":["49.5"],"parameters":["50.3"],"重新构造可以实现":["50.21"],"omitthisparameter":["50.21"],"用重新构造可以实现":["50.21"]},{"0":["4.36","8.4","32.3"],"1":["4.39","8.0","10.13","14.1","19.3","25.3","47.3"],"2":["4.18","4.20","4.39","14.7","18.3","19.1","25.1","32.3","34.13","34.21","47.0","49.1"],"3":["4.36","4.39","14.7","34.13"],"4":["45.5"],"5":["34.10","39.12"],"6":["5.2","34.10","39.12"],"7":["5.2","39.12"],"8":["1.16"],"10":["34.5","40.10"],"26":["34.5"],"50":["37.4"],"100":["4.44"],"111":["9.4"],"300":["4.44"],"400":["4.44"],"1111":["47.3"],"2000":["41.4"],"2222":["9.4"],"33333":["45.1","45.3","45.5"],"有了":["1.1"],"ast":["1.1","1.18"],"计算机就能理解源码字符串的意思":["1.1"],"而理解是能够转换的前提":["1.1"],"所以编译的第一步需要把源码":["1.1"],"parse":["1.1","5.8"],"是对源码的抽象":["1.2"],"字面量":["1.2"],"相应的还有数字字面量":["1.3"],"numericliteral":["1.3"],"布尔字面量":["1.3"],"booleanliteral":["1.3"],"的词法特点":["1.4"],"尝试分析一下":["1.4"],"下面这一段代码里面有多少":["1.4"],"throw":["1.5","4.38"],"error":["1.5","4.38","5.8","9.14","41.3"],"try":["1.5","5.8"],"catch":["1.5","5.8"],"e":["1.5"],"finally":["1.5"],"b":["1.6","4.7","5.5","9.3","9.25","12.5","12.6","26.0"],"c":["1.6","5.5"],"怎么也是表达式呢":["1.7"],"因为":["1.7"],"有返回值":["1.7"],"符合表达式的特点":["1.7"],"所以也是":["1.7"],"我们判断":["1.7"],"constructor":["1.8","4.26","4.37"],"还是":["1.8"],"method":["1.8"],"比如下面的代码":["1.8"],"js":["1.8","4.42","5.7","40.14"],"specifiers":["1.9"],"属性不同":["1.9"],"分别对应":["1.9"],"importspicifier":["1.9"],"importdefaultspecifier":["1.9"],"importnamespacespcifier":["1.9"],"图中黄框标出的就是":["1.9"],"specifier":["1.9"],"部分":["1.9"],"可以直观的看出整体结构相同":["1.9"],"只是":["1.9"],"部分不同":["1.9"],"还有":["1.10"],"directives":["1.10"],"属性":["1.10"],"程序体":["1.11"],"注释":["1.11"],"token":["1.11"],"也可以修改":["1.12"],"options":["1.12"],"点击这里的":["1.12"],"save":["1.12"],"leadingcomments":["1.13"],"innercomments":["1.13"],"trailingcomments":["1.13"],"表示开始的注释":["1.13"],"中间的注释":["1.13"],"结尾的注释":["1.13"],"每个":["1.13"],"比如":["1.14","4.6"],"statement":["1.14"],"的特点是可以单独执行":["1.14"],"expression":["1.14"],"的特点是有返回值":["1.14"],"从中你可以看到":["1.15"],"原本一行普通的代码字符串被拆分成了拥有语法属性的":["1.15"],"列表":["1.15"],"不同的":["1.15"],"处理字母":["1.17"],"else":["1.17","9.17","34.20"],"identifier":["1.17"],"in":["1.17","11.16","11.17","11.18","11.19"],"generator":["1.17"],"如果是关键字":["1.17"],"数据结构":["1.18"],"至于代码的":["1.18"],"的":["2.0"],"api":["2.0","18.2"],"还可以通过":["2.0"],"state":["2.0"],"来在遍历过程中传递一些数据":["2.0"],"types":["2.0"],"用于创建":["2.0"],"判断":["2.0"],"通过打包等工具转换成方便机器或者程序使用的代码":["3.0"],"对于":["3.0"],"功能模块甚至一个完整的软件系统":["4.0"],"避免我们经常做一些重复的设计":["4.0"],"编写一些重复的代码":["4.0"],"合理使用设计模式并对设计模式的使用情况进行文档化":["4.0"],"将有助于别人更快地理解系统":["4.0"],"学习设计模式将有助于初学者更加深入地理解面向对象思想":["4.0"],"储备知识":["4.0"],"抽象类":["4.0"],"一般抽象类都是作为基类":["4.0"],"比如说":["4.0"],"电脑":["4.0"],"就可以作为一个抽象类":["4.0"],"根据抽象类派生出":["4.0"],"台式电脑":["4.0"],"和":["4.0","4.46","8.8","13.2","31.1"],"笔记本电脑":["4.0"],"能看懂类图中各个类之间的线条":["4.1"],"箭头代表什么意思后":["4.1"],"也就足够应对日常的工作和交流":["4.1"],"继承用一条带空心箭头的直接表示":["4.2"],"实现关系用一条带空心箭头的虚线表示":["4.3"],"比如公司由多个部门组成":["4.4"],"例如一个部门由多个员工组成":["4.5"],"与组合关系不同的是":["4.5"],"关联关系是一种":["4.6"],"强关联":["4.6"],"的关系":["4.6"],"他描述一个对象在运行期间会用到另一个对象的关系":["4.7"],"与关联关系不同的是":["4.7"],"软件寿命越来越长":["4.9"],"软件维护成本越来越高":["4.9"],"设计满足开闭原则的软件系统也变得越来越重要":["4.9"],"为了满足开闭原则":["4.9"],"需要对系统进行抽象化设计":["4.9"],"类是":["4.10"],"类的子类":["4.10"],"那么一个方法如果可以接受一个":["4.10"],"类型的基类对象":["4.10"],"base":["4.10"],"而不要用具体类来做这些事情":["4.11"],"为了确保该原则的应用":["4.11"],"一个具体类应当只实现接口或抽象类中声明过的方法":["4.11"],"而不要给出多余的方法":["4.11"],"否则将无法调用到在子类中增加的新方法":["4.11"],"它被复用的可能性就越小":["4.12"],"而且一个类承担的职责过多":["4.12"],"就相当于将这些职责耦合在一起":["4.12"],"当其中一个职责变化时":["4.12"],"可能会影响其他职责的运作":["4.12"],"如果两个对象之间不必彼此直接通信":["4.13"],"那么这两个对象就不应当发生任何直接的相互作用":["4.13"],"如果其中的一个对象需要调用另一个对象的某一个方法的话":["4.13"],"可以通过第三者转发这个调用":["4.13"],"简言之":["4.13"],"每一个接口应该承担一种相对独立的角色":["4.14"],"不干不该干的事":["4.14"],"该干的事都要干":["4.14"],"关联关系":["4.15"],"少用继承":["4.15"],"在面向对象设计中":["4.15"],"可以通过两种方法在不同的环境中复用已有的设计和实现":["4.15"],"即通过组合":["4.15"],"知道最少原则":["4.16"],"可以降低耦合":["4.16"],"减少不必要的交互":["4.16"],"主张设计接口和类要简单易使用":["4.16"],"creational":["4.17"],"结构型":["4.17"],"structural":["4.17"],"factory":["4.18"],"工厂方法模式":["4.18"],"由多个类可以组合成一个更大的系统":["4.19"],"在类结构型模式中一般只存在继承关系和实现关系":["4.19"],"对象结构型模式关心类与对象的组合":["4.19"],"通过关联关系使得在一":["4.19"],"个类中定义另一个类的实例对象":["4.19"],"职责链模式":["4.20"],"命令模式":["4.20"],"简单工厂实现":["4.22"],"simplefactory":["4.22"],"const":["4.22","4.24","4.30","4.32","5.5","5.7","5.8","15.0"],"createcolawithtype":["4.22"],"number":["4.22","8.5","8.9","9.30","40.7","49.4"],"switch":["4.22"],"case":["4.22"],"可口可乐工厂":["4.23"],"cocacola":["4.23"],"extends":["4.23","8.5","10.0","10.15","13.3","48.0"],"百事可乐工厂":["4.23"],"cocacolabox":["4.24"],"pepsicolabox":["4.24"],"工厂抽象类":["4.24"],"createcola":["4.24"],"new":["4.24","4.38","9.13","15.0","48.7"],"createbottle":["4.24"],"createsingleton":["4.25"],"let":["4.25","21.1","25.3"],"instance":["4.25"],"return":["4.25","4.26","4.40","4.41","9.13","34.18","34.21","39.7","39.9","47.2"],"if":["4.25","4.30","4.34","4.38","4.40","9.17","25.3","34.19"],"super":["4.26"],"this":["4.26","4.27","4.37","4.43"],"最终组建一个产品":["4.26"],"vehicleprototype":["4.27"],"init":["4.27"],"carmodel":["4.27"],"model":["4.27"],"getmodel":["4.27"],"myclass":["4.29"],"function":["4.29","4.30","4.41","4.42","5.8","9.14","34.3"],"target":["4.29","34.16"],"annotated":["4.29"],"true":["4.29","34.14","49.1"],"装饰方法或属性":["4.29"],"el":["4.30"],"ev":["4.30"],"fn":["4.30","4.36"],"redirect":["4.31"],"remove":["4.31"],"vary":["4.31"],"has":["4.31"],"set":["4.31"],"append":["4.31"],"flushheaders":["4.31"],"access":["4.31"],"status":["4.31","16.3"],"音乐服务":["4.32"],"musicservice":["4.32"],"共享的音乐库":["4.32"],"musiclibrary":["4.32"],"听音乐":["4.32"],"listentomusic":["4.32"],"music":["4.32"],"下载音乐":["4.32"],"wd":["4.33"],"word":["4.33"],"say":["4.33"],"说话":["4.33"],"ball":["4.33"],"创建球类":["4.33"],"可以着色和运动":["4.33"],"event":["4.34","34.6","34.7"],"callback":["4.34"],"addeventlistener":["4.34"],"ordercommon":["4.36"],"普通購買":["4.36"],"无優惠卷":["4.36"],"库存不够":["4.36"],"链路代码":["4.36"],"接收者类":["4.37"],"execute":["4.37"],"console":["4.37","4.43","4.44","5.2"],"log":["4.37","4.43","4.44","5.2"],"接收者执行请求":["4.37"],"命令对象类":["4.37"],"调用接收者对应接口执行":["4.37"],"instanceof":["4.38"],"typeerror":["4.38"],"minusexpression":["4.38"],"call":["4.39"],"players":["4.40"],"winarr":["4.40"],"losearr":["4.40"],"push":["4.40"],"length":["4.40","8.9","9.30","34.21"],"var":["4.41","4.42","4.44","34.1","34.2"],"page":["4.41"],"通过cache对象缓存数据":["4.41"],"cache":["4.41"],"其他对象将相应作出反应":["4.42"],"在":["4.42"],"javascript":["4.42"],"中观察者模式的实现主要用事件模型":["4.42"],"dom":["4.42"],"事件":["4.42"],"发布者":["4.42"],"pub":["4.42"],"currentstate":["4.43"],"jump":["4.43"],"move":["4.43"],"shoot":["4.43"],"squat":["4.43"],"指令处理集合":["4.44"],"compileutil":["4.44"],"v":["4.44"],"text更新视图原理":["4.44"],"text":["4.44","4.46"],"node":["4.44"],"vm":["4.44"],"现在到了思考的时间":["4.45"],"我们刚刚泡了一杯咖啡和一壶茶":["4.45"],"有没有觉得这两个过程是大同小异的":["4.45"],"我们能很容易的就找出他们的共同点":["4.45"],"不同点就是原料不同嘛":["4.45"],"茶和咖啡":["4.45"],"我们可以把他们抽象为":["4.45"],"饮料":["4.45"],"哇":["4.45"],"泡的方式不同嘛":["4.45"],"一个是冲泡":["4.45"],"一个是浸泡":["4.45"],"我们可以把这个行为抽象为":["4.45"],"泡":["4.45"],"加入的调料也不同咯":["4.45"],"它们也可以抽象为":["4.45"],"调料":["4.45"],"吖":["4.45"],"这么一分析":["4.45"],"是不是很清楚了吖":["4.45"],"我们整理一下就是":["4.45"],"用沸水冲泡饮料":["4.45"],"把饮料倒进杯子":["4.45"],"加调料":["4.45"],"大家请注意":["4.45"],"主角来了":["4.45"],"btn":["4.46"],"innerhtml":["4.46"],"tagname":["4.46"],"访问者模式的思想就是在不改变操作对象的同时":["4.46"],"为它添加新的操作方法":["4.46"],"以实现对操作对象的访问":["4.46"],"我们知道":["4.46","24.0"],"apply":["4.46","5.4"],"的作用就是更改函数执行时的作用域":["4.46"],"这正是访问者模式的精髓":["4.46"],"通过":["4.46","10.8","10.16","11.13","11.14","11.20","12.2"],"这两种方式我们就可以让某个对象在其它作用域中运行":["4.46"],"数组方法封装":["4.46"],"在学习设计模式之前的很多时候我们是凭借过往经验和智慧来完善系统的设计":["4.47"],"patterns":["4.48"],"readthedocs":["4.48"],"io":["4.48","5.8"],"zh":["4.48"],"cn":["4.48"],"函数":["5.0"],"方法":["5.0","9.1"],"而是数学中的函数":["5.0"],"即映射关系":["5.0"],"相同的输入始终要得到相同的输出":["5.0"],"纯函数":["5.0"],"函数式编程用来描述数据":["5.0"],"我们可以把函数存储到变量":["5.1"],"数组中":["5.1"],"它还可以作为另一个函数的参数和返回值":["5.1"],"甚至我们还可以在程序运行的时候通过":["5.1"],"r":["5.2","20.1","36.5","39.6","39.9","40.6","48.5","49.2"],"随着栈的深度增加":["5.3"],"直到内存不够分配":["5.3"],"产生溢出":["5.3"],"栈的优势":["5.3"],"所有方法中的变量都存在栈中":["5.3"],"stringfy":["5.4"],"arguments":["5.4"],"返回该函数并等待继续传递参数":["5.5"],"参数":["5.5"],"需要柯里化的函数":["5.5"],"返回值":["5.5"],"柯里化后的函数":["5.5"],"lodash中的curry的使用":["5.5"],"require":["5.5","5.8"],"loadsh":["5.5"],"getsum":["5.5"],"a":["5.5","9.3","9.25","12.5","12.6","26.0","47.3","49.4"],"如果是表达式赋值的话":["5.6"],"不会变量提升":["5.6"],"函数的组合要满足结合律":["5.6"],"即":["5.6"],"三个函数":["5.6"],"无论先组合那几个":["5.6"],"结果都是等效的":["5.6"],"需要定义一些辅助的基本运算函数":["5.7"],"parsejson":["5.8"],"str":["5.8","9.14","34.18"],"json":["5.8"],"message":["5.8","41.1"],"l":["5.8","48.1"],"name":["5.8"],"zs":["5.8"],"toupper":["5.8"],"函子中的":["5.8"],"是一个函数":["5.8"],"这里是把函数当作值来处理":["5.8"],"函子可以把不纯的函数储存到":["5.8"],"中":["5.8"],"延迟执行这个不纯的操作":["5.8"],"惰性执行":["5.8"],"把不纯的操作交给调用者来处理":["5.8"],"fp":["5.8"],"lodash":["5.8"],"仍在加载":["7.4"],"interactive":["7.4"],"num2":["8.0","8.3","8.5"],"类型参数":["8.2","8.8","9.5","10.16","10.17","11.9","11.11","11.13","11.14","12.2","12.11","12.13","48.4"],"是要构造的数组的长度":["8.2"],"buildarray":["8.3"],"arr1":["8.3"],"unknown":["8.4","8.5","8.7","13.1"],"subtract":["8.4"],"num1":["8.5"],"countarr":["8.5"],"infer":["8.7","10.0","48.0"],"rest":["8.7","10.5","11.8","48.1"],"indexarr":["8.9"],"num":["8.9"],"动态类型检查":["9.1"],"在源码中不保留类型信息":["9.1"],"对某个变量赋什么值":["9.1"],"做什么操作都是允许的":["9.1"],"写代码很灵活":["9.1"],"但这也埋下了类型不安全的隐患":["9.1"],"比如对":["9.1"],"做了乘除":["9.1"],"对":["9.1","10.2"],"对象调用了":["9.1"],"exec":["9.1","9.6"],"这些都是运行时才能检查出来的错误":["9.1"],"声明时把会变化的类型声明成泛型":["9.4"],"也就是类型参数":["9.4"],"在调用的时候再确定类型":["9.4"],"就是这种类型系统":["9.4"],"如果你看过":["9.4"],"代码":["9.4"],"如果是":["9.5"],"的只支持泛型的类型系统可以做到么":["9.5"],"明显不能":["9.5"],"但是":["9.5","9.17"],"的类型系统就可以":["9.5"],"因为它可以对泛型":["9.5"],"做各种逻辑处理":["9.5"],"只不过":["9.5"],"这个类型的类型逻辑的代码比较多":["9.5"],"下面的":["9.5"],"类型暂时看不懂没关系":["9.5"],"在顺口溜那节会有详解":["9.5"],"这里只是用来直观感受下类型编程的复杂度的":["9.5"],"等学完以后大家也能实现这样的复杂高级类型的":["9.5"],"parseparam":["9.5"],"param":["9.5","30.3"],"date":["9.6"],"类型的对象就不能调用":["9.6"],"这是类型检查做的事情":["9.6"],"的子类型":["9.7"],"更具体":["9.7"],"那么":["9.7","13.3"],"类型的变量就可以赋值给":["9.7"],"类型":["9.7","10.8","20.3"],"不是":["9.8"],"的父类型么":["9.8"],"为啥能赋值给子类型":["9.8"],"因为这个函数调用的时候是按照":["9.8"],"来约束的类型":["9.8"],"但实际上函数只用到了父类型":["9.8"],"的属性和方法":["9.8"],"type":["9.9","9.28","19.3","34.15","36.5","41.1"],"而":["9.9","10.2","26.0"],"ts":["9.9","9.12","9.15","9.28","47.1"],"里不看这个":["9.9"],"只要结构上是一致的":["9.9"],"那么就可以确定父子关系":["9.9"],"这种叫做结构类型系统":["9.9"],"structual":["9.9"],"还有就是它们的包装类型":["9.11"],"func":["9.13","9.14","47.2","48.4","48.5"],"hello":["9.13","47.2"],"构造器":["9.13","47.2"],"personconstructor":["9.13"],"开头":["9.14"],"后面是任意":["9.14"],"的字符串字面量类型":["9.14"],"所以想要约束以某个字符串开头的字符串字面量类型时可以这样写":["9.14"],"interface":["9.15"],"iperson":["9.15","47.8"],"typescript":["9.16","39.1","47.3"],"上面这样的逻辑没啥意义":["9.17"],"静态的值自己就能算出结果来":["9.17"],"为什么要用代码去判断呢":["9.17"],"所以":["9.17","9.24","13.2"],"never":["9.18","10.3","10.5","10.16","10.17","11.11","12.2","12.4","12.10","48.0","48.4","48.5","49.2"],"res":["9.18","18.1"],"但是作用于类型":["9.19","49.3"],"代表类型可以是几个类型之一":["9.19","49.3"],"可以合并的":["9.20"],"映射类型就相当于把一个集合映射到另一个集合":["9.21","49.5"],"这是它名字的由来":["9.21","49.5"],"除了值可以变化":["9.21","49.5"],"索引也可以做变化":["9.21","49.5"],"用":["9.21","10.7","10.8","49.5"],"as":["9.21","49.5"],"运算符":["9.21","49.5"],"叫做重映射":["9.21","49.5"],"结果是":["9.23"],"可以是任何类型":["9.24"],"任何类型也都是":["9.24"],"所以当这样写判断不出":["9.24"],"类型来":["9.24"],"我们会这样写":["9.24"],"可以这样写":["9.26"],"而数组的":["9.27","9.30"],"中有函数参数是有逆变的性质的":["9.28"],"也就是如果参数可能是多个类型":["9.28"],"参数类型会变成它们的交叉类型":["9.28"],"所以联合转交叉可以这样实现":["9.28"],"u":["9.28"],"用映射类型的语法重新构造索引类型":["9.29"],"索引是之前的索引也就是":["9.29"],"但要做一些过滤":["9.29"],"也就是":["9.29","11.3","12.13"],"元组类型也是数组类型":["9.30"],"但":["9.30"],"是数字字面量":["9.30"],"是":["9.30","13.2","35.1"],"可以这样做":["10.0"],"getvaluetype":["10.0","11.0"],"只能接收任意类型的值":["10.2"],"除了可以接收任意类型的值":["10.2"],"也可以赋值给任意类型":["10.2"],"除了":["10.2","47.6"],"类型体操中经常用":["10.2"],"接受和匹配任何类型":["10.2"],"而很少把任何类型赋值给某个类型变量":["10.2"],"last":["10.3"],"当类型参数":["10.3","10.4","10.5"],"声明的局部变量":["10.4","10.9","10.12","11.5","48.1","48.2"],"里":["10.4","10.9","11.5","48.1","48.2"],"返回":["10.4"],"匹配一个模式字符串":["10.6"],"它们都是":["10.7"],"去匹配一个模式类型":["10.7"],"模式类型的前缀是":["10.7"],"约束为都是":["10.8"],"去匹配模式串":["10.8"],"模式串由":["10.8"],"和之前之后的字符串构成":["10.8"],"换行":["10.9","48.2"],"制表符":["10.9","48.2"],"那就把字符串放到":["10.9","48.2"],"把":["10.9"],"作为类型参数递归":["10.9"],"比如提取参数":["10.10"],"约束为":["10.11","11.14","12.13"],"和模式类型做匹配":["10.11","10.12"],"参数类型放到用":["10.11"],"提取返回值到通过":["10.12"],"x":["10.13"],"调用的时候":["10.13"],"就变了":["10.13","48.6"],"但这里却没有被检查出来":["10.13","48.6"],"指向的错误":["10.13","48.6"],"如何让编译器能够检查出":["10.13"],"指向的错误呢":["10.13"],"可以在方法声明时指定":["10.13"],"的类型":["10.13"],"构造器是用于创建对象的":["10.14"],"constructortype":["10.15"],"args":["10.15"],"any":["10.15","21.1"],"为待处理的类型":["10.16"],"约束为构造器类型":["10.16"],"getpropsref":["10.17"],"value":["10.17"],"相当于局部变量":["11.0"],"p":["11.0"],"想对类型做各种变换产生新的类型就需要重新构造":["11.1"],"数组":["11.1"],"元组类型":["11.3"],"元素的类型任意":["11.3"],"是添加的元素的类型":["11.3"],"返回的是用":["11.3"],"arr":["11.4","13.1","34.12"],"的元素到":["11.5"],"用提取的元素构造成新的元组返回即可":["11.5"],"zipresult":["11.5"],"uppercase":["11.7","11.8","13.0"],"我们声明了类型参数":["11.7"],"是待处理的字符串":["11.9"],"是要删除的字符串":["11.9"],"是待处理的函数类型":["11.11"],"只读":["11.12"],"可选":["11.12"],"是待处理的索引类型":["11.13","11.14","12.13"],"新的索引类型的索引为":["11.14"],"就可以创建一个对应的索引类型":["11.15"],"上面的索引类型的约束我们用的":["11.15"],"object":["11.15"],"其实更语义化一点我推荐用":["11.15"],"key":["11.16","11.18"],"keyof":["11.16","11.17","11.19"],"约束为索引为":["11.20"],"值为任意类型的索引类型":["11.20","12.13"],"类型系统不支持循环":["12.0"],"但支持递归":["12.0"],"当处理数量":["12.0"],"是待处理的":["12.2"],"four":["12.4"],"five":["12.4"],"但如果数组长度不确定呢":["12.4"],"就要条件反射的想到递归":["12.9"],"每次递归只处理一个类型":["12.9"],"这部分我们已经实现了":["12.9"],"那么加上递归的调用就可以":["12.9"],"但如果字符串长度不确定呢":["12.10"],"数量不确定":["12.10"],"在类型体操中就要条件反射的想到递归":["12.10"],"也就是索引为":["12.13"],"索引映射自之前的索引":["12.13"],"只不过加上了":["12.13"],"result":["13.0"],"camelcasearr":["13.1"],"item":["13.1"],"restarr":["13.1"],"的时候":["13.2"],"结果是这样的":["13.2"],"都是同一个联合类型":["13.2"],"为啥值还不一样呢":["13.2"],"因为条件类型中如果左边的类型是联合类型":["13.2"],"会把每个元素单独传入做计算":["13.2"],"而右边不会":["13.2"],"就可以这样实现":["13.3"],"string":["13.3"],"modifiers":["13.3"],"然后构造出来的字符串再和其他字符串组合":["13.4"],"所以全组合的高级类型就是这样":["13.4"],"不是没意义":["13.5"],"意义是取出联合类型中的单个类型放入":["13.5"],"的二叉树":["14.0"],"最多有":["14.0"],"最少有":["14.0"],"个节点的二叉树称为满二叉树":["14.1"],"从左到右的顺序进行编号":["14.2"],"如果编号为":["14.2"],"或者是具有下列性质的二叉树":["14.3"],"若它的左子树不空":["14.3"],"且左子树和右子树的高度差的绝对值不超过":["14.4"],"查找路径不只两个":["14.5"],"m":["14.7","21.1"],"所以红黑树不是严格意义上的平衡二叉树":["14.8"],"是不是":["14.18"],"bundle":["15.0"],"文件路径":["16.4"],"需要监听的文件":["16.4"],"并返回一个新的":["18.0"],"refresh":["18.1"],"async":["18.1"],"await":["18.1"],"promise":["18.1"],"allsettled":["18.1"],"声明变量":["18.3"],"必须和下面的对应起来":["18.3"],"changecase":["19.2"],"无":["19.3"],"首字母大写":["19.3"],"匹配目标参数":["20.1"],"window":["20.1","34.6"],"geturlparam":["20.2"],"月":["21.0"],"ret":["21.1"],"opt":["21.1"],"y":["21.1","34.20"],"getfullyear":["21.1"],"年":["21.1"],"timeformat":["21.2"],"mm":["21.3"],"dd":["21.3"],"一次比较两个元素":["22.0"],"如果它们的顺序错误就把它们交换过来":["22.0"],"这样在最后的元素应该会是最大的数":["22.1"],"j":["22.3","31.3","34.4"],"将数据分到有限数量的桶里":["23.0"],"对每个不是空的桶进行排序":["23.1"],"getmin":["23.2"],"min":["23.2"],"因为其它部分的时间复杂度都为":["23.3"],"这里的不基于比较指的是数组元素之间不存在比较大小的排序算法":["24.0"],"从":["24.1"],"中的第一个元素开始":["24.1"],"时间复杂度是":["24.4"],"o":["24.4"],"是指利用堆这种数据结构所设计的一种排序算法":["25.0"],"由于交换后新的堆顶":["25.1"],"right":["25.3"],"largest":["25.3"],"原本在":["26.0"],"前面":["26.0"],"排序之后":["26.0"],"n2":["27.0"],"的时间复杂度":["27.0","31.4"],"大于新元素":["27.1"],"将该元素移到下一位置":["27.1"],"preindex":["27.3"],"即只需用到":["27.4"],"conquer":["28.0"],"的一个非常典型的应用":["28.0"],"因为始终都是":["28.4"],"通过一趟排序将待排记录分隔成独立的两部分":["29.0"],"基准":["29.1"],"pivot":["29.1"],"重新排序数列":["29.1"],"依次类推":["30.0"],"直到最高位":["30.0"],"从最低位开始取每个位组成":["30.1"],"radix":["30.1","30.3"],"maxdigit":["30.3"],"则基数排序的时间复杂度将是":["30.4"],"2n":["30.4"],"首先在未排序序列中找到最小":["31.0"],"大":["31.0"],"当前有序区和无序区分别为":["31.1"],"发明":["32.0"],"第一个突破":["32.0"],"按增量序列个数":["32.1"],"k":["32.1"],"对序列进行":["32.1"],"第":["32.4"],"absolute":["33.1"],"left":["33.1"],"space":["33.3"],"要截取的字符串":["34.1","34.2"],"requestpermission":["34.3"],"相邻元素两两对比":["34.4"],"元素交换":["34.4"],"大的元素交换到后面":["34.4"],"aa":["34.5"],"returnvalue":["34.7"],"jkl":["34.8"],"logic":["34.8"],"shorthand":["34.8","34.10"],"case3":["34.9"],"test":["34.9"],"fgh":["34.11"],"efg":["34.12"],"responsetype":["34.14"],"blob":["34.14"],"onload":["34.14"],"sheet":["34.15"],"unique":["34.17"],"pageyoffset":["34.20"],"所以再次使用时无需重复下载":["35.2"],"同时利用并行下载以最大化资源利用率":["35.2"],"install":["35.3"],"添加包":["35.4"],"会更新package":["35.4"],"json和yarn":["35.4"],"在当前的项目中添加一个依赖包":["35.4"],"会自动更新到package":["35.4"],"lock文件中":["35.4"],"add":["35.4"],"package":["35.4"],"安装指定版本":["35.4"],"这里指的是主要版本":["35.4"],"如果需要精确到小版本":["35.4"],"使用":["35.4"],"e参数":["35.4"],"安装某个tag":["35.4"],"比如beta":["35.4"],"next或者latest":["35.4"],"更新的时候":["35.5"],"再次安装模块就会安装":["35.5"],"的最新版本":["35.5"],"xml":["36.1","45.4","46.1"],"bottom":["36.5"],"12px":["36.5"],"default":["36.5"],"user":["36.5","37.1","40.3","40.4","40.5","40.9"],"默认按钮":["36.5"],"primary":["36.6","41.1"],"3f51b5":["37.5"],"justify":["37.7"],"content":["37.7","41.4"],"src":["38.1"],"f379":["38.4"],"08":["38.4"],"a0cnre2ankupk":["38.4"],"acnpvkspcaaeibacyxuyfabgm3ynhuaecrngazluypgeirklhu7u7xdyytgwhad8jjnyng4od7vnz51dbpt8":["38.4"],"7z58":["38.4"],"nb9":["38.4"],"bt6ju":["38.4"],"ti":["38.4"],"agwhenrx48ej":["38.4"],"essmhzx40l18":["38.4"],"ui":["39.0"],"采用":["39.1"],"dt":["39.2"],"d":["39.2"],"接下来是一些使用例子":["39.4"],"button":["39.5","39.8"],"app":["39.7"],"url":["39.9"],"createobjecturl":["39.9"],"div":["39.9"],"preview":["39.9"],"skeleton":["39.10"],"width":["39.10"],"100px":["39.10"],"top":["39.10"],"10px":["39.10"],"其他均有较好支持":["39.11"],"设计规范":["39.12"],"element":["39.12"],"ecma":["39.13"],"input":["40.1"],"组件联动的时候有效":["40.11"],"document":["40.15"],"createelement":["40.15"],"onclick":["41.1","43.1"],"info":["41.1"],"错误提示":["41.3"],"duration":["41.4"],"close":["41.4"],"pptx":["43.0"],"uploadfile":["43.1"],"choose":["43.1"],"file":["43.1"],"to":["43.1"],"就不展示":["43.3"],"时":["43.4"],"表示不可关闭":["43.4"],"tab3":["45.1","45.3","46.1","46.3","46.4","46.5"],"tab4":["45.5"],"也可以单独指定":["46.6"],"clean":["46.7"],"null":["47.0"],"复合类型":["47.0"],"class":["47.0"],"还支持字面量类型":["47.3"],"也就是类似":["47.3"],"aaaa":["47.3"],"或":["47.4"],"readonly":["47.8","50.21"],"inter":["48.1","49.2"],"我们分别取了首尾元素":["48.1"],"当然也可以取剩余的数组":["48.1"],"比如取去掉了最后一个元素的数组":["48.1"],"pop":["48.1"],"如果是空数组":["48.1"],"就直接返回":["48.1"],"否则匹配剩余的元素":["48.1"],"放到":["48.1"],"匹配字符串":["48.2"],"空白字符":["48.2"],"空格":["48.2"],"这里的":["48.6","48.8"],"返回的是":["48.8"],"objtype":["49.4"],"用于提取函数参数的类型":["50.3"],"partial":["50.21"],"required":["50.21"],"pick":["50.21"]},{"0":["1.5","4.22","4.46","5.2","8.8","14.0","40.10"],"1":["4.46","5.0","5.1","5.5","9.18","9.24","10.3","10.4","10.5","14.2","14.4","24.3","27.4","49.2"],"2":["4.0","5.5","5.8","8.0","9.18","9.24","10.3","10.4","10.5","19.3","28.1","45.6","49.2"],"3":["1.17","5.5","5.8","9.7","9.18","10.4","10.5","19.1","27.1","39.1","39.13","49.2"],"4":["4.20","32.4"],"5":["4.20","4.39","23.2","37.6","40.10"],"6":["5.5"],"8":["34.15","39.12"],"9":["39.12"],"22":["46.6"],"50":["33.1"],"70":["37.4"],"123":["34.6"],"成":["1.1"],"转成":["1.1"],"之后就可以通过修改":["1.1"],"标识符":["1.2"],"表达式":["1.2"],"字符串字面量":["1.3"],"正则表达式字面量":["1.3"],"regexpliteral":["1.3"],"呢":["1.4"],"const":["1.4","4.23","4.38","40.14"],"name":["1.4","1.8","9.15","20.2","20.3","47.8"],"let":["1.5","5.0","9.7"],"key":["1.5"],"in":["1.5","9.5"],"obj":["1.5","11.15"],"i":["1.5","14.2","32.3"],"d":["1.6","21.1","35.4"],"from":["1.6"],"e":["1.6","34.14"],"default":["1.6","4.22"],"节点是不是某种类型要看它是不是符合该种类型的特点":["1.7"],"比如语句的特点是能够单独执行":["1.7"],"表达式的特点是有返回值":["1.7"],"有的表达式可以单独执行":["1.7"],"符合语句的特点":["1.7"],"所以也是语句":["1.7"],"比如赋值表达式":["1.7"],"数组表达式等":["1.7"],"guang":["1.8"],"extends":["1.8","9.25","9.28","11.0","11.4"],"person":["1.8"],"所以":["1.9","9.9","9.23"],"语法的":["1.9"],"的结构是":["1.9"],"包含着各种":["1.9"],"export":["1.9"],"也有":["1.9"],"节点":["1.10","2.0"],"比如":["1.10","9.4","47.3"],"use":["1.10"],"等":["1.11","5.8"],"是最外层节点":["1.11"],"注释分为块注释和行内注释":["1.11"],"对应":["1.11"],"就可以保存下来":["1.12"],"然后把":["1.12"],"url":["1.12"],"分享出去":["1.12"],"比如这个链接":["1.12"],"https":["1.12"],"节点中都可能存在注释":["1.13"],"而且可能在开始":["1.13"],"中间":["1.13"],"结束这三种位置":["1.13"],"想拿到某个":["1.13"],"的注释就通过这三个属性":["1.13"],"比如这段有注释的代码的":["1.13"],"所以一些可以单独执行的":["1.14"],"会包一层":["1.14"],"expressionstatement":["1.14"],"不同":["1.14"],"之间也存在千丝万缕的联系":["1.15"],"而后面所要介绍的语法分析器":["1.15"],"就是来梳理各个":["1.15"],"之间的联系":["1.15"],"as":["1.17"],"keyof":["1.17","11.18"],"typeof":["1.17"],"如果是普通标识符":["1.17"],"push":["1.17","4.46"],"处理单字符":["1.17"],"known":["1.17"],"single":["1.17"],"has":["1.17"],"singlechartokens":["1.17"],"结构到底是什么样子":["1.18"],"你可以去":["1.18"],"提供了":["2.0"],"xxx":["2.0"],"isxxx":["2.0"],"assertxxx":["2.0"],"template":["2.0"],"当需要批量创建":["2.0"],"web":["3.0","39.9"],"前端来说":["3.0"],"种具体类":["4.0"],"一般不对抽象类进行实例化":["4.0"],"组合优于继承":["4.0"],"不能滥用继承来拓展功能":["4.0"],"配合组合会更灵活":["4.0"],"同样拿":["4.0"],"抽象类来举例":["4.0"],"如果使用继承":["4.0"],"区分不同类型的":["4.0"],"我们可以派生出":["4.0"],"同时":["4.1"],"我们应该能将类图所表达的含义和最终的代码对应起来":["4.1"],"有了这些知识":["4.1"],"看后面章节的设计模式结构图就没有什么问题了":["4.1"],"但组合关系是一种强依赖的特殊聚合关系":["4.4"],"如果整体不存在了":["4.4"],"整体和部分不是强依赖的":["4.5"],"即使整体不存在了":["4.5"],"乘车人和车票之间就是一种关联关系":["4.6"],"学生和学校就是一种关联关系":["4.6"],"关联关系默认不强调方向":["4.6"],"表示对象间相互知道":["4.6"],"它是一种临时性的关系":["4.7"],"通常在运行期间产生":["4.7"],"并且随着运行时的变化":["4.7"],"抽象化是开闭原则的关键":["4.9"],"在":["4.9","9.4","39.9"],"java":["4.9"],"c":["4.9","45.4","46.5","49.4"],"等编程语言中":["4.9"],"可以为系统定义一个相对稳定的抽象层":["4.9"],"的话":["4.10"],"如":["4.10"],"method1":["4.10"],"那么它必然可以接受一个":["4.10"],"类型的子类对象":["4.10"],"sub":["4.10","4.42"],"在引入抽象层后":["4.11"],"系统将具有很好的灵活性":["4.11"],"在程序中尽量使用抽象层进行编程":["4.11"],"而将具体类写在配置文件中":["4.11"],"这样一来":["4.11"],"因此要将这些职责进行分离":["4.12"],"将不同的职责封装在不同的类中":["4.12"],"即将不同的变化原因封装在不同的类中":["4.12"],"如果多个职责总是同时发生改变则可将它们封装在同一类中":["4.12"],"单一职责原则是实现高内聚":["4.12"],"低耦合的指导方针":["4.12"],"就是通过引入一个合理的第三者来降低现有对象之间的耦合度":["4.13"],"在将迪米特法则运用到系统设计中时":["4.13"],"要注意下面的几点":["4.13"],"在类的划分上":["4.13"],"应当尽量创建松耦合的类":["4.13"],"类之间的耦合度越低":["4.13"],"在使用接口隔离原则时":["4.14"],"我们需要注意控制接口的粒度":["4.14"],"接口不能太小":["4.14"],"如果太小会导致系统中接口泛滥":["4.14"],"聚合关系或通过继承":["4.15"],"但首先应该考虑使用组合":["4.15"],"聚合":["4.15"],"组合":["4.15"],"聚合可以使系统更加灵活":["4.15"],"将复杂的逻辑封装并提供简单易用的接口":["4.16"],"单一职责原则":["4.16"],"使项目中的类和方法根据职责细分":["4.16"],"避免单个类负担过重":["4.16"],"和行为型":["4.17"],"behavioral":["4.17"],"三种":["4.17"],"method":["4.18","4.29"],"抽象工厂模式":["4.18"],"abstract":["4.18"],"然后通过该对象调用其方法":["4.19"],"根据":["4.19"],"合成复用原则":["4.19"],"在系统中尽量使用关联关系来替代继":["4.19"],"承关系":["4.19"],"解释器模式":["4.20"],"迭代器模式":["4.20"],"中介者模式":["4.20"],"return":["4.22","4.43","9.3","28.3","34.5","34.16","34.17"],"new":["4.22","4.25","4.33","10.14","24.3","30.3","47.2"],"pepsicola":["4.23"],"根据不同的工厂类生产不同的产品":["4.23"],"createbox":["4.24"],"可口可乐主题工厂":["4.24"],"cocacolafactory":["4.24"],"百事可乐主题工厂":["4.24"],"产品角色":["4.26"],"dosomething":["4.26"],"独立业务":["4.26"],"director":["4.26"],"set":["4.26"],"console":["4.27","4.39","4.42","5.5","5.6","34.12"],"log":["4.27","4.39","4.42","5.5","5.6"],"车辆模具是":["4.27"],"vehicle":["4.27"],"f":["4.27","5.7"],"js":["4.29","5.0","39.4"],"readonly":["4.29","9.15"],"addeventlistener":["4.30","4.42"],"false":["4.30","9.26","12.6","34.7","49.1"],"else":["4.30","4.34","4.41"],"message":["4.31"],"body":["4.31","4.42","34.20"],"length":["4.31","4.46","8.5"],"type":["4.31","9.12","9.19","9.23","47.1","48.6","48.8","49.3"],"lastmodified":["4.31"],"etag":["4.31"],"getter":["4.31"],"headersent":["4.31"],"downloadmusic":["4.32"],"免费音乐服务":["4.32"],"freemusicservice":["4.32"],"listenfreemusic":["4.32"],"if":["4.32","4.41","22.3","31.3","34.4"],"ismusicfree":["4.32"],"init":["4.33","4.36"],"attachevent":["4.34"],"this":["4.36","4.44","39.6"],"successor":["4.36"],"null":["4.36","9.1"],"prototype":["4.36","4.46"],"setnext":["4.36"],"result":["4.36"],"apply":["4.36"],"发布者类":["4.37"],"invoke":["4.37"],"发布请求":["4.37"],"以下是测试代码":["4.38"],"依次添加":["4.38"],"加法":["4.38"],"减法":["4.38"],"el":["4.39"],"index":["4.39","4.48","18.1"],"item":["4.39","18.1"],"优点":["4.39"],"show":["4.40"],"fn":["4.41"],"showpage":["4.41"],"post":["4.41"],"欢迎订阅":["4.42"],"订阅者":["4.42"],"document":["4.42","34.15","34.20","40.14"],"订阅者实现订阅":["4.42"],"change":["4.43"],"arr":["4.43","34.17"],"更改当前动作":["4.43"],"go":["4.43"],"触发动作":["4.43"],"foreach":["4.43","18.1"],"exp":["4.44"],"bind":["4.44"],"html更新视图原理":["4.44"],"html":["4.44","4.48","37.3","37.4","37.5","37.6","39.4","39.9","40.3","40.4","40.5","40.8","40.9","43.1","43.3","43.4","46.5"],"class绑定原理":["4.44"],"class":["4.44"],"之前我们已经扔出了概念":["4.45"],"所以我们现在可以创建一个抽象父类来表示泡一杯饮料的过程":["4.45"],"那么":["4.45"],"抽象父类":["4.45"],"抽象类":["4.45"],"抽象类是不能被实例化的":["4.45"],"一定是用来继承的":["4.45"],"继承了抽象类的所有子类都将拥有跟抽象类一致的接口方法":["4.45"],"抽象类的主要作用就是为它的子类定义这些公共接口":["4.45"],"通过上面分析":["4.45"],"这里具体来说就是要把泡茶和泡咖啡的共同步骤共同点找出来":["4.45"],"封装到父类":["4.45"],"也就是抽象类中":["4.45"],"然后不同的步骤写在子类中":["4.45"],"也就是茶和咖啡中":["4.45"],"抽象类既然不能被实例化":["4.45"],"不怕啊":["4.45"],"子类就是他的实例化":["4.45"],"泡饮料啦":["4.45"],"beverage":["4.45"],"brew":["4.45"],"addcondiments":["4.45"],"splice":["4.46"],"args":["4.46"],"array":["4.46","18.3","47.0"],"arguments":["4.46"],"len":["4.46"],"而这些经验很多和某个设计模式的思想不谋而合":["4.47"],"latest":["4.48"],"blog":["4.48"],"之间的映射关系":["5.0"],"非函数式编程":["5.0"],"面向过程的编程方式":["5.0"],"num1":["5.0"],"alert":["5.1"],"来构建一个新的函数":["5.1"],"函数作为返回值":["5.2"],"makefn":["5.2"],"msg":["5.2"],"highter":["5.2"],"随着方法执行的结束":["5.3"],"这个方法的内存栈也随之销毁":["5.3"],"存取速度很快":["5.3"],"仅次于":["5.3"],"cpu":["5.3"],"的寄存器":["5.3"],"可测试":["5.4"],"让测试更方便":["5.4"],"多线程环境下操作共享的内存数据可能会出现意外的情况":["5.4"],"而纯函数不需要共享的数据空间":["5.4"],"只和输入有关":["5.4"],"所以并行环境下可以任意运行纯函数":["5.4"],"副作用":["5.4"],"副作用会让纯函数变的不纯":["5.4"],"比如依赖外部的状态":["5.4"],"就无法保证输出相同":["5.4"],"curried":["5.5"],"函数组合如何进行调试":["5.6"],"v":["5.6"],"库中的":["5.6"],"fp":["5.6","5.7"],"模块":["5.6"],"flowright":["5.7","5.8"],"调用":["5.8"],"因为是在node环境":["5.8"],"所以直接传递process对象":["5.8"],"node的进程":["5.8"],"process":["5.8"],"p":["5.8","35.4"],"execpath":["5.8"],"执行node进程的路径":["5.8"],"folktale":["5.8"],"是一个标准的函数式编程库":["5.8"],"和":["5.8","8.4"],"ramda":["5.8"],"不同的是":["5.8"],"他没有提供很多功能函数":["5.8"],"只提供了函数式处理的操作":["5.8"],"例如":["5.8"],"curry":["5.8"],"compose":["5.8"],"和一些函子":["5.8"],"task":["5.8"],"task处理异步任务":["5.8"],"fs":["5.8"],"concurrency":["5.8"],"split":["5.8"],"find":["5.8","34.11"],"loadsh":["5.8"],"readfile":["5.8"],"filename":["5.8"],"resolver":["5.8"],"fun":["7.2"],"互动":["7.4"],"文档已经完成加载":["7.4"],"文档已被解析":["7.4"],"num3":["8.0"],"是数组元素":["8.2"],"默认为":["8.2"],"为构造出的数组":["8.2"],"默认是":["8.2"],"如果":["8.2","8.8","9.8"],"的长度到达了":["8.2"],"arr2":["8.3"],"infer":["8.3","9.5","10.15"],"rest":["8.3"],"never":["8.3","9.14","9.28","10.0","11.0","13.4","47.4","47.6"],"类型参数":["8.3","8.4","8.7","8.9","10.15","11.8","12.5","12.6","12.7","13.1","13.3"],"buildarray":["8.4"],"分别是被加数和加数":["8.4"],"因为乘法是多个加法结果的累加":["8.4"],"我们加了一个类型参数":["8.4"],"subtract":["8.5"],"是待比较的两个数":["8.8"],"是计数用的":["8.8"],"会不断累加":["8.8"],"默认值是":["8.8"],"代表从":["8.8"],"开始":["8.8"],"其中":["9.1","47.3"],"最常见的错误应该是":["9.1"],"is":["9.1","39.6"],"not":["9.1"],"an":["9.1"],"undefined":["9.1","16.4"],"a":["9.1","34.5","34.15","45.4"],"之类的了":["9.1"],"写代码时没发现类型不匹配":["9.1"],"到了运行的时候才发现":["9.1"],"double":["9.3"],"你会发现泛型用的特别多":["9.4"],"这确实是一个很好的增加类型系统灵活性的特性":["9.4"],"但是":["9.4"],"这种类型系统的灵活性对于":["9.4"],"javascript":["9.4"],"来说还不够":["9.4"],"因为":["9.4","13.1"],"太过灵活了":["9.4"],"string":["9.5","9.15","16.4","47.8","49.5"],"value":["9.5","10.9","11.0","34.5"],"k":["9.5","31.1"],"mergevalues":["9.5"],"one":["9.5"],"other":["9.5"],"unknown":["9.5","9.14","9.28","11.4"],"遇到类型安全问题会在编译时报错":["9.6"],"但是这种类型安全的限制也不能太死板":["9.6"],"有的时候需要一些变通":["9.6"],"比如子类型是可以赋值给父类型的变量的":["9.6"],"可以完全当成父类型来使用":["9.6"],"当然不会有问题":["9.8"],"依然是类型安全的":["9.8"],"这就是逆变":["9.8"],"函数的参数有逆变的性质":["9.8"],"而返回值是协变的":["9.8"],"也就是子类型可以赋值给父类型":["9.8"],"那反过来呢":["9.8"],"printhoobies":["9.8"],"赋值给":["9.8"],"会发生什么":["9.8"],"因为函数声明的时候是按照":["9.8"],"来约束类型":["9.8"],"但是调用的时候是按照":["9.8"],"的类型来访问的属性和方法":["9.8"],"那自然类型不安全了":["9.8"],"所以就会报错":["9.8"],"但是在":["9.8"],"ts2":["9.8"],"通过结构":["9.9"],"更具体的那个是子类型":["9.9"],"这里的":["9.9","9.29"],"cat":["9.9"],"有":["9.9"],"animal":["9.9"],"的所有属性":["9.9"],"并且还多了一些属性":["9.9"],"这些很容易理解":["9.11"],"给":["9.11"],"添加静态类型":["9.11"],"总没有必要重新造一套基础类型吧":["9.11"],"直接复用":["9.11"],"function":["9.13","34.5","47.2"],"createperson":["9.13","47.2"],"ctor":["9.13","47.2"],"true":["9.14","9.26"],"还有四种特殊的类型":["9.14"],"void":["9.14"],"any":["9.14","10.12","11.15"],"代表不可达":["9.14"],"比如函数抛异常的时候":["9.14"],"返回值就是":["9.14"],"类型系统里有哪些类型":["9.16"],"类型运算逻辑都是用来做一些动态的类型的运算的":["9.17"],"也就是对类型参数的运算":["9.17"],"istwo":["9.17"],"t":["9.17","9.24"],"ts":["9.19","9.23","48.6","49.3"],"res":["9.20","49.1","49.2"],"我们用":["9.21"],"把索引也做了修改":["9.21"],"改成了":["9.21"],"个":["9.21"],"重复":["9.21"],"可以这样写":["9.23"],"这样就能正常判断":["9.26"],"类型了":["9.26"],"是":["9.27","9.29","18.3"],"x":["9.28"],"之后的部分":["9.29"],"过滤的方式就是单独取出该索引之后":["9.29"],"判断空对象是否是其子类型":["9.29"],"提供的内置高级类型":["9.29"],"就是取出某个":["9.29"],"构造新的索引类型":["9.29","11.20"],"可以用来判断元组类型":["9.30"],"函数参数处会发生逆变":["9.30"],"可以用来实现联合类型转交叉类型":["9.30"],"可选索引的索引可能没有":["9.30"],"那":["9.30"],"pick":["9.30"],"出来的就可能是":["9.30"],"可以用来过滤可选索引":["9.30"],"通过":["10.0","10.15","10.17","11.7","11.11","48.0","48.4"],"对传入的类型参数":["10.0","48.0"],"做模式匹配":["10.0","10.2","48.0"],"其中值的类型是需要提取的":["10.0","48.0"],"声明一个局部变量":["10.0"],"把我们要提取的第一个元素的类型放到通过":["10.2"],"声明的":["10.2"],"局部变量里":["10.2"],"后面的元素可以是任何类型":["10.2"],"用":["10.2","10.11","10.16","11.13"],"接收":["10.2"],"然后把局部变量":["10.2"],"返回":["10.2"],"为":["10.3","10.4","10.5"],"时":["10.4","21.1"],"把需要提取的部分放到":["10.6"],"后面是任意的":["10.7"],"如果匹配返回":["10.7"],"否则返回":["10.7"],"当匹配时":["10.7"],"把之前之后的字符串放到通过":["10.8"],"声明的局部变量":["10.8","10.11","10.16","12.2","48.5"],"里":["10.8","10.11"],"加上替换到的字符串":["10.8"],"构造成新的字符串类型返回":["10.8"],"直到不匹配":["10.9","48.2"],"这时的类型参数":["10.9","48.2"],"就是处理结果":["10.9","48.2"],"trimrightresult":["10.9"],"返回值的类型":["10.10"],"返回值可以是任何类型":["10.11"],"里返回":["10.12"],"参数类型可以是任意类型":["10.12"],"也就是":["10.12","10.17","11.14","11.20"],"这样":["10.13"],"所以可以被":["10.14"],"instancetype":["10.15"],"是待处理的类型":["10.15"],"匹配一个模式类型":["10.16"],"提取参数的部分到":["10.16"],"为待处理的类型":["10.17"],"取出":["10.17","11.13"],"的所有索引构成的联合类型":["10.17"],"判断下":["10.17"],"是否在其中":["10.17"],"为什么要做这个判断":["10.17"],"类型参数用于接受具体的类型":["11.0"],"字符串":["11.1"],"函数等类型的重新构造比较简单":["11.1"],"已有的元素加上":["11.3"],"构造的新的元组类型":["11.3"],"pushresult":["11.3"],"但是这样只能合并两个元素的元组":["11.5"],"如果是任意个呢":["11.5"],"那就得用递归了":["11.5"],"onerest":["11.5"],"是要处理的字符串类型":["11.7"],"约束为":["11.7","11.8","11.9","11.11","11.13","12.2","12.7","13.0","48.4"],"是待处理的字符串类型":["11.8"],"提取":["11.8"],"都通过":["11.9"],"类型":["11.9","12.2"],"通过模式匹配提取":["11.9"],"是要添加的参数类型":["11.11"],"通过模式匹配提取参数到":["11.11"],"中的索引":["11.14"],"但要做一些变换":["11.14"],"之后的":["11.14"],"uppercasekey":["11.15"],"通过映射类型构造了新的索引类型":["11.16"],"给索引加上了":["11.16"],"为要过滤出的值的类型":["11.20"],"索引为":["11.20"],"的索引":["11.20"],"个数":["12.0"],"长度":["12.0"],"层数":["12.0"],"不固定的类型的时候":["12.0"],"类型不确定":["12.2"],"设为":["12.2"],"每次只处理一个类型的提取":["12.2"],"也就是通过模式匹配提取出":["12.2"],"的类型到":["12.2"],"数量不确定":["12.4"],"条件反射的就要想到递归":["12.4"],"我们每次只处理一个类型":["12.4"],"剩下的递归做":["12.4"],"直到满足结束条件":["12.4"],"是待查找的数组类型":["12.5"],"元素类型任意":["12.5"],"为数组长度":["12.7"],"left":["12.9"],"right":["12.9"],"为待处理的字符串":["12.11"],"为构造出的字符":["12.11"],"默认值是空串":["12.11"],"通过模式匹配提取第一个字符到":["12.11"],"值要做下判断":["12.13"],"如果是":["12.13"],"类型并且还是":["12.13"],"那么就直接取之前的值":["12.13"],"类型但不是":["12.13"],"那就是说也是一个索引类型":["12.13"],"就递归处理":["12.13"],"否则":["12.13"],"值不是":["12.13"],"就直接返回之前的值":["12.13"],"可以看到":["13.0"],"我们类型参数":["13.0"],"为待处理数组":["13.1"],"递归提取每一个元素做":["13.1"],"要求传入":["13.1"],"这里要":["13.1"],"那么利用这个特点就可以实现":["13.2"],"union":["13.2"],"类型的判断":["13.2"],"分别是":["13.3"],"规范的三部分":["13.3"],"exclude":["13.4"],"才是分布式条件类型":["13.5"],"包含":["14.0"],"n":["14.0"],"个结点的二叉树的高度至少为":["14.0"],"log2n":["14.0"],"非空的二叉树":["14.0"],"分支度为":["14.0"],"的总数为":["14.0"],"除最后一层无任何子节点外":["14.1"],"每一层上的所有结点都有两个子结点的二叉树":["14.1"],"则左子树上所有结点的值均小于它的根结点的值":["14.3"],"若它的右子树不空":["14.3"],"树的变体":["14.6"],"即块的最低使用率为":["14.7"],"代替":["14.7"],"avl":["14.8"],"但对它进行平衡的代价较低":["14.8"],"的子结构":["14.18"],"ps":["14.18"],"entry":["15.0"],"input":["15.0","39.10","40.6"],"文件是否被改变":["16.3"],"boolean":["16.3","49.4"],"只有等到参数数组的所有":["18.0"],"对象都发生状态变更":["18.0"],"成员对象的":["18.1"],"status属性的值只可能是字符串":["18.1"],"fulfilled或字符串":["18.1"],"rejected":["18.1"],"params":["18.2"],"transformdata":["18.2"],"无":["18.3"],"api":["18.3"],"str":["19.2"],"br":["19.3"],"首页母小写":["19.3"],"问号后面的参数":["20.0"],"location":["20.1"],"search":["20.1"],"substr":["20.1"],"默认值":["20.3"],"日":["21.0","21.1","21.3"],"getmonth":["21.1"],"月":["21.1","21.3"],"getdate":["21.1"],"h":["21.1"],"gethours":["21.1"],"datetime":["21.2"],"年":["21.3"],"走访数列的工作是重复地进行直到没有再需要交换":["22.0"],"也就是说该数列已经排序完成":["22.0"],"针对所有的元素重复以上的步骤":["22.1"],"除了最后一个":["22.1"],"每个桶再分别排序":["23.0"],"从不是空的桶里把排好序的数据拼接起来":["23.1"],"description":["23.2","28.3"],"桶排序":["23.2"],"param":["23.2","28.3"],"bucket":["23.2"],"bucketsize":["23.2"],"很显然":["23.3"],"用分治法来解决排序问题最快也只能使算法的时间复杂度接近":["24.0"],"θ":["24.0"],"每一项和前一项相加":["24.1"],"反向填充目标数组":["24.1"],"将每个元素":["24.1"],"countlist":["24.3"],"空间复杂度也是":["24.4"],"堆积是一个近似完全二叉树的结构":["25.0"],"并同时满足堆积的性质":["25.0"],"可能违反堆的性质":["25.1"],"因此需要对当前无序区":["25.1"],"仍然在":["26.0"],"的前面":["26.0"],"不稳定":["26.0"],"所以用到它的时候":["27.0","31.4"],"数据规模越小越好":["27.0","31.4"],"重复步骤":["27.1"],"current":["27.3"],"while":["27.3"],"o":["27.4","28.4","32.0","35.4"],"将已有序的子序列合并":["28.0"],"得到完全有序的序列":["28.0"],"即先使每个子序列有序":["28.0"],"的子序列":["28.1"],"归并排序":["28.3"],"其中一部分记录的关键字均比另一部分的关键字小":["29.0"],"所有元素比基准值小的摆放在基准前面":["29.1"],"所有元素比基准值大的摆在基准的后面":["29.1"],"相同的数可以到任一边":["29.1"],"不断分区":["29.3"],"设置基准值":["29.3"],"combine":["29.3"],"有时候有些属性是有优先级顺序的":["30.0"],"先按低优先级排序":["30.0"],"再按高优先级排序":["30.0"],"数组":["30.1"],"对":["30.1"],"buckets":["30.3"],"当然":["30.4"],"要远远小于":["30.4"],"因此基本上还是线性级别的":["30.4"],"元素":["31.0"],"存放到排序序列的起始位置":["31.0"],"然后":["31.0"],"该趟排序从当前无序区中":["31.1"],"选出关键字最小的记录":["31.1"],"将它与无序区的第":["31.1"],"n2":["32.0"],"趟排序":["32.1"],"每趟排序":["32.1"],"根据对应的增量":["32.1"],"j":["32.3"],"版":["32.4"],"top":["33.1"],"ms":["33.2"],"nowrap":["33.3"],"overflow":["33.3"],"strsplit":["34.1"],"reg":["34.2"],"gi":["34.2"],"status":["34.3"],"var":["34.3"],"temp":["34.4"],"compare":["34.5"],"keycode":["34.6"],"and":["34.9"],"so":["34.9"],"on":["34.9"],"shorthand":["34.9"],"filtereddata":["34.11"],"object":["34.12","34.16"],"entries":["34.12"],"math":["34.13","34.21"],"max":["34.13"],"window":["34.14"],"charset":["34.15"],"utf":["34.15"],"link":["34.15"],"createelement":["34.15","40.14"],"replace":["34.18"],"stoppropagation":["34.19"],"floor":["34.21"],"facebook":["35.1"],"发布的一款取代":["35.1"],"因此安装速度更快":["35.2"],"在执行代码之前":["35.2"],"g":["35.3"],"yarn":["35.3"],"tag":["35.4"],"不指定依赖类型默认安装到dependencies里":["35.4"],"你也可以指定依赖类型":["35.4"],"加到":["35.4"],"devdependencies":["35.4"],"dev":["35.4"],"peerdependencies":["35.4"],"peer":["35.4"],"optionaldependencies":["35.4"],"optional":["35.4"],"默认安装包的主要版本里的最新版本":["35.4"],"下面两个命令可以指定版本":["35.4"],"安装包的精确版本":["35.4"],"例如yarn":["35.4"],"foo":["35.4"],"如果新的版本无法兼容你的项目":["35.5"],"你的程序可能就会出":["35.5"],"bug":["35.5"],"甚至无法运行":["35.5"],"这就是":["35.5"],"的弊端":["35.5"],"text":["36.3","36.4"],"文本按钮":["36.3","36.4"],"home":["36.6","40.15"],"主要按钮":["36.6"],"xml":["36.6","37.1","45.1","45.3","45.5","46.3","46.4"],"user":["37.3"],"start":["37.7"],"flow":["37.7"],"fallback":["38.1"],"flyzxf3zvmjeydciedjmyzzs5wipxnyzfbjaxmhqiqrgzhvwr7xcyocxsomidai1hmpmmqjdpbpeidcil358enhurw":["38.4"],"5snwdibbxidcia38":["38.4"],"pnzrce2yyz4":["38.4"],"59f3eplnml4pbpil2j0l979":["38.4"],"7ydthdhw8vtzzvdgnexdvuigsisclawavhp":["38.4"],"qm0bcxmd":["38.4"],"q25n1vf57tybp0a3muzilepj4":["38.4"],"7k5kslb6gt6ydahpuzxnopr0dhl79wgtncfbnn1uvscjdegqhli1vvck":["38.4"],"fpu2epxt2tzoyev6":["38.4"],"fn31dz":["38.4"],"组件库":["39.0"],"有声明和类型文件":["39.1"],"纯原生手写":["39.1"],"基础组件无依赖":["39.1"],"badgesize":["39.2"],"unpkg":["39.2"],"style":["39.3"],"也可以全局导入":["39.3"],"更加方便":["39.3"],"appendchild":["39.6"],"r":["39.7","43.3"],"button":["39.7","39.9"],"primary":["39.9"],"onclick":["39.9"],"choose":["39.9"],"to":["39.9"],"jsx":["39.9"],"typescript":["39.9"],"中定义了所有":["39.9"],"原生组件的类型":["39.9"],"200px":["39.10"],"label":["39.10","40.15"],"中文网":["39.12"],"ant":["39.12"],"design":["39.12"],"在线绘制":["39.12"],"这几种类型":["40.7"],"设置后会出现额外的":["40.7"],"warning":["40.12"],"ff7875":["40.12"],"setattribute":["40.15"],"这是一条提示":["41.1"],"点击触发全局提示":["41.1"],"success":["41.3"],"成功提示":["41.3"],"pdf":["43.0"],"将不会展示右上角的关闭按钮":["43.4"],"需要和":["45.0"],"设置":["45.4"],"line":["45.6"],"不使用":["46.6"],"但这种情况必须要设置":["46.6"],"的":["46.6"],"size":["46.6"],"否则无法判断":["46.6"],"的大小":["46.6"],"iconsize":["46.6"],"元组":["47.0"],"tuple":["47.0"],"接口":["47.0"],"personconstructor":["47.2"],"这种值也可以做为类型":["47.3"],"字符串的字面量类型有两种":["47.3"],"一种是普通的字符串字面量":["47.3"],"aaa":["47.3"],"另一种是模版字面量":["47.3"],"同理可得":["48.1","48.2"],"shiftarr":["48.1"],"的实现":["48.1"],"shift":["48.1"],"把":["48.2"],"作为类型参数递归":["48.2"],"trimleft":["48.2"],"是要匹配的函数类型":["48.4"],"和模式类型做匹配":["48.5"],"提取返回值到通过":["48.5"],"类型同样也可以通过模式匹配提取出来":["48.6"],"同样":["48.7"],"类型的实例对象":["48.8"],"这个也可以通过模式匹配取出来":["48.8"],"first":["49.2"],"注意":["49.4"],"同一类型可以合并":["49.4"],"maptypefixkey":["49.5"],"而":["50.3"],"record":["50.21"],"递归可以实现":["50.21"],"awaited":["50.21"]},{"0":["10.17","25.3","27.3","34.1","34.6"],"1":["4.19","9.19","14.7","22.1","34.9","34.18","35.4","49.1","49.3"],"2":["5.0","28.3","35.4"],"3":["8.0","10.3","35.4","45.7"],"4":["4.18","11.3","19.3","39.1","45.4"],"5":["9.7"],"6":["4.20"],"7":["4.20"],"8":["5.8"],"9":["35.4"],"10":["1.5","39.12"],"11":["39.12"],"1234":["40.6"],"分析":["1.1"],"的方式来修改和分析代码":["1.1"],"比如":["1.1","1.13"],"babel":["1.1","1.12"],"就通过这种方式进行代码的转换":["1.1"],"语句":["1.2"],"模块语法":["1.2"],"class":["1.2","9.11","9.30"],"等":["1.3"],"下面这些字面量都有对应的":["1.3"],"value":["1.4","1.13"],"function":["1.4","1.17","48.6"],"say":["1.4"],"true":["1.5","9.8","9.20","16.3","48.1"],"do":["1.5"],"switch":["1.5"],"v":["1.5"],"但有的表达式不能单独执行":["1.7"],"需要和其他类型的节点组合在一起构成语句":["1.7"],"比如匿名函数表达式和匿名":["1.7"],"表达式单独执行会报错":["1.7"],"eat":["1.8"],"对应的":["1.8"],"是这样的":["1.8"],"all":["1.9"],"strict":["1.10"],"这种指令会使用":["1.10"],"commentblock":["1.11"],"和":["1.11","8.5","9.26","11.8","13.3"],"commentline":["1.11"],"节点":["1.11"],"astexplorer":["1.12"],"如果想查看全部的":["1.12"],"可以在":["1.12"],"extra":["1.13"],"记录一些额外的信息":["1.13"],"用于处理一些特殊情况":["1.13"],"stringliteral":["1.13"],"的":["1.13","5.6","9.30"],"节点有不同的属性来存放对应的源码信息":["1.14"],"但是都有一些公共属性如":["1.14"],"type":["1.14","1.17","19.2","47.8"],"xxcomments":["1.14"],"整理出":["1.15"],"ast":["1.15"],"数据结构":["1.15"],"当下我们所要实现的词法分析器":["1.15"],"本质上是对代码字符串进行逐个字符的扫描":["1.15"],"然后根据一定的语法规则进行分组":["1.15"],"其中":["1.15","9.24","13.3","30.4"],"get":["1.17"],"使用方式":["1.17"],"new":["1.17","4.23","4.27","4.36","4.37","4.40","4.43","4.44","9.4","34.3","34.17"],"结果":["1.17"],"explorer":["1.18"],"网站进行在线预览":["1.18"],"接下来":["1.18"],"我们要做的就是将":["1.18"],"的时候可以使用":["2.0"],"来简化":["2.0"],"创建逻辑":["2.0"],"code":["2.0"],"frame":["2.0"],"可以创建友好的报错信息":["2.0"],"打包工具":["3.0"],"至少需要以下功能":["3.0"],"编译能力":["3.0"],"如果再增加一个维度":["4.0"],"根据品牌又能继续细分出":["4.0"],"联想台式电脑":["4.0"],"联想笔记本电脑":["4.0"],"苹果台式电脑":["4.0"],"苹果笔记本电脑":["4.0"],"等等":["4.0"],"如果再增加一个维度继续细分下去":["4.0"],"显然继承是无法胜任的":["4.0"],"这个时候可以使用继承加组合方式":["4.0"],"组合的对象也可以进行抽象化设计":["4.0"],"ts":["4.0","9.27","39.9"],"品牌":["4.0"],"interface":["4.0","10.16","39.9","47.0"],"brand":["4.0"],"本文中大部分是":["4.1"],"也有个别简易流程图":["4.1"],"则部分也不存在了":["4.4"],"例如":["4.4","4.5"],"部分仍然存在":["4.5"],"如果特别强调方向":["4.6"],"如下图":["4.6"],"表示":["4.6"],"a":["4.6","5.6","19.1","34.14"],"依赖关系也可能发生变化":["4.7"],"显然":["4.7"],"而将不同的实现行为移至具体的实现层中完成":["4.9"],"在很多面向对象编程语言中都提供了接口":["4.9"],"抽象类等机制":["4.9"],"可以通过它们定义系统的抽象层":["4.9"],"再通过具体类来进行扩展":["4.9"],"能够正常运行":["4.10"],"反过来的代换不成立":["4.10"],"如一个方法":["4.10"],"method2":["4.10"],"接受":["4.10"],"如果系统行为发生变化":["4.11"],"只需要对抽象层进行扩展":["4.11"],"并修改配置文件":["4.11"],"而无须修改原有系统的源代码":["4.11"],"在不修改的情况下来扩展系统的功能":["4.11"],"它是最简单但又最难运用的原则":["4.12"],"需要设计人员发现类的不同职责并将其分离":["4.12"],"而发现类的多重职责需要设计人员具有较强的分析设计能力和相关实践经验":["4.12"],"优点":["4.12","4.23","4.25","4.29","4.42"],"如果类与方法的职责划分得很清晰":["4.12"],"就越有利于复用":["4.13"],"一个处在松耦合中的类一旦被修改":["4.13"],"不会对关联的类造成太大波及":["4.13"],"在类的结构设计上":["4.13"],"每一个类都应当尽量降低其成员变量和成员函数的访问权限":["4.13"],"不利于维护":["4.14"],"接口也不能太大":["4.14"],"太大的接口将违背接口隔离原则":["4.14"],"降低类与类之间的耦合度":["4.15"],"一个类的变化对其他类造成的影响相对较少":["4.15"],"其次才考虑继承":["4.15"],"在使用继承时":["4.15"],"需要严格遵循里氏代换原则":["4.15"],"职责越多":["4.16"],"被复用的可能性就越小或使用起来越麻烦":["4.16"],"接口分离原则":["4.16"],"将功能复杂的接口细分成多个特定功能的接口":["4.16"],"其中创建型模式主要用于描述如何创建对象":["4.17"],"结构型模式主要用于描述如何实现类或对象的组合":["4.17"],"行为型模式主要用于描述类或对象怎样交互以及怎样分配职责":["4.17"],"此外":["4.17"],"单例模式":["4.18"],"singleton":["4.18"],"因此大部分结构型模式都是对象结构型模式":["4.19"],"外观模式":["4.19"],"适配器模式":["4.19"],"备忘录模式":["4.20"],"观察者模式":["4.20"],"null":["4.22","9.23"],"break":["4.22"],"生产可口可乐":["4.22"],"用户只需要关心其所需产品对应的具体工厂是哪一个即可":["4.23"],"pepsicolafactory":["4.24"],"可口可乐主题":["4.24"],"提供了对唯一实例的受控访问":["4.25"],"因为单例类封装了它的唯一实例":["4.25"],"所以它可以严格控制客户怎样以及何时访问它":["4.25"],"因为该类在系统内存中只存在一个对象":["4.25"],"所以可以节约系统资源":["4.25"],"将处理建造的流程交给指挥者":["4.26"],"constructorproduct":["4.26"],"使用":["4.26","5.8"],"const":["4.26","4.37","5.2"],"return":["4.27","4.29","15.0"],"name":["4.29"],"descriptor":["4.29"],"writable":["4.29","4.31"],"false":["4.29","4.42","9.8","9.20","48.1"],"比继承更加灵活":["4.29"],"attachevent":["4.30"],"on":["4.30","4.34"],"对":["4.31"],"context":["4.31","5.8"],"request":["4.31"],"做一个代理":["4.31"],"保护真正的":["4.31"],"this":["4.31"],"object":["4.31"],"create":["4.31"],"如果是免费则播放":["4.32"],"else":["4.32","34.19"],"如果是收费音乐":["4.32"],"则提示用户升级":["4.32"],"vip":["4.32"],"console":["4.32","4.40","34.2"],"log":["4.32","4.40","34.2","34.12"],"please":["4.32"],"upgrade":["4.32"],"to":["4.32"],"man":["4.33"],"人类":["4.33"],"可以运动和说话":["4.33"],"arguments":["4.36","4.45"],"order500new":["4.36"],"order200new":["4.36"],"ordercommonnew":["4.36"],"发布者发布请求":["4.37"],"warehouse":["4.37"],"仓库":["4.37"],"order":["4.37"],"订单":["4.37"],"client":["4.37"],"表达式":["4.38"],"依次执行":["4.38"],"它支持以不同的方式遍历一个聚合对象":["4.39"],"在同一个聚合对象上可以定义多种遍历方式":["4.39"],"在迭代器模式中只需要用一个不同的迭代器来替换原有迭代器即可改变遍历算法":["4.39"],"我们也可以自己定义迭代器的子类以支持新的遍历方式":["4.39"],"迭代器简化了聚合类":["4.39"],"由于引入了迭代器":["4.39"],"在原有的聚合对象中不需要再自行提供数据遍历等方法":["4.39"],"这样可以简化聚合类的设计":["4.39"],"在迭代器模式中":["4.39"],"由于引入了抽象层":["4.39"],"增加新的聚合类和迭代器类都很方便":["4.39"],"无须修改原有代码":["4.39"],"满足":["4.39"],"for":["4.40","21.1","25.3"],"let":["4.40","5.1"],"winner":["4.40"],"of":["4.40"],"挑戰成功":["4.40"],"loser":["4.40"],"挑战失败":["4.40"],"url":["4.41","34.15"],"data":["4.41","5.6","5.8","18.2"],"click":["4.42"],"观察者模式可以实现表示层和数据逻辑层的分离":["4.42"],"定义了稳定的消息更新传递机制":["4.42"],"并抽象了更新接口":["4.42"],"使得可以有各种各样不同的表示层充当具体观察者角色":["4.42"],"观察者模式在观察目标和观察者之间建立一个抽象的耦合":["4.42"],"观察目标只需要维持一个抽象观察者的集合":["4.42"],"t":["4.43","9.23","9.29","11.0","48.6"],"statest":["4.43"],"dir":["4.44"],"不同指令触发视图更新":["4.44"],"updaterfn":["4.44"],"updater":["4.44"],"getvmval":["4.44"],"watcher":["4.44"],"将父类的构造方法拿来执行一下":["4.45"],"apply":["4.45"],"就像es6的super执行":["4.45"],"执行后this才会有对象的属性":["4.45"],"pop":["4.46"],"还有一些地方没有完全理解":["4.47"],"csdn":["4.48"],"net":["4.48"],"lovelion":["4.48"],"article":["4.48"],"details":["4.48"],"num2":["5.0"],"sum":["5.0"],"把函数赋值给变量":["5.1"],"fn":["5.1"],"第一种调用方式":["5.2"],"第二种调用方式":["5.2"],"once只能执行一次的函数":["5.2"],"once":["5.2"],"可以共享":["5.3"],"堆":["5.3"],"动态分配内存":["5.3"],"大小不定":["5.3"],"也不会自动释放内存":["5.3"],"带来副作用":["5.4"],"副作用来源":["5.4"],"配置文件":["5.4"],"数据库":["5.4"],"获取用户的输入等等":["5.4"],"所有的外部交互都可能带来副作用":["5.4"],"副作用使得方法通用性下降":["5.4"],"不适合扩展和重用":["5.4"],"同时给程序带来安全隐患":["5.4"],"副作用不可能完全禁止":["5.4"],"只能尽可能的在控制范围内":["5.4"],"实现一个":["5.5"],"函数":["5.5"],"模块提供了实用的对函数式编程友好的方法":["5.6"],"提供了不可变的auto":["5.6"],"curried":["5.6"],"iteratee":["5.6"],"last的方法":["5.6"],"lodash方法":["5.6"],"require":["5.6"],"map":["5.6","19.1","30.3"],"join":["5.7"],"utf":["5.8"],"reject":["5.8"],"err":["5.8"],"resolve":["5.8"],"会返回一个task函子":["5.8"],"package":["5.8"],"run":["5.8","9.7"],"listen":["5.8"],"监听事件的状态":["5.8"],"onrejected":["5.8"],"onresolved":["5.8"],"可以在run之前调用map":["5.8"],"去处理返回的结果":["5.8"],"n":["5.8","34.3"],"includes":["5.8","34.8"],"version":["5.8"],"pointed":["5.8"],"函子是实现的静态方法":["5.8"],"是为了避免使用":["5.8"],"来创建对象":["5.8"],"更深层的含义是":["5.8"],"方法用来把值放到上下文":["5.8"],"把值放到容器中":["5.8"],"来处理值":["5.8"],"monad":["5.8"],"函子是为来解决":["5.8"],"函子嵌套的问题":["5.8"],"但是诸如图像":["7.4"],"样式表和框架之类的子资源仍在加载":["7.4"],"complete":["7.4"],"完成":["7.4"],"而数组类型我们是能构造出来的":["8.0"],"那么通过构造不同长度的数组然后取":["8.0"],"就返回构造出的":["8.2"],"否则继续递归构造":["8.2"],"构造数组实现了":["8.2"],"那么基于它就能实现加法":["8.2"],"num1":["8.2"],"分别是被减数和减数":["8.3","8.5"],"通过":["8.3"],"约束为":["8.3","13.3"],"构造":["8.3"],"来保存中间结果":["8.4"],"默认值是":["8.4","8.9"],"相当于从":["8.4"],"开始加":["8.4"],"每加一次就把":["8.4"],"减一":["8.4"],"直到":["8.4"],"类型参数":["8.5","9.28","11.5","12.4","12.9","12.10","13.2","13.4"],"是用来记录减了几次的累加数组":["8.5"],"如果":["8.5"],"是待处理的字符串":["8.7"],"是做计数的数组":["8.7"],"默认值":["8.7"],"成立":["8.8"],"代表相等":["8.8"],"直接返回":["8.8"],"否则判断计数数组的长度":["8.8"],"那么就是":["8.8"],"是代表之前的累加值的数组":["8.9"],"是代表当前数值的数组":["8.9"],"用于记录":["8.9"],"index":["8.9","39.2"],"每次递归加一":["8.9"],"代表从":["8.9"],"开始":["8.9"],"就会有很多这种报错":["9.1"],"所以":["9.1"],"动态类型虽然代码写起来简单":["9.1"],"但代码中很容易藏着一些类型不匹配的隐患":["9.1"],"静态类型检查则是在源码中保留类型信息":["9.1"],"声明变量要指定类型":["9.1"],"对变量做的操作要和类型匹配":["9.1"],"会有专门的编译器在编译期间做检查":["9.1"],"静态类型给写代码增加了一些难度":["9.1"],"因为你除了要考虑代码要表达的逻辑之外":["9.1"],"还要考虑类型逻辑":["9.1"],"变量是什么类型的":["9.1"],"是不是匹配":["9.1"],"要不要做类型转换等":["9.1"],"不过":["9.1"],"里":["9.4","10.16"],"对象都是由类":["9.4"],"出来的":["9.4"],"你不能凭空创建对象":["9.4"],"却可以":["9.4"],"它支持对象字面量":["9.4"],"那如果是一个返回对象某个属性值的函数":["9.4"],"mergeparams":["9.5"],"oneparam":["9.5"],"record":["9.5"],"any":["9.5","9.26"],"otherparam":["9.5"],"也就是":["9.6","11.13","12.5","12.6","48.5"],"型变":["9.6"],"variant":["9.6"],"类型改变":["9.6"],"这种":["9.6"],"tony":["9.7"],"x":["9.8"],"之前支持这种赋值":["9.8"],"也就是父类型可以赋值给子类型":["9.8"],"子类型可以赋值给父类型":["9.8"],"既逆变又协变":["9.8"],"叫做":["9.8"],"双向协变":["9.8"],"但是这明显是有问题的":["9.8"],"不能保证类型安全":["9.8"],"所以之后":["9.8"],"加了一个编译选项":["9.8"],"strictfunctiontypes":["9.8"],"设置为":["9.8"],"就只支持函数参数的逆变":["9.8"],"则是双向协变":["9.8"],"我们把":["9.8"],"是":["9.9","20.3"],"注意":["9.9","9.18","10.12","49.2"],"这里用的是更具体":["9.9"],"而不是更多":["9.9"],"判断联合类型父子关系的时候":["9.9"],"的基础类型就行":["9.11"],"复合类型方面":["9.11"],"有":["9.11"],"number":["9.12","9.15","9.27","11.14","47.1","47.8"],"对象类型":["9.13","47.2"],"类型在":["9.13","47.2"],"typescript":["9.13","13.1","47.2"],"里也叫做索引类型":["9.13"],"也就是索引了多个元素的类型的意思":["9.13"],"对象可以动态添加属性":["9.13"],"如果不知道会有什么属性":["9.13"],"可以用可索引签名":["9.13"],"代表空":["9.14"],"可以是":["9.14"],"undefined":["9.14","39.9"],"或":["9.14"],"是任意类型":["9.14"],"任何类型都可以赋值给它":["9.14"],"它也可以赋值给任何类型":["9.14"],"除了":["9.14"],"是未知类型":["9.14"],"age":["9.15","47.8"],"那么可以对这些类型做什么类型运算呢":["9.16"],"第一个":["9.18","49.2"],"不是条件":["9.18","49.2"],"条件类型是":["9.18"],"extends":["9.20","48.6","48.8"],"string":["9.21","39.9","47.3","48.1"],"aaa":["9.21","34.5","49.5"],"bbb":["9.21","34.5","49.5"],"这样就能正常判断了":["9.24"],"除此以外":["9.26"],"如果类型参数为":["9.26"],"会直接返回":["9.26"],"truetype":["9.26"],"falsetype":["9.26"],"的合并":["9.26"],"infer":["9.28","10.6"],"r":["9.28","43.4"],"是要转换的联合类型":["9.28"],"k":["9.29","21.1","30.4"],"p":["9.29","48.1"],"反过来也可以过滤非可选索引":["9.30"],"索引类型的索引为字符串字面量类型":["9.30"],"而可索引签名不是":["9.30"],"可以用这个特性过滤掉可索引签名":["9.30"],"keyof":["9.30","11.15"],"只能拿到":["9.30"],"public":["9.30"],"来保存":["10.0","48.0"],"如果匹配":["10.0","48.0"],"就返回匹配到的":["10.0","48.0"],"否则就返回":["10.0"],"代表没匹配到":["10.0"],"getvalueresult":["10.0"],"当类型参数":["10.2"],"为":["10.2"],"时":["10.2","10.3","10.5"],"getlastresult":["10.3"],"popresult":["10.4"],"shiftresult":["10.5"],"startwithresult":["10.7"],"startwidth":["10.7","48.1"],"当匹配时":["10.8"],"replaceresult":["10.8"],"result":["10.8"],"aaaa":["10.8"],"同理可得":["10.9"],"trimleft":["10.9"],"返回提取到的参数类型":["10.11"],"getparametersresult":["10.11"],"这里不能用":["10.12"],"这里的解释涉及到参数的逆变性质":["10.12"],"具体原因逆变那一节会解释":["10.12"],"当":["10.13"],"就能检查出":["10.13"],"指向的对象是否是对的":["10.13"],"如果没有报错":["10.13"],"说明没开启":["10.13"],"strictbindcallapply":["10.13"],"的编译选项":["10.13"],"这个是控制是否按照原函数的类型来检查":["10.13"],"bind":["10.13"],"这里的":["10.13"],"类型同样也可以通过模式匹配提取出来":["10.13"],"同样":["10.14"],"约束为构造器类型":["10.15"],"用":["10.15","12.11"],"匹配一个模式类型":["10.15"],"提取返回的实例类型到":["10.15"],"声明的局部变量":["10.15","11.8","11.9","11.11","12.5","12.11"],"返回":["10.16"],"这样就能提取出构造器对应的参数类型":["10.16"],"personconstructor":["10.16"],"上面注释里写了":["10.17"],"在":["10.17"],"ts3":["10.17"],"里面如果没有对应的索引":["10.17"],"obj":["10.17"],"key":["10.17","11.15"],"返回的是":["10.17"],"而不是":["10.17"],"所以这样做下兼容处理":["10.17"],"如果有":["10.17"],"这个索引的话":["10.17"],"就通过":["10.17"],"在类型运算中也相当于局部变量":["11.0"],"istwo":["11.0"],"索引类型":["11.1"],"也就是多个元素的聚合类型的重新构造复杂一些":["11.1"],"ele":["11.4"],"otherrest":["11.5"],"声明为":["11.5"],"也就是元素个数任意":["11.5"],"类型任意的数组":["11.5"],"每次提取":["11.5"],"的第一个元素":["11.5"],"提取出首个字符到局部变量":["11.7"],"提取后面的字符到局部变量":["11.7"],"然后使用":["11.7"],"之前和之后的两个字符到":["11.8"],"剩下的字符放到":["11.8"],"之前和之后的字符串到":["11.9"],"中":["11.9","11.11","12.2","12.5"],"如果不匹配就直接返回":["11.9"],"提取返回值到局部变量":["11.11"],"对它的修改和构造新类型涉及到了映射类型的语法":["11.12"],"mapping":["11.12"],"的索引":["11.13"],"作为新的索引类型的索引":["11.13"],"把索引":["11.14"],"转为大写":["11.14"],"因为索引可能为":["11.14"],"symbol":["11.14"],"as":["11.15"],"的修饰":["11.16"],"其余的保持不变":["11.16"],"索引依然为原来的索引":["11.16"],"给索引类型":["11.17","11.18","11.19"],"但要做一些变换":["11.20"],"之后的部分":["11.20"],"如果原来索引的值":["11.20"],"可以只处理一个类型":["12.0"],"然后递归的调用自身处理下一个类型":["12.0"],"直到结束条件也就是所有的类型都处理完了":["12.0"],"然后判断如果":["12.2"],"依然是":["12.2"],"就递归处理":["12.2"],"结束条件就是":["12.2"],"不为":["12.2"],"那就处理完了所有的层数":["12.2"],"first":["12.4","12.10"],"rest":["12.4","12.10"],"待查找的元素类型":["12.5"],"每次提取一个元素到":["12.5"],"剩余的放到局部变量":["12.5"],"判断":["12.5"],"是待处理的数组":["12.6"],"元素类型任意":["12.6"],"为待查找的元素类型":["12.6"],"为元素类型":["12.7"],"默认值为":["12.7","13.2"],"为构造出的数组":["12.7"],"是待处理的字符串类型":["12.9"],"是待替换的字符":["12.9"],"其余字符放到":["12.11"],"这样就完成了任意层数的索引类型的添加":["12.13"],"修饰":["12.13"],"我们取处理以后的索引":["12.13"],"的值看一下":["12.13"],"发现":["12.13"],"已经加上了":["12.13"],"测试一下":["12.13"],"为啥这里没有计算呀":["12.13"],"因为":["12.13"],"的类型只有被用到的时候才会做计算":["12.13"],"所以可以在前面加上一段":["12.13"],"条件类型的判断中也是判断是否是":["13.0"],"但传入的是联合类型":["13.0"],"这就是":["13.0"],"对联合类型在条件类型中使用时的特殊处理":["13.0"],"会把联合类型的每一个元素单独传入做类型计算":["13.0"],"来变成":["13.1"],"类型":["13.1"],"那如果是联合类型呢":["13.1"],"联合类型不需要递归提取每个元素":["13.1"],"内部会把每一个元素传入单独做计算":["13.1"],"之后把每个元素的计算结果合并成联合类型":["13.1"],"是待判断的联合类型":["13.2"],"也就是同一个类型":["13.2"],"这段看似没啥意义":["13.2"],"主要是为了触发分布式条件类型":["13.2"],"让":["13.2"],"的每个类型单独传入":["13.2"],"这样不直接写":["13.2"],"都可能多个":["13.3"],"构造一个字符串类型":["13.3"],"通过索引访问来变为联合类型":["13.3"],"字符串类型中遇到联合类型的时候":["13.3"],"会每个元素单独传入计算":["13.3"],"是待组合的两个联合类型":["13.4"],"默认是":["13.4"],"也就是同一个":["13.4"],"的意义就是让联合类型每个类型单独传入做处理":["13.4"],"上面我们刚学会":["13.4"],"的处理就是":["13.4"],"就不是了":["13.5"],"n0":["14.0"],"n2":["14.0"],"则":["14.0"],"二叉树的总结点数":["14.0"],"sup":["14.1"],"的结点与满二叉树中编号为":["14.2"],"则右子树上所有结点的值均大于它的根结点的值":["14.3"],"也是一种多路搜索树":["14.6"],"树的":["14.7"],"其平均统计性能要强于":["14.8"],"约定空树不是任意一个树的子结构":["14.18"],"参考文档":["14.18"],"文件改变":["16.3"],"interval":["16.4"],"监听文件改变的时间":["16.4"],"不管是":["18.0"],"fulfilled":["18.0","18.1"],"还是":["18.0"],"用来区分异步操作是成功还是失败":["18.1"],"如果是成功":["18.1"],"对象会有":["18.1"],"value属性":["18.1"],"如果是失败":["18.1"],"会有":["18.1"],"reason属性":["18.1"],"对应两种状态时前面异步操作的返回值":["18.1"],"if":["18.1","19.1","20.1"],"接口方法":["18.3"],"split":["19.1"],"z":["19.1"],"test":["19.1"],"大小写转换":["19.3"],"match":["20.1"],"要截取的参数名":["20.3"],"getminutes":["21.1"],"分":["21.1"],"s":["21.1","48.1"],"getseconds":["21.1"],"秒":["21.1"],"in":["21.1"],"fmt":["21.2"],"这个算法的名字由来是因为越小的元素会经由交换慢慢":["22.0"],"重复步骤":["22.1"],"相邻元素两两对比":["22.3"],"temp":["22.3"],"有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排":["23.0"],"bucketcount":["23.2"],"math":["23.2","25.3"],"floor":["23.2","25.3"],"桶划分的越小":["23.3"],"各个桶之间的数据越少":["23.3"],"nlogn":["24.0","28.4"],"即基于比较的时间复杂度存在下界":["24.0"],"ω":["24.0"],"放在新数组的第":["24.1"],"其排序速度快于任何比较排序算法":["24.4"],"即子结点的键值或索引总是小于":["25.0"],"调整为新堆":["25.1"],"然后再次将":["25.1"],"与无序区最后一个元素交换":["25.1"],"得到新的无序区":["25.1"],"优点是不占用额外的内存空间":["27.0"],"工作原理是通过构建有序序列":["27.0"],"直到找到已排序的元素小于或者等于新元素的位置":["27.1"],"将新元素插入到该位置后":["27.1"],"的额外空间的排序":["27.4"],"因而在从后向前扫描过程中":["27.4"],"再使子序列段间有序":["28.0"],"若将两个有序表合并成一个有序表":["28.0"],"对这两个子序列分别采用归并排序":["28.1"],"merge":["28.3"],"的时间复杂度":["28.4"],"则可分别对这两部分记录继续进行排序":["29.0"],"在这个分区退出之后":["29.1"],"该基准就处于数列的中间位置":["29.1"],"这个称为分区":["29.1"],"partitionindex":["29.3"],"最后的次序就是高优先级高的在前":["30.0"],"高优先级相同的低优先级高的在前":["30.0"],"fill":["30.3"],"j":["30.3"],"基数排序的空间复杂度为":["30.4"],"再从剩余未排序元素中继续寻找最小":["31.0"],"个记录":["31.1"],"交换":["31.1"],"使":["31.1"],"寻找最小的数":["31.3"],"将最小数的索引保存":["31.3"],"唯一的好处可能就是不占用额外的内存空间了吧":["31.4"],"的排序算法":["32.0"],"是简单插入排序的改进版":["32.0"],"将待排序列分割成若干长度为":["32.1"],"m":["32.1"],"的子序列":["32.1"],"current":["32.3"],"while":["32.3"],"的合著者":["32.4"],"robert":["32.4"],"transform":["33.1"],"khtml":["33.2"],"hidden":["33.3"],"text":["33.3","39.6"],"substring":["34.1"],"方法二":["34.4"],"通过解构赋值交换变量的值":["34.4"],"b":["34.5","45.4"],"onselectstart":["34.7"],"var":["34.9"],"output":["34.12"],"createobjecturl":["34.14","34.15"],"response":["34.14"],"document":["34.14"],"createelement":["34.14"],"style":["34.15"],"display":["34.15"],"none":["34.15"],"href":["34.15"],"prototype":["34.16"],"tostring":["34.16"],"w":["34.18"],"scrollleft":["34.20"],"documentelement":["34.20"],"random":["34.21"],"npm":["35.1"],"会通过算法校验每个安装包的完整性":["35.2"],"使用详细":["35.2"],"查看版本":["35.3"],"3会接受1":["35.4"],"1版":["35.4"],"但是yarn":["35.4"],"exact只会接受1":["35.4"],"3版":["35.4"],"exact":["35.4"],"e":["35.4","40.15"],"安装包的次要版本里的最新版":["35.4"],"tilde会接受1":["35.4"],"而":["35.5"],"为了解决这个问题推出了":["35.5"],"lock":["35.5"],"的机制":["35.5"],"这是作者项目中的":["35.5"],"默认按钮":["36.3","36.4"],"xml":["36.3","36.4","40.1","41.1"],"primary":["36.5"],"home":["36.5","40.14"],"主要按钮":["36.5"],"row":["37.7"],"wrap":["37.7"],"shwar1sp1cqvlntben9mxa9xcyjsxs1jwr4aia2ibzx0tc44fyx":["38.4"],"16lv6ndflxh":["38.4"],"yl32jwiacrbiebf5kcxotisqspzxx4n28ja4bqok7rgxiydbhjx":["38.4"],"p25taqajegaguwy0":["38.4"],"2q8pd6":["38.4"],"ki4r8evl":["38.4"],"bzbonzy95fq9rj9zakti2sxdidbhqg9":["38.4"],"skdw43borcxo":["38.4"],"zcjdrapwdv22uieila4q7nvvcug8wtqzqveoh26fodo7g6ufe":["38.4"],"a17w3":["38.4"],"nfbakryenrdb1vkkz1ch9cpsvy":["38.4"],"mit":["39.1"],"协议":["39.1"],"dist":["39.2"],"umd":["39.2"],"cjs":["39.2"],"label":["39.2","40.14"],"brotli":["39.2"],"compression":["39.2"],"这样什么都不用考虑了":["39.3"],"梭哈完事":["39.3"],"es":["39.3"],"module":["39.3"],"jsx":["39.4"],"component":["39.9"],"类型不在":["39.9"],"定义中":["39.9"],"需要手动添加":["39.9"],"否则会有类型问题":["39.9"],"但它实际上是有效的":["39.9"],"typings":["39.9"],"d":["39.9"],"rbutton":["39.9"],"mouseeventhandler":["39.9"],"password":["39.10"],"message":["39.10"],"onclick":["39.10"],"info":["39.10"],"这是一条提示":["39.10"],"信息提示":["39.10"],"警告提示":["39.10"],"动画":["39.12"],"tailwindcss":["39.12"],"组件库":["39.12"],"animate":["39.12"],"w3c":["39.13"],"ui":["40.7"],"html":["40.10","41.3"],"提交时收集的字段名字":["40.11"],"setattribute":["40.14"],"func":["40.15"],"toast":["41.3"],"toast提示":["41.3"],"xlsx":["43.0"],"preview":["43.3","43.4"],"200px":["44.1"],"tabs":["45.0"],"tab4":["45.4"],"end":["45.7"],"枚举":["47.0"],"enum":["47.0"],"它的意思是以":["47.3"],"开头":["47.3"],"后面是任意":["47.3"],"声明一个局部变量":["48.0"],"字符串类型也同样可以做模式匹配":["48.1"],"匹配一个模式字符串":["48.1"],"把需要提取的部分放到":["48.1"],"声明的局部变量里":["48.1"],"判断字符串是否以某个前缀开头":["48.1"],"也是通过模式匹配":["48.1"],"需要声明字符串":["48.1"],"str":["48.1"],"匹配的前缀":["48.1"],"prefix":["48.1"],"两个类型参数":["48.1"],"它们都是":["48.1"],"和模式类型做匹配":["48.4"],"参数类型放到用":["48.4"],"returntype":["48.5"],"里返回":["48.5"],"参数类型可以是任意类型":["48.5"],"我们也可以通过模式匹配提取构造器的参数和返回值的类型":["48.7"],"c":["48.8"],"args":["48.8"],"unknown":["48.8"],"res2":["49.1"],"不同的类型没法合并":["49.4"],"会被舍弃":["49.4"],"用联合类型在分布式条件类型的特性可以实现":["50.21"],"exclude":["50.21"],"此外还有":["50.21"]},{"0":["8.7","35.4"],"1":["1.5","1.15","4.33","10.17","14.18","34.21"],"2":["4.33","4.46","9.19","11.0","14.1","27.1","28.0","34.9","49.3"],"3":["4.46","9.19","11.5","22.1","34.9","47.0","49.3"],"4":["1.17","4.19","4.46","11.5"],"5":["1.17","4.18","4.19","4.46","19.3","39.1"],"6":["1.11","1.17"],"7":["1.17"],"8":["1.17","4.20"],"9":["4.20"],"10":["4.20"],"12":["39.12"],"16":["1.17"],"18":["5.4"],"23":["4.1"],"17517213":["4.48"],"rollup":["1.1"],"的":["1.1","1.9","9.1","12.2"],"shaking":["1.1"],"就是通过分析":["1.1"],"语法都有各自的":["1.2"],"节点":["1.3"],"代码中的字面量很多":["1.3"],"babel":["1.3"],"就是通过":["1.3"],"console":["1.4","1.5","4.38","5.1","34.5","34.10","34.11"],"log":["1.4","1.5","4.38","5.1","34.10","34.11"],"obj":["1.4","9.4"],"case":["1.5"],"default":["1.5"],"label":["1.5"],"with":["1.5"],"a":["1.5","4.46","9.8","13.3"],"它们对应的":["1.6"],"ast":["1.6"],"需要和其他部分一起构成一条语句":["1.7"],"比如组成赋值语句":["1.7"],"这条赋值语句对应的":["1.7"],"是":["1.8","11.20"],"es":["1.8"],"next":["1.8"],"的语法":["1.8"],"exportnameddeclaration":["1.9"],"exportdefaultdeclaration":["1.9"],"exportalldeclaration":["1.9"],"比如这三种":["1.9"],"节点表示":["1.10"],"是包裹具体执行语句的节点":["1.10"],"而":["1.10","13.2","13.4"],"上面":["1.11"],"种就是常见的一些":["1.11"],"仓库里的":["1.12"],"文档里查":["1.12"],"或者直接去看":["1.12"],"只是值的修改":["1.13"],"而修改":["1.13"],"raw":["1.13"],"则可以连同单双引号一起修改":["1.13"],"比如这段代码的":["1.13"],"修改":["1.13"],"loc":["1.14"],"等":["1.14","9.14","9.21","12.13","21.3","49.5"],"学会了":["1.14"],"就可以把对代码的操作转为对":["1.14"],"涉及到几个关键的步骤":["1.15"],"确定语法规则":["1.15"],"包括语言内置的关键词":["1.15"],"单字符":["1.15"],"分隔符等":["1.15"],"length":["1.16","5.5","34.1"],"singlechartokens":["1.16"],"单字符到":["1.16"],"生成器的映射":["1.16"],"known":["1.16"],"single":["1.16"],"char":["1.16"],"new":["1.16","4.26","4.46"],"map":["1.16","5.7","23.2"],"typeof":["1.16"],"keyof":["1.16"],"value":["1.17","4.44","10.12"],"start":["1.17"],"end":["1.17"],"assign":["1.17"],"leftparen":["1.17"],"数组转换为上图所示的":["1.18"],"数据":["1.18"],"generator":["2.0"],"打印":["2.0"],"成目标代码字符串":["2.0"],"支持":["2.0"],"comments":["2.0"],"minified":["2.0"],"sourcemaps":["2.0"],"等选项":["2.0"],"插件机制":["3.0"],"hmr":["3.0"],"lenovo":["4.0"],"extends":["4.0","9.23","10.13","11.12"],"apple":["4.0"],"cpu":["4.0"],"inter":["4.0"],"由于文中部分模式并未配图":["4.1"],"你可以在这里查看我在网络上收集的完整":["4.1"],"种设计模式":["4.1"],"公司不存在了":["4.4"],"部门也将不存在了":["4.4"],"部门撤销了":["4.5"],"人员不会消失":["4.5"],"知道":["4.6"],"b":["4.6","5.6","13.3","14.0"],"但":["4.6"],"依赖也有方向":["4.7"],"双向依赖是一种非常糟糕的结构":["4.7"],"我们总是应该保持单向依赖":["4.7"],"如果需要修改系统的行为":["4.9"],"无须对抽象层进行任何改动":["4.9"],"只需要增加新的具体类来实现新的业务功能即可":["4.9"],"实现在不修改已有代码的基础上扩展系统的功能":["4.9"],"达到开闭原则的要求":["4.9"],"为参数":["4.10"],"那么一般而言不可以有":["4.10"],"除非是重载方法":["4.10"],"里氏代换原则是实现开闭原则的重要方式之一":["4.10"],"满足开闭原则的要求":["4.11"],"优点":["4.11","4.14","4.15","4.22","4.26","4.27","4.30","4.31","4.32","4.34","4.36","4.37","4.38","4.41","4.43","4.44"],"通过抽象来搭建框架":["4.11"],"建立类和类的关联":["4.11"],"以减少类间的耦合性":["4.11"],"不但可以提高代码的可读性":["4.12"],"更实际性地更降低了程序出错的风险":["4.12"],"因为清晰的代码会让":["4.12"],"bug":["4.12"],"无处藏身":["4.12"],"在类的设计上":["4.13"],"只要有可能":["4.13"],"一个类型应当设计成不变类":["4.13"],"在对其他类的引用上":["4.13"],"一个对象对其他对象的引用应当降到最低":["4.13"],"灵活性较差":["4.14"],"使用起来很不方便":["4.14"],"避免同一个接口里面包含不同类职责的方法":["4.14"],"有效使用继承会有助于对问题的理解":["4.15"],"降低复杂度":["4.15"],"而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度":["4.15"],"因此需要慎重使用继承复用":["4.15"],"只做该做的事情":["4.16"],"降低耦合":["4.16"],"但是细化粒度不能太细":["4.16"],"容易导致接口过多":["4.16"],"根据某个模式主要是用于处理类之间的关系还是对象之间的关系":["4.17"],"设计模式还可以分为类模式和对象模式":["4.17"],"我们经常将两种分类方式结合使用":["4.17"],"生成器模式":["4.18"],"builder":["4.18"],"桥接模式":["4.19"],"代理模式":["4.19"],"状态模式":["4.20"],"策略模式":["4.20"],"生产百事可乐":["4.22"],"使用者只需要给工厂类传入一个正确的约定好的参数":["4.22"],"就可以获取你所需要的对象":["4.22"],"而不需要知道其创建细节":["4.22"],"一定程度上减少系统的耦合":["4.22"],"不需要关心产品的创建细节":["4.23"],"也不需要知道具体产品类的类名":["4.23"],"当系统中加入新产品时":["4.23"],"不需要修改抽象工厂和抽象产品提供的接口":["4.23"],"也无须修改客户端和其他的具体工厂和具体产品":["4.23"],"而只要添加一个具体工厂和与其对应的具体产品就可以了":["4.23"],"符合了开闭原则":["4.23"],"百事可乐主题":["4.24"],"缺点":["4.25","4.39"],"由于单例模式中没有抽象层":["4.25"],"因此单例类很难进行扩展":["4.25"],"对于有垃圾回收系统的语言":["4.25"],"java":["4.25"],"c":["4.25","5.6","9.9","13.3"],"客户端不必知道产品内部组成的细节":["4.26"],"将产品本身与产品的创建过程解耦":["4.26"],"使得相同的创建过程可以创建不同的产品对象":["4.26"],"每一个具体建造者都相对独立":["4.26"],"而与其他的具体建造者无关":["4.26"],"福特escort":["4.27"],"可以利用原型模式简化对象的创建过程":["4.27"],"尤其是对一些创建过程繁琐":["4.27"],"包含对象层级比较多的对象来说":["4.27"],"使用原型模式可以节约系统资源":["4.27"],"不同于在编译期起作用的继承":["4.29"],"装饰者模式可以在运行时扩展一个对象的功能":["4.29"],"另外也可以通过配置文件在运行时选择不同的装饰器":["4.29"],"从而实现不同的行为":["4.29"],"也可以通过不同的组合":["4.29"],"可以实现不同效果":["4.29"],"符合":["4.29"],"开闭原则":["4.29","4.39","4.42","4.44"],"实现了客户端与子系统间的解耦":["4.30"],"客户端无需知道子系统的接口":["4.30"],"简化了客户端调用子系统的调用过程":["4.30"],"使得子系统使用起来更加容易":["4.30"],"同时便于子系统的扩展和维护":["4.30"],"符合迪米特法则":["4.30"],"降低系统的耦合度":["4.31","4.37"],"代理模式能够协调调用者和被调用者":["4.31"],"在一定程度上降低了系":["4.31"],"vipmusicservice":["4.32"],"可以听全部的音乐":["4.32"],"listenmusic":["4.32"],"可以下载音乐":["4.32"],"使用享元模可以减少内存中对象的数量":["4.32"],"const":["4.33","9.8","9.30"],"符合开闭原则":["4.34"],"使用适配器而不需要改变现有类":["4.34"],"普通购买":["4.36"],"无优惠券":["4.36"],"职责链模式使得一个对象无须知道是其他哪一个对象处理其请求":["4.36"],"对象仅需知道该请求会被处理即可":["4.36"],"接收者和发送者都没有对方的明确信息":["4.36"],"且链中的对象不需要知道链的结构":["4.36"],"由客户端负责链的创建":["4.36"],"降低了系统的耦合度":["4.36"],"请求处理对象仅需维持一个指向其后继者的引用":["4.36"],"客户":["4.37"],"由于请求者与接收者之间不存在直接引用":["4.37"],"因此请求者与接收者之间实现完全解耦":["4.37"],"相同的请求者可以对应不同的接收者":["4.37"],"同样":["4.37"],"相同的接收者也可以供不同的请求者使用":["4.37"],"两者之间具有良好的独立性":["4.37"],"新的命令可以很容易地加入到系统中":["4.37"],"由于增加新的具体命令类不会影响到其他类":["4.37"],"因此增加新的具体命令类很容易":["4.37"],"无须修改原有系统源代码":["4.37"],"foreach":["4.38"],"易于改变和扩展文法":["4.38"],"由于在解释器模式中使用类来表示语言的文法规则":["4.38"],"因此可以通过继承等机制来改变或扩展文法":["4.38"],"每一条文法规则都可以表示为一个类":["4.38"],"因此可以方便地实现一个简单的语言":["4.38"],"实现文法较为容易":["4.38"],"在抽象语法树中每一个表达式节点类的实现方式都是相似的":["4.38"],"这些类的代码编写都不会特别复杂":["4.38"],"的要求":["4.39","4.42"],"由于迭代器模式将存储数据和遍历数据的职责分离":["4.39"],"增加新的聚合类需要对应增加新的迭代器类":["4.39"],"类的个数成对增加":["4.39"],"这在一定程度上增加了系统的复杂性":["4.39"],"抽象迭代器的设计难度较大":["4.39"],"需要充分考虑到系统将来的扩展":["4.39"],"例如":["4.39"],"jdk":["4.39"],"内置迭代器":["4.39"],"a选手":["4.40"],"b选手":["4.40"],"c选手":["4.40"],"选手挑战成功":["4.40"],"选手挑战失败":["4.40"],"它提供了一种状态恢复的实现机制":["4.41"],"备忘录实现了对信息的封装":["4.41"],"一个备忘录对象是一种原发器对象状态的表示":["4.41"],"不会被其他代码所改动":["4.41"],"无须了解其具体观察者":["4.42"],"由于观察目标和观察者没有紧密地耦合在一起":["4.42"],"因此它们可以属于不同的抽象化层次":["4.42"],"观察者模式支持广播通信":["4.42"],"观察目标会向所有已注册的观察者对象发送通知":["4.42"],"简化了一对多系统设计的难度":["4.42"],"观察者模式满足":["4.42"],"增加新的具体观察者无须修改原有系统代码":["4.42"],"在具体观察者与观察目标之间不存在关联关系的情况下":["4.42"],"封装了状态的转换规则":["4.43"],"在状态模式中可以将状态的转换代码封装在环境类或者具体状态类中":["4.43"],"可以对状态转换代码进行集中管理":["4.43"],"而不是分散在一个个业务方法中":["4.43"],"将所有与某个状态有关的行为放到一个类中":["4.43"],"只需要注入一个不同的状态对象即可使环境对象拥有不同的行为":["4.43"],"允许状态转换逻辑与状态对象合成一体":["4.43"],"oldvalue":["4.44"],"策略模式提供了对":["4.44"],"的完美支持":["4.44"],"用户可以在不修改原有系统的基础上选择算法或行为":["4.44"],"也可以灵活地增加新的算法或行为":["4.44"],"策略模式提供了管理相关的算法族的办法":["4.44"],"策略类的等级结构定义了一个算法或行为族":["4.44"],"恰当使用继承可以把公共的代码移到抽象策略类中":["4.44"],"从而避免重复的代码":["4.44"],"策略模式提供了一种可以替换继承关系的办法":["4.44"],"如果不使用策略模式":["4.44"],"那么使用算法的环境类就可能会有一些子类":["4.44"],"每一个子类提供一种不同的算法":["4.44"],"但是":["4.44","11.0"],"这样一来算法的使用就和算法本身混在一起":["4.44"],"不符合":["4.44"],"单一职责原则":["4.44"],"决定使用哪一种算法的逻辑和该算法本身混合在一起":["4.44"],"从而不可能再独立演化":["4.44"],"把茶叶倒进杯子":["4.45"],"这里既泡了咖啡又泡了茶":["4.45"],"是不是没有之前那么繁琐呢":["4.45"],"这里的代码可是很高级的呢":["4.45"],"这里用一个父类":["4.45"],"来表示":["4.45"],"和":["4.45","9.9","9.21","10.9","12.9","48.2","49.5"],"然后子类就是后面的":["4.45"],"啦":["4.45"],"因为这里的":["4.45"],"是一个抽象的存在":["4.45"],"需要子类来继承它":["4.45"],"泡饮品的流程":["4.45"],"可以理解为一个模板模式":["4.45"],"在子类中实现":["4.45"],"的继承是基于原型链的继承":["4.45"],"这里":["4.45","49.5"],"就是类的原型链":["4.45"],"这里由于":["4.45"],"object":["4.46","11.12"],"访问者模式解决了数据与数据的操作方法之间的耦合":["4.46"],"让数据的操作方法独立于数据":["4.46"],"使其可以自由演变":["4.46"],"因此":["4.46"],"访问者模式更适合于那些数据稳定":["4.46"],"文中有误之处还望不吝指出":["4.47"],"github":["4.48"],"com":["4.48"],"skyming":["4.48"],"对面向过程的抽象":["5.0"],"function":["5.0","9.4","18.3","47.3"],"n1":["5.0","14.0"],"n2":["5.0"],"return":["5.0","10.12","20.1"],"first":["5.1"],"done":["5.2"],"false":["5.2","9.25","11.0","16.3","34.6"],"true":["5.2","9.25","11.0"],"apply":["5.2"],"this":["5.2"],"arguments":["5.2"],"pay":["5.2"],"不会随着方法的结束而销毁堆内存":["5.3"],"存放引用数据类型":["5.3"],"实际保存的不是变量本身":["5.3"],"而是指向该对象的指针":["5.3"],"堆溢出":["5.3"],"不纯的函数":["5.4"],"mini":["5.4"],"checkage":["5.4"],"age":["5.4","9.29","10.11"],"min":["5.4","34.13"],"有硬编码":["5.4"],"curriedfn":["5.5"],"args":["5.5","10.13","48.6"],"if":["5.5"],"concat":["5.5"],"loadsh":["5.6"],"fp模块":["5.6"],"tolower":["5.7"],"readfilesync":["5.8"],"print":["5.8"],"cat":["5.8"],"函子是一个可以变扁的":["5.8"],"t":["7.4","10.13","12.2","35.4"],"文档和所有子资源已完成加载":["7.4"],"状态表示":["7.4"],"不就是数值的运算么":["8.0"],"类型系统中没有加减乘除运算符":["8.0"],"但是可以通过构造不同的数组然后取":["8.0"],"的方式来完成数值计算":["8.0"],"把数值的加减乘除转化为对数组的提取和构造":["8.0"],"num2":["8.2"],"我们拿大一点的数测试下":["8.2"],"addresult":["8.2"],"长度的数组":["8.3"],"通过模式匹配提取出":["8.3"],"长度个元素":["8.3"],"剩下的放到":["8.3","12.4"],"声明的局部变量":["8.3","12.4","12.9","12.10","48.4"],"为":["8.4"],"就代表加完了":["8.4"],"加的过程就是往":["8.4"],"数组中放":["8.4"],"个元素":["8.4"],"这样递归的进行累加":["8.4"],"也就是递归的往":["8.4"],"减到了":["8.5"],"那么这时候减了几次就是除法结果":["8.5"],"也就是":["8.5","8.9","12.4","13.4"],"否则继续递归的减":["8.5"],"让":["8.5"],"减去":["8.5"],"代表从":["8.7"],"开始":["8.7"],"每次通过模式匹配提取去掉一个字符之后的剩余字符串":["8.7"],"并且往计数数组里多放入一个元素":["8.7"],"递归进行取字符和计数":["8.7"],"如果模式匹配不满足":["8.7"],"返回":["8.8","10.15"],"反之":["8.8"],"代表求数列的第几个数":["8.9"],"判断当前":["8.9"],"是否到了":["8.9"],"到了就返回当前的数值":["8.9"],"否则求出当前":["8.9"],"对应的数值":["8.9"],"用之前的数加上当前的数":["8.9"],"静态类型也消除了类型不安全的隐患":["9.1"],"因为在编译期间就做了类型检查":["9.1"],"就不会出现对":["9.1"],"调用了":["9.1"],"方法这类问题":["9.1"],"静态类型虽然代码写起来要考虑的问题多一些":["9.1"],"会复杂一些":["9.1"],"但是却消除了代码中潜藏类型不安全问题的可能":["9.1"],"知道了动态类型检查和静态类型检查的区别":["9.1"],"这个问题的解决思路很容易想到":["9.3"],"如果类型能传参数就好了":["9.3"],"传入":["9.3"],"就是整数加法":["9.3"],"类型该怎么写呢":["9.4"],"ts":["9.4"],"getpropvalue":["9.4"],"key":["9.4","11.12"],"key对应的属性值类型":["9.4"],"never":["9.5","12.13","47.0"],"str":["9.5","10.17","34.2","47.3"],"rest":["9.5"],"分为两种":["9.6"],"一种是子类型可以赋值给父类型":["9.6"],"叫做协变":["9.6"],"covariant":["9.6"],"swim":["9.7"],"这并不会报错":["9.7"],"虽然这俩类型不一样":["9.7"],"但是依然是类型安全的":["9.7"],"这种子类型可以赋值给父类型的情况就叫做协变":["9.7"],"为什么要支持协变很容易理解":["9.7"],"关掉之后":["9.8"],"就会发现两种赋值都可以了":["9.8"],"这样就支持函数参数的双向协变":["9.8"],"类型检查不会报错":["9.8"],"但不能严格保证类型安全":["9.8"],"开启之后":["9.8"],"函数参数就只支持逆变":["9.8"],"子类型赋值给父类型就会报错":["9.8"],"再举个逆变的例子":["9.8"],"大家觉得下面这样的":["9.8"],"代码会报错么":["9.8"],"type":["9.8","9.15","9.27","10.13"],"func":["9.8","47.3"],"string":["9.8","9.12","10.11","10.16","20.3","41.4","47.1"],"哪个更具体":["9.9"],"更具体":["9.9"],"array":["9.11","9.14","11.3"],"这些":["9.11"],"typescript":["9.11","11.7"],"类型系统也都支持":["9.11"],"但是又多加了三种类型":["9.11"],"元组":["9.11"],"prop":["9.13","47.2"],"但是它不可以赋值给别的类型":["9.14"],"这些就是":["9.14"],"类型系统中的全部类型了":["9.14"],"大部分是从":["9.14"],"js":["9.14"],"中迁移过来的":["9.14"],"比如基础类型":["9.14"],"class":["9.14"],"也添加了一些类型":["9.14"],"tuple":["9.15","47.8"],"res2":["9.17"],"这里的":["9.18","9.21","49.2","49.5"],"是约束的意思":["9.18","49.2"],"也就是约束类型参数只能是数组类型":["9.18"],"因为不知道数组元素的具体类型":["9.18"],"所以用":["9.18"],"不可合并":["9.20"],"可能大家会迷惑":["9.21","49.5"],"解释一下":["9.21","49.5"],"因为索引类型":["9.21","49.5"],"可以用":["9.21","49.5"],"number":["9.21","10.11","11.3","16.4","49.5"],"symbol":["9.21","49.5"],"作为":["9.21","49.5"],"undefined":["9.23"],"是不传类型的":["9.24"],"相当于一个临时变量":["9.24"],"其目的是对比":["9.24"],"x":["9.24"],"testany":["9.26"],"testanyresult":["9.26"],"len":["9.27"],"是为了触发联合类型的":["9.28"],"distributive":["9.28","13.5"],"的性质":["9.28"],"让每个类型单独传入做计算":["9.28"],"最后合并":["9.28","13.0"],"比如单独取出":["9.29"],"构造的新的索引类型是这样的":["9.29"],"可选的意思是这个索引可能没有":["9.29"],"没有的时候":["9.29"],"那":["9.29"],"就是空的":["9.29"],"所以":["9.29"],"的索引":["9.30"],"可以用来过滤出":["9.30"],"的属性":["9.30"],"默认推导出来的不是字面量类型":["9.30"],"加上":["9.30","11.7"],"as":["9.30"],"这就是":["10.0"],"类型的模式匹配":["10.0"],"类型的模式匹配是通过":["10.0"],"getfirstvalue":["10.2"],"getfirst":["10.3"],"声明的局部变量里":["10.6"],"不匹配时":["10.7","10.8"],"结合就是":["10.9","48.2"],"name":["10.11","10.16","10.17"],"getreturntyperesult":["10.12"],"infer":["10.13","48.6"],"unknown":["10.13","48.6"],"类型参数":["10.13"],"是待处理的类型":["10.13"],"用":["10.13","11.5","11.11","12.9","48.4"],"我们也可以通过模式匹配提取构造器的参数和返回值的类型":["10.14"],"里":["10.15","11.8","12.4","12.9","48.4"],"这样就能取出构造器对应的实例类型":["10.15"],"person":["10.16"],"getconstructorparametersresult":["10.16"],"的类型返回":["10.17"],"否则返回":["10.17","48.1"],"getpropsrefresult":["10.17"],"当":["10.17","13.2","24.4"],"严格来说这三种也都不叫变量":["11.0"],"因为它们不能被重新赋值":["11.0"],"涉及到了映射类型的语法":["11.1"],"我们先从简单的开始":["11.1"],"这就是数组":["11.3"],"元组的重新构造":["11.3"],"数组和元组的区别":["11.3"],"数组类型是指任意多个同一类型的元素构成的":["11.3"],"比如":["11.3"],"剩余的放到":["11.5"],"构造成新的元组的一个元素":["11.5"],"剩余元素继续递归处理":["11.5"],"这样":["11.5","12.2"],"就能处理任意个数元组的合并":["11.5"],"提供的内置高级类型":["11.7"],"把首字母转为大写":["11.7"],"然后把右边的字符":["11.8"],"大写":["11.8"],"如果匹配":["11.9"],"那就用":["11.9"],"构造成新的字符串":["11.9","12.11"],"然后继续递归删除":["11.9"],"数组添加":["11.11"],"构造成新的参数类型":["11.11"],"结合":["11.11"],"in":["11.12"],"值的类型可以做变换":["11.13"],"这里我们用之前索引类型的值":["11.13"],"构造成了三个元素的元组类型":["11.13"],"类型":["11.14","11.20","41.4"],"而这里只能接受":["11.14"],"所以要":["11.14"],"也就是取索引中":["11.14"],"的部分":["11.14"],"uppercase":["11.15","50.21"],"也就是约束类型参数":["11.15"],"的索引添加了":["11.17"],"可选修饰符":["11.17"],"的每个索引去掉":["11.18"],"的修饰":["11.18","11.19"],"的索引去掉":["11.19"],"索引依然为之前的索引":["11.20"],"否则索引设置为":["11.20"],"的索引会在生成新的索引类型时被去掉":["11.20"],"就完成了不确定数量的类型编程":["12.0"],"达到循环的效果":["12.0"],"既然提到了数组":["12.0"],"字符串":["12.0"],"返回这时的":["12.2"],"我们就提取到了最里层的":["12.2"],"也就是索引类型":["12.2"],"其实这个类型的实现可以进一步的简化":["12.2"],"deeppromisevaluetype2":["12.2"],"为待处理的数组类型":["12.4"],"元素类型不确定":["12.4"],"每次只处理一个元素的提取":["12.4"],"放到":["12.4"],"是否是要查找的元素":["12.5"],"也就是和":["12.5"],"相等":["12.5"],"是的话就返回":["12.5","12.7"],"否则继续递归判断下一个元素":["12.5"],"直到结束条件也就是提取不出下一个元素":["12.5"],"这时返回":["12.5"],"相等的判断就是":["12.5"],"是构造出的新数组":["12.6"],"默认值是":["12.6","12.7"],"通过模式匹配提取数组中的一个元素的类型":["12.6"],"如果是":["12.6"],"类型的话就删除":["12.6"],"也就是不放入构造的新数组":["12.6"],"直接返回之前的":["12.6"],"否则放入构造的新数组":["12.6"],"每次判断下":["12.7"],"的长度是否到了":["12.7"],"是替换到的字符":["12.9"],"通过模式匹配提取":["12.9"],"左右的字符串到":["12.9"],"为待处理的字符串类型":["12.10"],"通过":["12.10"],"约束为":["12.10"],"通过模式匹配提取第一个字符到":["12.10"],"和之前的":["12.11"],"把":["12.11"],"放到前面":["12.11"],"因为递归是从左到右处理":["12.11"],"或者":["12.13"],"从而触发计算":["12.13"],"这和联合类型遇到字符串时的处理一样":["13.0"],"这样确实是简化了类型编程逻辑的":["13.0"],"不需要递归提取每个元素再处理":["13.0"],"之所以这样处理联合类型也很容易理解":["13.0"],"因为联合类型的每个元素都是互不相关的":["13.0"],"不像数组":["13.0"],"索引":["13.0"],"就可以避免触发分布式条件类型":["13.2"],"那么":["13.2"],"就是整个联合类型":["13.2"],"是联合类型整体":["13.2"],"是单个类型":["13.2"],"自然不成立":["13.2"],"而其它类型没有这种特殊处理":["13.2"],"都是同一个":["13.2"],"怎么判断都成立":["13.2"],"利用这个特点就可以判断出是否是联合类型":["13.2"],"其中有两个点比较困惑":["13.2"],"我们重点记一下":["13.2"],"是联合类型时":["13.2"],"也就是这样的效果":["13.3"],"remresult":["13.3"],"d":["13.3"],"e":["13.3","40.14"],"中去掉":["13.4"],"以后的所有类型组合":["13.4"],"去掉":["13.4"],"以后的所有组合":["13.4"],"只有左边是单独的类型参数才可以":["13.5"],"我们后面做了一些案例":["13.5"],"发现联合类型的这种":["13.5"],"总连线数等于总节点数减一":["14.0"],"总连线数等于分支度为":["14.0"],"的结点在二叉树中的位置相同":["14.2"],"它的左":["14.3"],"右子树也分别为二叉排序树":["14.3"],"树分配新结点的概率比":["14.7"],"维基百科二叉树":["14.18"],"then":["15.0"],"generate":["15.0"],"文件没变":["16.3"],"单位毫秒":["16.4"],"rejected":["18.0"],"返回的":["18.0"],"status":["18.1"],"transformdata":["18.1"],"data":["18.1"],"回调函数":["18.2"],"params":["18.3"],"需要传递的参数":["18.3"],"else":["19.1","34.21"],"join":["19.1"],"全部大写":["19.3"],"全部小写":["19.3"],"null":["20.1"],"unescape":["20.1"],"无":["20.3"],"hh":["21.0","21.3"],"时":["21.0","21.3","32.1"],"regexp":["21.1"],"exec":["21.1"],"replace":["21.1","34.2","48.1"],"分":["21.3"],"浮":["22.0"],"到数列的顶端":["22.0"],"直到排序完成":["22.1"],"元素交换":["22.3"],"buckets":["23.2"],"fill":["23.2"],"排序所用的时间也会越少":["23.3"],"但相应的空间消耗就会增大":["23.3"],"nlog":["24.0"],"n":["24.0","26.0"],"每放一个元素就将":["24.1"],"startindex":["24.3"],"不是很大并且序列比较集中时":["24.4"],"或者大于":["25.0"],"它的父节点":["25.0"],"description":["25.3"],"堆排序":["25.3"],"param":["25.3"],"可能会出现在":["26.0"],"的后面":["26.0"],"时间复杂度":["26.0"],"对排序数据的总的操作次数":["26.0"],"反映当":["26.0"],"变化时":["26.0"],"对于未排序数据":["27.0"],"在已排序序列中从后向前扫描":["27.0"],"需要反复把已排序元素逐步向后挪位":["27.4"],"为最新元素提供插入空间":["27.4"],"称为":["28.0"],"将两个排序好的子序列合并成一个最终的排序序列":["28.1"],"middle":["28.3"],"math":["28.3"],"floor":["28.3"],"slice":["28.3"],"代价是需要额外的内存空间":["28.4"],"以达到整个序列有序":["29.0"],"partition":["29.1"],"操作":["29.1"],"递归地":["29.1"],"快速排序":["29.3"],"桶排序扩展":["30.0"],"类似于指定桶排序按位数排序规则":["30.0"],"进行计数排序":["30.1"],"利用计数排序适用于小范围数的特点":["30.1"],"push":["30.3"],"为桶的数量":["30.4"],"一般来说":["30.4"],"然后放到已排序序列的末尾":["31.0"],"以此类推":["31.0"],"分别变为记录个数增加":["31.1"],"个的新有序区和记录个数减少":["31.1"],"理论上讲":["31.4"],"选择排序可能也是平时排序一般人想到的最多的排序方法了吧":["31.4"],"它与插入排序的不同之处在于":["32.0"],"它会优先比较距离较远的元素":["32.0"],"分别对各子表进行直接插入排序":["32.1"],"仅增量因子为":["32.1"],"sedgewick":["32.4"],"提出的":["32.4"],"translate":["33.1"],"ellipsis":["33.3"],"通知消息":["34.3"],"body":["34.3","34.15","39.6"],"returnvalue":["34.6"],"test1":["34.8"],"callmethod":["34.8"],"href":["34.14"],"download":["34.14","34.15"],"setattribute":["34.15"],"appendchild":["34.15"],"call":["34.16"],"set":["34.17"],"g":["34.18"],"window":["34.19"],"event":["34.19"],"cancelbubble":["34.19"],"scrolltop":["34.20"],"的包管理工具":["35.1"],"简洁的锁文件格式和明确的安装算法":["35.2"],"version":["35.3"],"但不接受1":["35.4"],"tilde":["35.4"],"发布包":["35.4"],"publish":["35.4"],"移除一个包":["35.4"],"会自动更新package":["35.4"],"remove":["35.4"],"packagename":["35.4"],"更新一个依赖":["35.4"],"用于更新包到基于规范范围的最新版本":["35.4"],"upgrade":["35.4"],"运行脚本":["35.4"],"run":["35.4"],"用来执行在":["35.4"],"文件":["35.5"],"注意":["35.5","48.5"],"这个文件不要手动修改它":["35.5"],"当你使用一些操作如":["35.5"],"xml":["36.5"],"id":["37.7"],"icon":["37.7"],"list":["37.7"],"jrhr27pqmyvenynlhaiesribywry0v":["38.4"],"8ixp8":["38.4"],"fvx11mr7l7ecueb":["38.4"],"r48emqm7fui2bgwdeg8cm":["38.4"],"7g3neofmdctqw4h9":["38.4"],"55lhm7dekrykqpzf2arbxtayu4kdyb2yxuzwg0gi":["38.4"],"41zthnfqg26hbgel":["38.4"],"crvrm7tny":["38.4"],"1btkoeaz2m05r4fb7r9gbaidxazyrhdosgj":["38.4"],"wceqy0j74tmoknbxxt9n3fgggwwsvdowhtjt9nnvf7yqm2azu":["38.4"],"文档基于":["39.1"],"vitepress":["39.1"],"badge":["39.2"],"module":["39.2"],"20formats":["39.2"],"2c":["39.2"],"20esm":["39.2"],"green":["39.2"],"umd":["39.3"],"vue":["39.4"],"tsx":["39.4"],"rpreview":["39.9"],"blob":["39.9"],"arraybuffer":["39.9"],"mutablerefobject":["39.9"],"declare":["39.9"],"namespace":["39.9"],"error":["39.10"],"错误提示":["39.10"],"success":["39.10"],"成功提示":["39.10"],"toast":["39.10"],"提示":["39.10"],"tab":["39.10"],"非常优秀的":["39.12"],"can":["39.12"],"i":["39.12"],"控件":["40.7"],"addeventlistener":["40.15"],"参数":["41.4"],"说明":["41.4"],"提示内容":["41.4"],"文件的预览":["43.0"],"搭配使用":["45.0"],"特殊的类型":["47.0"],"void":["47.0"],"里也叫做索引类型":["47.2"],"也就是索引了多个元素的类型的意思":["47.2"],"对象可以动态添加属性":["47.2"],"如果不知道会有什么属性":["47.2"],"可以用可索引签名":["47.2"],"的字符串字面量类型":["47.3"],"所以想要约束以某个字符串开头的字符串字面量类型时可以这样写":["47.3"],"否则就返回":["48.0"],"代表没匹配到":["48.0"],"去匹配一个模式类型":["48.1"],"模式类型的前缀是":["48.1"],"后面是任意的":["48.1"],"如果匹配返回":["48.1"],"字符串可以匹配一个模式类型":["48.1"],"提取想要的部分":["48.1"],"自然也可以用这些再构成一个新的类型":["48.1"],"比如实现字符串替换":["48.1"],"f":["48.1"],"返回值可以是任何类型":["48.4"],"any":["48.5"],"这里不能用":["48.5"],"h":["48.6"],"这种类型也叫做高级类型":["49.1"],"条件类型是":["49.2"],"res":["49.4"],"用于提取构造器参数的类型":["50.3"],"nonnullable":["50.21"],"和四个编译器内部实现的类型":["50.21"],"lowercase":["50.21"]},{"0":["21.1","29.3"],"1":["24.1"],"2":["1.15","14.18","20.1","49.4"],"3":["8.8"],"4":["8.8"],"5":["11.5","19.1","27.1"],"6":["4.18","4.19"],"11":["4.20"],"13":["39.12"],"17":["1.17"],"18":["1.17","34.4"],"19":["1.17","34.4"],"20":["1.17","16.4","34.4"],"21":["1.17"],"25":["8.2"],"27":["34.4"],"32":["8.2"],"35":["34.4"],"57":["8.2"],"2222":["9.20"],"导入导出语法":["1.1"],"从而分析出没有使用的代码":["1.1"],"进行去除":["1.1"],"我们分别来了解一下":["1.2"],"xxliteral":["1.3"],"来抽象这部分内容的":["1.3"],"guang":["1.4"],"答案是这些":["1.4"],"它们对应的":["1.5"],"ast":["1.5"],"节点如下图所示":["1.5"],"语句是代码执行的最小单位":["1.5"],"可以说":["1.5"],"代码是由语句":["1.5"],"构成的":["1.5"],"节点如下图":["1.6"],"声明语句用于定义变量":["1.6"],"这也是代码中一个基础组成部分":["1.6"],"是这样的":["1.7"],"你会发现赋值语句的":["1.7"],"节点":["1.7"],"assignmentexpression":["1.7"],"包裹了一层":["1.7"],"expressionstatement":["1.7"],"的节点":["1.7"],"代表这个表达式是被当成语句执行的":["1.7"],"babel":["1.8"],"中有专门的":["1.8"],"来表示它的内容":["1.8"],"对应的":["1.9"],"节点为":["1.9"],"则是代码中的指令部分":["1.10"],"节点类型":["1.11"],"就是通过这些节点来抽象源码中不同的部分":["1.11"],"types":["1.12"],"的":["1.12","4.36","4.45","8.4"],"typescript":["1.12"],"类型定义":["1.12"],"只能修改值":["1.13"],"可以连引号一起修改":["1.13"],"的操作了":["1.14"],"这是编译":["1.14"],"静态分析的第一步":["1.14"],"逐个代码字符扫描":["1.15"],"根据语法规则进行":["1.15"],"分组":["1.15"],"有了":["1.16"],"类型和对应生成的规则":["1.16"],"我们便可以去遍历分析代码":["1.16"],"输出分析后的结果":["1.16"],"rightparen":["1.17"],"leftcurly":["1.17"],"rightcurly":["1.17"],"一个简易版本的分词器已经被我们开发出来了":["1.17"],"不过目前的分词器还比较简陋":["1.17"],"仅仅支持有限的语法":["1.17"],"不过在明确了核心的开发步骤之后":["1.17"],"后面继续完善的过程就比较简单了":["1.17"],"开发步骤主要分为":["1.18"],"初始化类型声明":["1.18"],"core":["2.0"],"基于上面的包来完成":["2.0"],"的编译流程":["2.0"],"并应用":["2.0"],"plugin":["2.0"],"preset":["2.0"],"cli":["3.0"],"和命令行能力":["3.0"],"amd":["4.0"],"computer":["4.0"],"desktopcomputer":["4.0"],"notebookcomputer":["4.0"],"他们依然存在":["4.5"],"不知道":["4.6"],"杜绝双向依赖的产生":["4.7"],"优点":["4.9","4.10","4.13","4.24","4.33","4.40","4.45","4.46"],"实践开闭原则的优点在于可以在不改动原有代码的前提下给程序扩展功能":["4.9"],"增加了程序的可扩展性":["4.9"],"同时也降低了程序的维护成本":["4.9"],"由于使用基类对象的地方都可以使用子类对象":["4.10"],"因此在程序中尽量使用基类类型来对对象进行定义":["4.10"],"而在运行时再确定其子类类型":["4.10"],"用子类对象来替换父类对象":["4.10"],"可以检验继承使用的正确性":["4.10"],"约束继承在使用上的泛滥":["4.10"],"而且以抽象搭建的系统要比以具体实现搭建的系统更加稳定":["4.11"],"扩展性更高":["4.11"],"同时也便于维护":["4.11"],"也有利于":["4.12"],"的追踪":["4.12"],"也就是降低了程序的维护成本":["4.12"],"实践迪米特法则可以良好地降低类与类之间的耦合":["4.13"],"减少类与类之间的关联程度":["4.13"],"让类与类之间的协作更加直接":["4.13"],"接口责任划分更加明确":["4.14"],"符合高内聚低耦合的思想":["4.14"],"避免复用时滥用继承":["4.15"],"合理使用组合关系":["4.15"],"增加灵活性":["4.15"],"单一职责原则强调单个类内部根据职责细分的设计":["4.16"],"接口分离原则强调类之间的耦合":["4.16"],"尽量建立最小的依赖关系":["4.16"],"如单例模式是对象创建型模式":["4.17"],"模板方法模式是类行为型模式":["4.17"],"原型模式":["4.18"],"prototype":["4.18"],"装饰者模式":["4.19"],"享元模式":["4.19"],"模板方法模式":["4.20"],"访问者模式":["4.20"],"客户端无须知道所创建的具体产品类的类名":["4.22"],"只需要知道具体产品类所对应的参数即可":["4.22"],"减少开发者的记忆成本":["4.22"],"缺点":["4.22","4.23","4.24","4.26","4.27","4.29","4.30","4.31","4.32","4.33","4.34","4.36","4.37","4.38","4.40","4.41","4.42","4.43","4.44","4.45","4.46"],"如果业务上添加新产品的话":["4.22"],"就需要修改工厂类原有的判断逻辑":["4.22"],"这其实是违背了开闭原则的":["4.22"],"在产品类型较多时":["4.22"],"有可能造成工厂逻辑过于复杂":["4.22"],"所以简单工厂模式比较适合产品种类比较少而且增多的概率很低的情况":["4.22"],"除了需要提供新的产品类之外":["4.23"],"还要提供与其对应的具体工厂类":["4.23"],"因此系统中类的个数将成对增加":["4.23"],"增加了系统的复杂度":["4.23"],"具体产品在应用层代码隔离":["4.24"],"不需要关心产品细节":["4.24"],"只需要知道自己需要的产品是属于哪个工厂的即可":["4.24"],"当一个产品族中的多个对象被设计成一起工作时":["4.24"],"它能够保证客户端始终只使用同一个产品族中的对象":["4.24"],"这对一些需要根据当前环境来决定其行为的软件系统来说":["4.24"],"是一种非常实用的设计模式":["4.24"],"规定了所有可能被创建的产品集合":["4.24"],"产品族中扩展新的产品困难":["4.24"],"需要修改抽象工厂的接口":["4.24"],"来说":["4.25"],"如果对象长时间不被利用":["4.25"],"则可能会被回收":["4.25"],"那么如果这个单例持有一些数据的话":["4.25"],"在回收后重新实例化时就不复存在了":["4.25"],"因此可以很方便地替换具体建造者或增加新的具体建造者":["4.26"],"用户使用不同的具体建造者即可得到不同的产品对象":["4.26"],"增加新的具体建造者无须修改原有类库的代码":["4.26"],"指挥者类针对抽象建造者类编程":["4.26"],"系统扩展方便":["4.26"],"符合":["4.26","4.38","4.46"],"开闭原则":["4.26","4.36","4.37","4.38","4.40","4.43","4.46"],"可以更加精细地控制产品的创建过程":["4.26"],"将复杂产品的创建步骤分解在不同的方法中":["4.26"],"使得创建过程更加清晰":["4.26"],"也更方便使用程序来控制创建过程":["4.26"],"建造者模式所创建的产品一般具有较多的共同点":["4.26"],"其组成部分相似":["4.26"],"如果产品之间的差异性很大":["4.26"],"则不适合使用建造者模式":["4.26"],"因此其使用范围受到一定的限制":["4.26"],"如果产品的内部变化复杂":["4.26"],"可能会导致需要定义很多具体建造者类来实现这种变化":["4.26"],"导致系统变得很庞大":["4.26"],"增加系统的理解难度和运行成本":["4.26"],"提高对象生成的效率":["4.27"],"可以很方便得通过改变值来生成新的对象":["4.27"],"有些对象之间的差别可能只在于某些值的不同":["4.27"],"用原型模式可以快速复制出新的对象并手动修改值即可":["4.27"],"对象包含的所有对象都需要配备一个克隆的方法":["4.27"],"这就使得在对象层级比较多的情况下":["4.27"],"代码量会很大":["4.27"],"也更加复杂":["4.27"],"装饰者和被装饰者可以独立变化":["4.29"],"用户可以根据需要增加新的装饰类":["4.29"],"在使用时再对其进行组合":["4.29"],"原有代码无须改变":["4.29"],"装饰者模式需要创建一些具体装饰类":["4.29"],"会增加系统的复杂度":["4.29"],"最少知道原则":["4.30"],"子系统只需要将需要外部调用的接口暴露给外观类即可":["4.30"],"而且他的接口则可以隐藏起来":["4.30"],"违背了开闭原则":["4.30"],"在不引入抽象外观类的情况下":["4.30"],"增加新的子系统可能需要修改外观类或客户端的代码":["4.30"],"统的耦合度":["4.31"],"不同类型的代理可以对客户端对目标对象的访问进行不同的控制":["4.31"],"远程代理":["4.31"],"使得客户端可以访问在远程机器上的对象":["4.31"],"远程机器":["4.31"],"可能具有更好的计算性能与处理速度":["4.31"],"可以快速响应并处理客户端请求":["4.31"],"虚拟代理通过使用一个小对象来代表一个大对象":["4.31"],"可以减少系统资源的消耗":["4.31"],"对系统进行优化并提高运行速度":["4.31"],"保护代理可以控制客户端对真实对象的使用权限":["4.31"],"由于在客户端和被代理对象之间增加了代理对象":["4.31"],"因此可能会让客户端请求的速度变慢":["4.31"],"使得相同对象或相似对象在内存中只保存一份":["4.32"],"降低系统的使用内存":["4.32"],"也可以提性能":["4.32"],"享元模式的外部状态相对独立":["4.32"],"而且不会影响其内部状态":["4.32"],"从而使得享元对象可以在不同的环境中被共享":["4.32"],"使用享元模式需要分离出内部状态和外部状态":["4.32"],"这使得程序的逻辑复杂化":["4.32"],"对象在缓冲池中的复用需要考虑线程问题":["4.32"],"hello":["4.33","9.8"],"扩展性好":["4.33"],"符合开闭原则":["4.33"],"将抽象与实现分离":["4.33"],"让二者可以独立变化":["4.33"],"在设计之前":["4.33"],"需要识别出两个独立变化的维度":["4.33"],"提高类的复用性":["4.34"],"目标类和适配器类解耦":["4.34"],"提高程序扩展性":["4.34"],"增加了系统的复杂性":["4.34"],"而不需要维持它对所有的候选处理者的引用":["4.36"],"可简化对象的相互连接":["4.36"],"在给对象分派职责时":["4.36"],"职责链可以给我们更多的灵活性":["4.36"],"可以通过在运行时对该链进行动态的增加或修改来增加或改变处理一个请求的职责":["4.36"],"在系统中增加一个新的具体请求处理者时无须修改原有系统的代码":["4.36"],"只需要在客户端重新建链即可":["4.36"],"从这一点来看是符合":["4.36"],"由于一个请求没有明确的接收者":["4.36"],"那么就不能保证它一定会被处理":["4.36"],"该请求可能一直到链的末端都得不到处理":["4.36"],"一个请求也可能因职责链没有被正确配置而得不到处理":["4.36"],"对于比较长的职责链":["4.36"],"请求的处理可能涉及到多个处理对象":["4.36"],"系统性能将受到一定影响":["4.36"],"而且在进行代码调试时不太方便":["4.36"],"如果建链不当":["4.36"],"可能会造成循环调用":["4.36"],"将导致系统陷入死循环":["4.36"],"甚至客户类代码":["4.37"],"满足":["4.37"],"的要求":["4.37","4.46"],"可以比较容易地设计一个命令队列或宏命令":["4.37"],"组合命令":["4.37"],"为请求的撤销":["4.37"],"undo":["4.37"],"和恢复":["4.37"],"redo":["4.37"],"操作提供了一种设计和实现方案":["4.37"],"使用命令模式可能会导致某些系统有过多的具体命令类":["4.37"],"因为针对每一个对请求接收者的调用操作都需要设计一个具体命令类":["4.37"],"因此在某些系统中可能需要提供大量的具体命令类":["4.37"],"这将影响命令模式的使用":["4.37"],"还可以通过一些工具自动生成节点类代码":["4.38"],"增加新的解释表达式较为方便":["4.38"],"如果用户需要增加新的解释表达式只需要对应增加一个新的终结符表达式或非终结符表达式类":["4.38"],"原有表达式类代码无须修改":["4.38"],"对于复杂文法难以维护":["4.38"],"在解释器模式中":["4.38"],"每一条规则至少需要定义一个类":["4.38"],"因此如果一个语言包含太多文法规则":["4.38"],"类的个数将会急剧增加":["4.38"],"导致系统难以管理和维护":["4.38"],"此时可以考虑使用语法分析程序等方式来取代解释器模式":["4.38"],"执行效率较低":["4.38"],"由于在解释器模式中使用了大量的循环和递归调用":["4.38"],"因此在解释较为复杂的句子时其速度很慢":["4.38"],"而且代码的调试过程也比较麻烦":["4.38"],"就无法实现逆向遍历":["4.39"],"如果需要实现逆向遍历":["4.39"],"只能通过其子类":["4.39"],"listiterator":["4.39"],"等来实现":["4.39"],"而":["4.39","9.8"],"迭代器无法用于操作":["4.39"],"set":["4.39"],"类型的聚合对象":["4.39"],"在自定义迭代器时":["4.39"],"创建一个考虑全面的抽象迭代器并不是件很容易的事情":["4.39"],"中介者模式简化了对象之间的交互":["4.40"],"它用中介者和同事的一对多交互代替了原来同事之间的多对多交互":["4.40"],"一对多关系更容易理解":["4.40"],"维护和扩展":["4.40"],"将原本难以理解的网状结构转换成相对简单的星型结构":["4.40"],"中介者模式可将各同事对象解耦":["4.40"],"中介者有利于各同事之间的松耦合":["4.40"],"我们可以独立的改变和复用每一个同事和中介者":["4.40"],"增加新的中介者和新的同事类都比较方便":["4.40"],"更好地符合":["4.40"],"可以减少子类生成":["4.40"],"中介者将原本分布于多个对象间的行为集中在一起":["4.40"],"改变这些行为只需生成新的中介者子类即可":["4.40"],"这使各个同事类可被重用":["4.40"],"无须对同事类进行扩展":["4.40"],"在具体中介者类中包含了大量同事之间的交互细节":["4.40"],"可能会导致具体中介者类非常复杂":["4.40"],"使得系统难以维护":["4.40"],"备忘录保存了原发器的状态":["4.41"],"采用列表":["4.41"],"堆栈等集合来存储备忘录对象可以实现多次撤销操作":["4.41"],"资源消耗过大":["4.41"],"如果需要保存的原发器类的成员变量太多":["4.41"],"就不可避免需要占用大量的存储空间":["4.41"],"每保存一次对象的状态都需要消耗一定的系统资源":["4.41"],"增加新的观察目标也很方便":["4.42"],"如果一个观察目标对象有很多直接和间接观察者":["4.42"],"将所有的观察者都通知到会花费很多时间":["4.42"],"如果在观察者和观察目标之间存在循环依赖":["4.42"],"观察目标会触发它们之间进行循环调用":["4.42"],"可能导致系统崩溃":["4.42"],"观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的":["4.42"],"而仅仅只是知道观察目标发生了变化":["4.42"],"而不是提供一个巨大的条件语句块":["4.43"],"状态模式可以让我们避免使用庞大的条件语句来将业务方法和状态转换代码交织在一起":["4.43"],"可以让多个环境对象共享一个状态对象":["4.43"],"从而减少系统中对象的个数":["4.43"],"状态模式的使用必然会增加系统中类和对象的个数":["4.43"],"导致系统运行开销增大":["4.43"],"状态模式的结构与实现都较为复杂":["4.43"],"如果使用不当将导致程序结构和代码的混乱":["4.43"],"增加系统设计的难度":["4.43"],"状态模式对":["4.43"],"的支持并不太好":["4.43"],"增加新的状态类需要修改那些负责状态转换的源代码":["4.43"],"否则无法转换到新增状态":["4.43"],"而且修改某个状态类的行为也需修改对应类的源代码":["4.43"],"而且使用继承无法实现算法或行为在程序运行时的动态切换":["4.44"],"使用策略模式可以避免多重条件选择语句":["4.44"],"多重条件选择语句不易维护":["4.44"],"它把采取哪一种算法或行为的逻辑与算法或行为本身的实现逻辑混合在一起":["4.44"],"将它们全部硬编码":["4.44"],"hard":["4.44"],"coding":["4.44"],"在一个庞大的多重条件选择语句中":["4.44"],"比直接继承环境类的办法还要原始和落后":["4.44"],"策略模式提供了一种算法的复用机制":["4.44"],"由于将算法单独提取出来封装在策略类中":["4.44"],"因此不同的环境类可以方便地复用这些策略类":["4.44"],"客户端必须知道所有的策略类":["4.44"],"并自行决定使用哪一个策略类":["4.44"],"这就意味着客户端必须理解这些算法的区别":["4.44"],"以便适时选择恰当的算法":["4.44"],"换言之":["4.44"],"策略模式只适用于客户端知道所有的算法或行为的情况":["4.44"],"策略模式将造成系统产生很多具体策略类":["4.44"],"任何细小的变化都将导致系统要增加一个新的具体策略类":["4.44"],"无法同时在客户端使用多个策略类":["4.44"],"也就是说":["4.44"],"在使用策略模式时":["4.44"],"客户端每次只能使用一个策略类":["4.44"],"不支持使用一个策略类完成部分功能后再使用另一个策略类来完成剩余功能的情况":["4.44"],"对象和":["4.45"],"对象的原型":["4.45"],"上都没有对应的":["4.45"],"所以请求会顺着原型链":["4.45"],"找到父类":["4.45"],"子类寻找对应的属性和方法的时候会顺着原型链去查找":["4.45"],"先找自己":["4.45"],"没有找到会顺着去父类里面查找":["4.45"],"被称为模板方法的原因是":["4.45"],"该方法中封装了子类的算法框架":["4.45"],"它作为一个算法的模板":["4.45"],"指导子类以何种顺序去执行哪些方法":["4.45"],"在父类中形式化地定义一个算法":["4.45"],"而由它的子类来实现细节的处理":["4.45"],"在子类实现详细的处理算法时并不会改变算法中步骤的执行次序":["4.45"],"模板方法模式是一种代码复用技术":["4.45"],"它在类库设计中尤为重要":["4.45"],"它提取了类库中的公共行为":["4.45"],"将公共行为放在父类中":["4.45"],"而通过其子类来实现不同的行为":["4.45"],"它鼓励我们恰当使用继承来实现代码复用":["4.45"],"可实现一种反向控制结构":["4.45"],"通过子类覆盖父类的钩子方法来决定某一特定步骤是否需要执行":["4.45"],"在模板方法模式中可以通过子类来覆盖父类的基本方法":["4.45"],"不同的子类可以提供基本方法的不同实现":["4.45"],"更换和增加新的子类很方便":["4.45"],"符合单一职责原则和开闭原则":["4.45"],"需要为每一个基本方法的不同实现提供一个子类":["4.45"],"如果父类中可变的基本方法太多":["4.45"],"将会导致类的个数增加":["4.45"],"系统更加庞大":["4.45"],"设计也更加抽象":["4.45"],"此时":["4.45"],"可结合桥接模式来进行设计":["4.45"],"但数据的操作方法易变的环境下":["4.46"],"增加新的访问操作很方便":["4.46"],"使用访问者模式":["4.46"],"增加新的访问操作就意味着增加一个新的具体访问者类":["4.46"],"实现简单":["4.46"],"无须修改源代码":["4.46"],"将有关元素对象的访问行为集中到一个访问者对象中":["4.46"],"而不是分散在一个个的元素类中":["4.46"],"类的职责更加清晰":["4.46"],"有利于对象结构中元素对象的复用":["4.46"],"相同的对象结构可以供多个不同的访问者访问":["4.46"],"让用户能够在不修改现有元素类层次结构的情况下":["4.46"],"定义作用于该层次结构的操作":["4.46"],"增加新的元素类很困难":["4.46"],"在访问者模式中":["4.46"],"每增加一个新的元素类都意味着要在抽象访问者角色中增加一个新的抽象操作":["4.46"],"并在每一个具体访问者类中增加相应的具体操作":["4.46"],"这违背了":["4.46"],"破坏封装":["4.46"],"访问者模式要求访问者对象访问并调用每一个元素对象的操作":["4.46"],"这意味着元素对象有时候必须暴露一些自己的内部操作和内部状态":["4.46"],"否则无法供访问者访问":["4.46"],"trip":["4.48"],"to":["4.48","48.1"],"ios":["4.48"],"result":["5.0","48.0"],"class":["5.1"],"mdn":["5.1"],"money":["5.2"],"支付":["5.2"],"循环创建对象":["5.3"],"就是不断的":["5.3"],"new":["5.3","25.3"],"对象":["5.3"],"后续可以通过柯里化来解决":["5.4"],"array":["5.5"],"form":["5.5"],"arguments":["5.5"],"else":["5.5"],"总结":["5.5"],"柯里化可以让我们给一个函数传递较少的参数":["5.5"],"返回一个记住来某些固定参数的新函数":["5.5"],"这是一种对函数参数的缓存":["5.5"],"让函数变的更灵活":["5.5"],"让函数的粒度更小":["5.5"],"可以把多元函数转换成一元的函数":["5.5"],"可以组合使用函数产生强大的功能":["5.5"],"lodasg":["5.6"],"splite":["5.7"],"变扁就是解决函子嵌套的问题":["5.8"],"一个函子如果具有":["5.8"],"join":["5.8"],"两个方法并遵守一些定律就是一个":["5.8"],"注意看join方法":["5.8"],"flatmap":["5.8"],"经常会用到map和join方法":["5.8"],"所以就用flatmap将其变扁":["5.8"],"这里可以用map去处理内容":["5.8"],"load":["7.4"],"事件即将被触发":["7.4"],"严格来说构造的是元组":["8.0"],"大家知道数组和元组的区别就行":["8.0"],"这点可以说是类型体操中最麻烦的一个点":["8.0"],"需要思维做一些转换":["8.0"],"绕过这个弯来":["8.0"],"下面我们就来做一些真实的案例来掌握它吧":["8.0"],"就这样":["8.2","8.3","8.4","8.5"],"我们通过构造一定长度的数组取":["8.2"],"的方式实现了加法运算":["8.2"],"里":["8.3"],"取":["8.3"],"的长度返回":["8.3"],"就是减法的结果":["8.3"],"我们通过数组类型的提取实现了减法运算":["8.3"],"中放元素":["8.4"],"最后取":["8.4"],"就是乘法的结果":["8.4"],"我们通过递归的累加实现了乘法":["8.4"],"并且":["8.5"],"多加一个元素代表又减了一次":["8.5"],"这样就实现了除法":["8.5"],"我们通过递归的累减并记录减了几次实现了除法":["8.5"],"做完了加减乘除":["8.5"],"我们再来做一些别的数值计算的类型体操":["8.5"],"代表计数结束":["8.7"],"返回计数数组的长度":["8.7"],"这样就能求出字符串长度":["8.7"],"如果都没到就往计数数组":["8.8"],"中放入一个元素":["8.8"],"继续递归":["8.8"],"这样就实现了数值比较":["8.8"],"当":["8.8"],"比较时":["8.8"],"然后继续递归":["8.9"],"这就是递归计算":["8.9"],"fibinacci":["8.9"],"数列的数的过程":["8.9"],"可以正确的算出第":["8.9"],"个数是":["8.9"],"我们自然可以得出这样的结论":["9.1"],"动态类型只适合简单的场景":["9.1"],"对于大项目却不太合适":["9.1"],"因为代码中可能藏着的隐患太多了":["9.1"],"万一线上报一个类型不匹配的错误":["9.1"],"那可能就是大问题":["9.1"],"而静态类型虽然会增加写代码的成本":["9.1"],"但是却能更好的保证代码的健壮性":["9.1"],"减少":["9.1"],"bug":["9.1"],"率":["9.1"],"大型项目注定会用静态类型语言开发":["9.1"],"就是浮点数加法":["9.3"],"所以":["9.3","9.4"],"就有了第二种类型系统":["9.3"],"好像拿到了":["9.4"],"也不能拿到它的属性和属性值":["9.4"],"如果能对类型参数":["9.4"],"做一些逻辑处理就好了":["9.4"],"就有了第三种类型系统":["9.4"],"的类型系统是图灵完备的":["9.5"],"也就是能描述各种可计算逻辑":["9.5"],"简单点来理解就是循环":["9.5"],"条件等各种":["9.5"],"js":["9.5","49.5"],"里面有的语法它都有":["9.5"],"能写的逻辑它都能写":["9.5"],"对类型参数的编程是":["9.5"],"类型系统最强大的部分":["9.5"],"可以实现各种复杂的类型计算逻辑":["9.5"],"是它的优点":["9.5"],"但同时也被认为是它的缺点":["9.5"],"因为除了业务逻辑外还要写很多类型逻辑":["9.5"],"不过":["9.5"],"我倒是觉得这种复杂度是不可避免的":["9.5"],"因为":["9.5","49.5"],"本身足够灵活":["9.5"],"要准确定义类型那类型系统必然也要设计的足够灵活":["9.5"],"一种是父类型可以赋值给子类型":["9.6"],"叫做逆变":["9.6"],"contravariant":["9.6"],"先来看下协变":["9.6"],"类型系统支持了父子类型":["9.7"],"那如果子类型还不能赋值给父类型":["9.7"],"还叫父子类型么":["9.7"],"所以型变是实现类型父子关系必须的":["9.7"],"它在保证类型安全的基础上":["9.7"],"增加了类型系统的灵活性":["9.7"],"逆变相对难理解一些":["9.7"],"undefined":["9.8"],"答案是参数的位置会":["9.8"],"返回值的位置不会":["9.8"],"参数的位置是逆变的":["9.8"],"也就是被赋值的函数参数要是赋值的函数参数的子类型":["9.8"],"所以报错了":["9.8"],"返回值的位置是协变的":["9.8"],"也就是赋值的函数的返回值是被赋值的函数的返回值的子类型":["9.8"],"这里":["9.8","9.21"],"所以不报错":["9.8"],"tuple":["9.11"],"接口":["9.11","9.14"],"interface":["9.11","9.14"],"枚举":["9.11"],"enum":["9.11"],"总之":["9.13"],"接口可以用来描述函数":["9.13"],"索引类型":["9.13"],"数组":["9.13"],"等复合类型":["9.13"],"元组等":["9.14"],"还支持了字面量类型和":["9.14"],"的特殊类型":["9.14"],"这种类型也叫做高级类型":["9.17"],"高级类型的特点是传入类型参数":["9.17","49.1"],"经过一系列类型运算逻辑后":["9.17","49.1"],"返回新的类型":["9.17","49.1"],"在后面的章节会大量用到":["9.18"],"这里先简单了解即可":["9.18"],"aaaa":["9.20"],"never":["9.20","9.25","49.4"],"取出的索引就是":["9.21","49.5"],"的联合类型":["9.21","49.5"],"取交叉部分就只剩下":["9.21","49.5"],"了":["9.21","11.9","49.5"],"就像前面所说":["9.21","49.5"],"交叉类型会把同一类型做合并":["9.21","49.5"],"不同类型舍弃":["9.21","49.5"],"true":["9.23","11.3","34.19","47.3"],"false":["9.23"],"y":["9.24"],"这两个泛型函数类型是否相等":["9.24"],"原理":["9.24"],"联合类型":["9.26"],"在作为条件类型的类型参数时的这些特殊情况":["9.26"],"也会在后面的原理篇来解释原因":["9.26"],"利用":["9.28"],"做为参数构造个函数":["9.28"],"通过模式匹配取参数的类型":["9.28"],"结果就是交叉类型":["9.28"],"函数参数的逆变性质一般就联合类型转交叉类型会用":["9.28"],"记住就行":["9.28"],"就能过滤出可选索引":["9.29"],"值的类型依然是之前的":["9.29"],"这样":["9.29"],"就能过滤出所有可选索引":["9.29"],"构造成新的索引类型":["9.29"],"可以推导出字面量类型":["9.30"],"但带有":["9.30"],"readonly":["9.30"],"修饰":["9.30"],"这样模式匹配的时候也得加上":["9.30"],"才行":["9.30"],"对类型参数做匹配":["10.0"],"结果保存到通过":["10.0"],"声明的局部类型变量里":["10.0"],"如果匹配就能从该局部变量里拿到提取出的类型":["10.0"],"这个模式匹配的套路有多有用呢":["10.0"],"我们来看下在数组":["10.0"],"字符串":["10.0"],"函数":["10.0"],"构造器等类型里的应用":["10.0"],"getfirstresult":["10.2"],"匹配一个模式类型":["10.13"],"提取":["10.13"],"的类型到":["10.13"],"声明的局部变量":["10.13"],"thistype":["10.13"],"中":["10.13","35.4"],"其余的参数是任意类型":["10.13"],"也就是":["10.13"],"any":["10.13","47.0"],"返回值也是任意类型":["10.13"],"返回提取到的":["10.13"],"这样就能提取出":["10.13"],"getinstancetyperesult":["10.15"],"为":["10.17","11.15"],"时":["10.17","35.5"],"设计可以做类型编程的类型系统的目的就是为了产生各种复杂的类型":["11.0"],"那不能修改怎么产生新类型呢":["11.0"],"答案是重新构造":["11.0"],"这就涉及到了第二个类型体操套路":["11.0"],"而元组则是数量固定":["11.3"],"类型可以不同的元素构成的":["11.3"],"name":["11.3","48.0"],"three":["11.5"],"four":["11.5"],"five":["11.5"],"了解了数组类型的重新构造":["11.5"],"我们再来看下字符串类型的":["11.5"],"构造成新的字符串类型返回":["11.7","48.1"],"这就是字符串类型的重新构造":["11.7"],"从已有的字符串类型中提取出一些部分字符串":["11.7"],"经过一系列变换":["11.7"],"构造成新的字符串类型":["11.7"],"构造成新的字符串":["11.8"],"剩余的字符":["11.8"],"要继续递归的处理":["11.8"],"这样就完成了从下划线到驼峰形式的转换":["11.8"],"直到不再匹配":["11.9"],"也就是没有":["11.9"],"字符串类型的重新构造之后":["11.9"],"我们再来看下函数类型的重新构造":["11.9"],"构造成新的函数类型返回":["11.11"],"这样就完成了函数类型的修改":["11.11"],"最后":["11.11"],"我们再来看下索引类型的重新构造":["11.11"],"keyof":["11.12"],"保持不变":["11.14"],"也就是之前的索引":["11.14"],"对应的值的类型":["11.14"],"这样构造出的新的索引类型":["11.14"],"就把原来索引类型的索引转为了大写":["11.14"],"值为任意类型的索引类型":["11.15"],"值依然为原来的值":["11.16"],"其余保持不变":["11.17","11.18","11.19"],"值保持不变":["11.20"],"依然为原来索引的值":["11.20"],"这样就达到了过滤索引类型的索引":["11.20"],"产生新的索引类型的目的":["11.20"],"对象等类型":["12.0"],"那么我们就来看一下这些类型的递归案例吧":["12.0"],"不再约束类型参数必须是":["12.2"],"这样就可以少一层判断":["12.2"],"接下来再看下数组类型的递归复用":["12.2"],"用":["12.4","12.10"],"作为最后一个元素构造新数组":["12.4"],"其余元素递归的取":["12.4"],"结束条件就是取完所有的元素":["12.4"],"也就是不再满足模式匹配的条件":["12.4"],"这时候就返回":["12.4"],"是":["12.5"],"的子类型并且":["12.5"],"也是":["12.5"],"的子类型":["12.5"],"这样就完成了不确定长度的数组中的元素查找":["12.5"],"用递归实现了循环":["12.5"],"也就是再构造一个新的数组":["12.6"],"直到模式匹配不再满足":["12.6"],"也就是处理完了所有的元素":["12.6"],"返回这时候的":["12.6"],"这样我们就完成了不确定元素个数的数组的某个元素的删除":["12.6"],"否则在":["12.7"],"上加一个元素":["12.7"],"然后递归构造":["12.7"],"学完了数组类型的递归":["12.7"],"我们再来看下字符串类型":["12.7"],"构造新的字符串":["12.9"],"剩余的":["12.9"],"部分继续递归的替换":["12.9"],"结束条件是不再满足模式匹配":["12.9"],"也就是没有要替换的元素":["12.9"],"这时就直接返回字符串":["12.9"],"这样就实现了任意数量的字符串替换":["12.9"],"其余的字符放到局部变量":["12.10"],"构造联合类型":["12.10"],"剩余的元素递归的取":["12.10"],"这样就完成了不确定长度的字符串的提取和联合类型的构造":["12.10"],"那么不断往前插就是把右边的放到了左边":["12.11"],"完成了反转的效果":["12.11"],"直到模式匹配不满足":["12.11"],"就处理完了所有的字符":["12.11"],"这样就完成了字符串的反转":["12.11"],"字符串那样元素之间是有关系的":["13.0"],"所以设计成了每一个单独处理":["13.0"],"知道了":["13.0"],"怎么处理的联合类型":["13.0"],"趁热打铁来练习一下":["13.0"],"这不和单个字符串的处理没区别么":["13.1"],"没错":["13.1"],"对联合类型的处理和对单个类型的处理没什么区别":["13.1"],"会把每个单独的类型拆开传入":["13.1"],"不需要像数组类型那样需要递归提取每个元素做处理":["13.1"],"确实简化了很多":["13.1"],"好像都是优点":["13.1"],"也不全是":["13.1"],"其实这样处理也增加了一些认知成本":["13.1"],"不信我们再来看个例子":["13.1"],"这种写法是为了触发分布式条件类型":["13.2"],"让每个类型单独传入处理的":["13.2"],"没别的意义":["13.2"],"是不同的处理":["13.2"],"前者是单个类型和整个类型做判断":["13.2"],"后者两边都是整个联合类型":["13.2"],"因为只有":["13.2"],"左边直接是类型参数才会触发分布式条件类型":["13.2"],"理解了这两点":["13.2"],"分布式条件类型就算掌握了":["13.2"],"可以看到":["13.3"],"用好了联合类型":["13.3"],"确实能简化类型编程逻辑":["13.3"],"以后的所有组合就是":["13.4"],"所以全组合就是":["13.4"],"的特性确实能简化类型编程":["13.5"],"但是也增加了认知成本":["13.5"],"不过这也是不可避免的事":["13.5"],"的节点的两倍加上分支度为":["14.0"],"二叉树的类型":["14.0"],"则这棵二叉树称为完全二叉树":["14.2"],"树要低":["14.7"],"空间使用率更高":["14.7"],"百度百科满二叉树":["14.18"],"render":["15.0"],"架构图":["15.0"],"对象才会发生状态变更":["18.0"],"as":["18.1"],"可为空":["18.2"],"否":["18.3","19.3"],"object":["18.3"],"default":["19.1"],"number":["19.3","41.4"],"分":["21.0"],"等":["21.0"],"padstart":["21.1"],"string":["21.3"],"return":["22.3","25.3","27.3","31.3","34.4","34.6"],"push":["23.2"],"concat":["23.2","30.3"],"而不基于比较的排序算法可以突破这一下界":["24.0"],"减去":["24.1"],"while":["24.3"],"计数排序是一个很有效的排序算法":["24.4"],"不断重复此过程直到有序区的元素个数为":["25.1"],"则整个排序过程完成":["25.1"],"升序用大根堆":["25.1"],"降序用小根堆":["25.1"],"list":["25.3"],"操作次数呈现什么规律":["26.0"],"空间复杂度":["26.0"],"是指算法在计算机内执行时所需存储空间的度量":["26.0"],"它也是数据规模":["26.0"],"的函数":["26.0"],"找到相应位置并插入":["27.0"],"路归并":["28.0"],"recursive":["29.1"],"把小于基准值元素的子数列和大于基准值元素的子数列排序":["29.1"],"quick":["29.3"],"length":["29.3"],"同时能利用计数排序适用于小范围数的特点":["30.0"],"count":["30.3"],"因此额外空间需要大概":["30.4"],"个左右":["30.4"],"直到所有元素均排序完毕":["31.0"],"个的新无序区":["31.1"],"趟结束":["31.1"],"数组有序化了":["31.1"],"希尔排序又叫缩小增量排序":["32.0"],"整个序列作为一个表来处理":["32.1"],"表长度即为整个序列的长度":["32.1"],"文字文字文字":["34.3"],"使用函数":["34.4"],"log":["34.5"],"sort":["34.5"],"datasomething":["34.9"],"something":["34.9"],"click":["34.14","34.15"],"send":["34.14"],"removechild":["34.15"],"null":["34.21"],"能够保证在不同系统上无差异的工作":["35.2"],"json":["35.4"],"scripts":["35.4"],"属性下定义的脚本":["35.4"],"显示某个包的信息":["35.4"],"可以用来查看某个模块的最新版本信息":["35.4"],"info":["35.4"],"缓存":["35.4"],"cache":["35.4"],"列出已缓存的每个包":["35.4"],"返回":["35.4"],"全局缓存位置":["35.4"],"dir":["35.4"],"清除缓存":["35.4"],"clean":["35.4"],"add":["35.5"],"会自动更新":["35.5"],"tiaiaxrw6donawtzzcoenbpnutuobwmeilax1hy0zqjemhj3hnvgcbbhy6jtamoeijb0z29vl6ls58vxpco8":["38.4"],"zfrdo5qvko":["38.4"],"d3fx8wu8zf1dw4p":["38.4"],"cpzlly":["38.4"],"dtv9ts":["38.4"],"ebcvgahhhyfbihz6nsiibto0lnntscabfyniqfcbchulmnnsdahjynsiecrcjubepncrahz6nsiaarcjxbuhmcrmjzqbqiqircztbunaarcjyqhqgqovczdtunqiscjuohakqo1gxdzqkqiwejuogaeqo121bzakti2aguikceqs021jwaexi2kouiekfqsw01j0ceni1kiqjeknrsq80jecfno1kiabekndtqcwjeynmofcjahelnntscabfyniqfcbchulmnnsdahjynsiecrcjubepncrahz6nsiaarcjxbuhmcrmjzqbqiqircztbunaarcjyqhqgqovczdtunqiscjuohakqo1gxdzqkqiwejuogaeqo121bzakti2aguikceqs021jwaexi2kouiekfqsw01j0ceni1kiqjeknrsq80jecfno1kiabekndtqcwjeynmofcjahelnntscabfyniqfcbchulmnnsdahjynsiecrcjubepncrahz6nsiaarcjxbuhmcrmjzqbqiqircztbunaarcjyqhqgqovczdtunqiscjuohakqo1gxdzqkqiwejuogaeqo121bzakti2aguikceqs021jwaexi2kouiekfqsw01j0ceni1kiqjeknrsq80jecfno1kiabekndtqcwjeynmofcjahelnntscabfyniqfcbchulmnnsdahjynsiec":["38.4"],"wggkkc4yma4taaaaabjru5erkjggg":["38.4"],"搭建":["39.1"],"所有组件实例均可交互":["39.1"],"formats":["39.2"],"esm":["39.2"],"git":["39.2"],"tree":["39.2"],"main":["39.2"],"packages":["39.2"],"www":["39.2"],"npmjs":["39.2"],"package":["39.2"],"iife":["39.3"],"cjs":["39.3"],"html":["39.3"],"intrinsicelements":["39.9"],"detailedhtmlprops":["39.9"],"htmlattributes":["39.9"],"tabs":["39.10"],"home":["39.10"],"tab1":["39.10"],"tab2":["39.10"],"tab3":["39.10"],"use":["39.12"],"检测兼容性":["39.12"],"api":["39.12"],"网站":["39.12"],"addeventlistener":["40.14"],"change":["40.14"],"事件的":["40.15"],"参数结构":["40.15"],"input方法":["40.15"],"自动关闭的延时":["41.4"],"单位毫秒":["41.4"],"默认":["41.4"],"void":["41.4"],"xml":["44.1"],"unknown":["47.0"],"error":["47.3"],"声明要替换的字符串":["48.1"],"待替换的字符串":["48.1"],"from":["48.1"],"替换成的字符串":["48.1"],"个类型参数":["48.1"],"约束为都是":["48.1"],"类型":["48.1"],"去匹配模式串":["48.1"],"模式串由":["48.1"],"和之前之后的字符串构成":["48.1"],"把之前之后的字符串放到通过":["48.1"],"suffix":["48.1"],"加上替换到的字符串":["48.1"],"返回提取到的参数类型":["48.4"],"这里的解释涉及到参数的逆变性质":["48.5"],"具体原因逆变那一节会解释":["48.5"],"infer":["48.8"],"t":["48.8"],"也就是约束类型参数只能是数组类型":["49.2"],"因为不知道数组元素的具体类型":["49.2"],"所以用":["49.2"],"处理对象比较多":["49.5"],"所以索引类型的映射比较重要":["49.5"],"capitalize":["50.21"],"uncapitalize":["50.21"]}]'},e={"1.0":{t:"# Abstract Syntax Tree",p:"",l:"src/article/astParse/tokenizer.html",a:"abstract-syntax-tree"},"1.1":{t:"一.（`abstract syntax tree`）抽象语法树的作用",p:"源码是一串按照语法格式来组织的字符串，人能够认识，但是计算机并不认识，想让计算机认识就要转成一种数据结构，通过不同的对象来保 ...",l:"src/article/astParse/tokenizer.html#一-abstract-syntax-tree-抽象语法树的作用",a:"一-abstract-syntax-tree-抽象语法树的作用"},"1.2":{t:"二.常见的 AST 节点",p:`常见的 AST 节点
AST 是对源码的抽象，字面量、标识符、表达式、语句、模块语法、class 语法都有各自的 AST。
 ...`,l:"src/article/astParse/tokenizer.html#二-常见的-ast-节点",a:"二-常见的-ast-节点"},"1.3":{t:"Literal",p:"Literal 是字面量的意思，比如 let name = 'value'中，'value'就是一个字符串字面量 Strin ...",l:"src/article/astParse/tokenizer.html#literal",a:"literal"},"1.4":{t:"Identifier",p:`Identifer 是标识符的意思，变量名、属性名、参数名等各种声明和引用的名字，都是Identifer。
我们知道， JS ...`,l:"src/article/astParse/tokenizer.html#identifier",a:"identifier"},"1.5":{t:"Statement",p:"statement 是语句，它是可以独立执行的单位，比如 break、continue、debugger、return 或者 ...",l:"src/article/astParse/tokenizer.html#statement",a:"statement"},"1.6":{t:"Declaration",p:`声明语句是一种特殊的语句，它执行的逻辑是在作用域内声明一个变量、函数、 class、import、export 等。
比如下 ...`,l:"src/article/astParse/tokenizer.html#declaration",a:"declaration"},"1.7":{t:"Expression",p:`expression 是表达式，特点是执行完以后有返回值，这是和语句 (statement) 的区别。
下面是一些常见的表达 ...`,l:"src/article/astParse/tokenizer.html#expression",a:"expression"},"1.8":{t:"Class",p:`class 的语法也有专门的 AST 节点来表示。
整个 class 的内容是 ClassBody ，属性是 ClassPr ...`,l:"src/article/astParse/tokenizer.html#class",a:"class"},"1.9":{t:"Modules",p:`es module 是语法级别的模块规范，所以也有专门的 AST 节点。
import
import 有 3 种语法：
na ...`,l:"src/article/astParse/tokenizer.html#modules",a:"modules"},"1.10":{t:"Program & Directive",p:"program 是代表整个程序的节点，它有 body 属性代表程序体，存放 statement 数组，就是具体执行的语句的集 ...",l:"src/article/astParse/tokenizer.html#program-directive",a:"program-directive"},"1.11":{t:"File & Comment",p:"babel 的 AST 最外层节点是 File ，它有 program 、 comments 、 tokens 等属性，分别 ...",l:"src/article/astParse/tokenizer.html#file-comment",a:"file-comment"},"1.12":{t:"`AST` 可视化查看工具",p:`这么多 AST 我们都要记住么？
不需要。可以通过 axtexplorer.net 这个网站来可视化的查看。
!
这个网站可 ...`,l:"src/article/astParse/tokenizer.html#ast-可视化查看工具",a:"ast-可视化查看工具"},"1.13":{t:"AST 的公共属性",p:`每种 AST 都有自己的属性，但是它们也有一些公共的属性：
type： AST 节点的类型
start 、 end 、loc ...`,l:"src/article/astParse/tokenizer.html#ast-的公共属性",a:"ast-的公共属性"},"1.14":{t:"总结",p:`了解了这些节点，就能知道平时写的代码是怎么用 AST 表示的。
当然也不需要记，可以用 (astexpoler.net) 可 ...`,l:"src/article/astParse/tokenizer.html#总结",a:"总结"},"1.15":{t:"三.编写词法分析器（Tokenizer）",p:"词法分析器，也叫分词器(Tokenizer)，它的作用是将代码划分为一个个词法单元，便于进行后续的语法分析。比如下面的这段代 ...",l:"src/article/astParse/tokenizer.html#三-编写词法分析器-tokenizer",a:"三-编写词法分析器-tokenizer"},"1.16":{t:"1. 确定 Token 的类型和规则",p:`增加 Token 的类型
export enum TokenType {
  // let
  Let = 'Let',
  ...`,l:"src/article/astParse/tokenizer.html#_1-确定-token-的类型和规则",a:"_1-确定-token-的类型和规则"},"1.17":{t:"2.代码字符扫描",p:`在扫描字符的过程，我们需要对不同的字符各自进行不同的处理，具体的策略如下：

当前字符为分隔符，如空格，直接跳过，不处理；
 ...`,l:"src/article/astParse/tokenizer.html#_2-代码字符扫描",a:"_2-代码字符扫描"},"1.18":{t:"四.编写语法分析器（Parser）",p:"在解析出词法 token 之后，我们就可以进入语法分析阶段了。在这个阶段，我们会依次遍历 token ，对代码进行语法结构层 ...",l:"src/article/astParse/tokenizer.html#四-编写语法分析器-parser",a:"四-编写语法分析器-parser"},"2.0":{t:"# Babel",p:`babel 核心库主要是：

@babel/parser 对源码进行 parse，可以通过 plugins、sourceTy ...`,l:"src/article/babel.html",a:"babel"},"3.0":{t:"# Bundle",p:"Bundle 的本质就是输入，转换，输出。在机器上直接运行的代码，往往都难以维护和理解，我们需要将开发者方便理解和维护的代码 ...",l:"src/article/bundle.html",a:"bundle"},"4.0":{t:"# 23 种经典设计模式",p:`
设计模式 Design Pattern 是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结，使用设计模式是 ...`,l:"src/article/designMode.html",a:"_23-种经典设计模式"},"4.1":{t:"一、UML 类图",p:"每个模式都有相应的对象结构图，同时为了展示对象间的交互细节， 有些时候会用到 UML 图来介绍其如何运行。这里不会将 UML ...",l:"src/article/designMode.html#一、uml-类图",a:"一、uml-类图"},"4.2":{t:"1.1 继承",p:`继承用一条带空心箭头的直接表示。
!
`,l:"src/article/designMode.html#_1-1-继承",a:"_1-1-继承"},"4.3":{t:"1.2 实现",p:`实现关系用一条带空心箭头的虚线表示。
!
`,l:"src/article/designMode.html#_1-2-实现",a:"_1-2-实现"},"4.4":{t:"1.3 组合",p:"与聚合关系一样，组合关系同样表示整体由部分构成的语义。比如公司由多个部门组成，但组合关系是一种强依赖的特殊聚合关系，如果整体 ...",l:"src/article/designMode.html#_1-3-组合",a:"_1-3-组合"},"4.5":{t:"1.4 聚合",p:"聚合关系用于表示实体对象之间的关系，表示整体由部分构成的语义，例如一个部门由多个员工组成。与组合关系不同的是，整体和部分不是 ...",l:"src/article/designMode.html#_1-4-聚合",a:"_1-4-聚合"},"4.6":{t:"1.5 关联",p:"关联关系是用一条直线表示的，它描述不同类的对象之间的结构关系，它是一种静态关系， 通常与运行状态无关，一般由常识等因素决定的 ...",l:"src/article/designMode.html#_1-5-关联",a:"_1-5-关联"},"4.7":{t:"1.6 依赖",p:`依赖关系是用一套带箭头的虚线表示的，如 A 依赖于 B，他描述一个对象在运行期间会用到另一个对象的关系。
与关联关系不同的是 ...`,l:"src/article/designMode.html#_1-6-依赖",a:"_1-6-依赖"},"4.8":{t:"二、六大原则",p:"",l:"src/article/designMode.html#二、六大原则",a:"二、六大原则"},"4.9":{t:"2.1 开闭原则",p:`
一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。

任何软件都需要面临一个很重要 ...`,l:"src/article/designMode.html#_2-1-开闭原则",a:"_2-1-开闭原则"},"4.10":{t:"2.2 里氏替换原则",p:`
所有引用基类对象的地方能够透明地使用其子类的对象

里氏代换原则告诉我们，在软件中将一个基类对象替换成它的子类对象，程序将 ...`,l:"src/article/designMode.html#_2-2-里氏替换原则",a:"_2-2-里氏替换原则"},"4.11":{t:"2.3 依赖倒置原则",p:`
抽象不应该依赖于具体类，具体类应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。

依赖倒转原则要求我们在程序代 ...`,l:"src/article/designMode.html#_2-3-依赖倒置原则",a:"_2-3-依赖倒置原则"},"4.12":{t:"2.4 单一职责原则",p:`
一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。

单一职责原则告诉我们 ...`,l:"src/article/designMode.html#_2-4-单一职责原则",a:"_2-4-单一职责原则"},"4.13":{t:"2.5 迪米特法则（最少知道原则）",p:`
一个软件实体应当尽可能少地与其他实体发生相互作用

如果一个系统符合迪米特法则，那么当其中某一个模块发生修改时，就会尽量少 ...`,l:"src/article/designMode.html#_2-5-迪米特法则-最少知道原则",a:"_2-5-迪米特法则-最少知道原则"},"4.14":{t:"2.6 接口分离原则",p:`
使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。

根据接口隔离原则，当一个接口太大时，我 ...`,l:"src/article/designMode.html#_2-6-接口分离原则",a:"_2-6-接口分离原则"},"4.15":{t:"2.7 合成复用原则（六大之外的）",p:`
尽量使用对象组合，而不是继承来达到复用的目的

合成复用原则就是在一个新的对象里通过关联关系（包括组合关系和聚合关系）来使 ...`,l:"src/article/designMode.html#_2-7-合成复用原则-六大之外的",a:"_2-7-合成复用原则-六大之外的"},"4.16":{t:"2.8 六大原则 - 学习心得",p:"六大原则中，开闭原则、里氏替换原则、依赖倒置原则 联系比较紧密，后两者是实现开闭原则重要前提，使用中通过抽象化设计具有很好的 ...",l:"src/article/designMode.html#_2-8-六大原则-学习心得",a:"_2-8-六大原则-学习心得"},"4.17":{t:"三、模式分类",p:"《设计模式：可复用面向对象软件的基础》一书中设计模式有 23 个，它们各具特色，每个模式都为某一个可重复的设计问题提供了一套 ...",l:"src/article/designMode.html#三、模式分类",a:"三、模式分类"},"4.18":{t:"3.1 创建型",p:"创建型模式(Creational Pattern)对类的实例化过程进行了抽象，能够将模块中对象的创建和对象的使用分离。为了使 ...",l:"src/article/designMode.html#_3-1-创建型",a:"_3-1-创建型"},"4.19":{t:"3.2 结构型",p:"结构型模式(Structural Pattern)描述如何将类或者对 象结合在一起形成更大的结构，就像搭积木，可以通过 简单 ...",l:"src/article/designMode.html#_3-2-结构型",a:"_3-2-结构型"},"4.20":{t:"3.3 行为型",p:"行为型模式(Behavioral Pattern)是对在不同的对象之间划分责任和算法的抽象化。行为型模式不仅仅关注类和对象的 ...",l:"src/article/designMode.html#_3-3-行为型",a:"_3-3-行为型"},"4.21":{t:"四、创建型",p:"",l:"src/article/designMode.html#四、创建型",a:"四、创建型"},"4.22":{t:"4.1 简单工厂模式",p:`
简单工厂模式(Simple Factory Pattern)：专门定义一个类（工厂类）来负责创建其他类的实例。可以根据创建 ...`,l:"src/article/designMode.html#_4-1-简单工厂模式",a:"_4-1-简单工厂模式"},"4.23":{t:"4.2 工厂方法模式",p:`
工厂方法模式(Factory Method Pattern)又称为工厂模式，工厂父类负责定义创建产品对象的公共接口，而工厂 ...`,l:"src/article/designMode.html#_4-2-工厂方法模式",a:"_4-2-工厂方法模式"},"4.24":{t:"4.3 抽象工厂模式",p:`抽象工厂模式并不直接生成实例， 而是用于对产品类簇的创建。

抽象工厂模式(Abstract Factory Pattern ...`,l:"src/article/designMode.html#_4-3-抽象工厂模式",a:"_4-3-抽象工厂模式"},"4.25":{t:"4.4 单例模式",p:`
单例模式(Singleton Pattern)：单例模式确保某一个类只有一个实例，并提供一个访问它的全剧访问点。

!
举 ...`,l:"src/article/designMode.html#_4-4-单例模式",a:"_4-4-单例模式"},"4.26":{t:"4.5 生成器模式",p:`
生成器模式(Builder Pattern)：也叫创建者模式，它将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以 ...`,l:"src/article/designMode.html#_4-5-生成器模式",a:"_4-5-生成器模式"},"4.27":{t:"4.6 原型模式",p:`
原型模式（Prototype Pattern）: 用原型实例指向创建对象的类，使用于创建新的对象的类的共享原型的属性与方法 ...`,l:"src/article/designMode.html#_4-6-原型模式",a:"_4-6-原型模式"},"4.28":{t:"五、结构型",p:"",l:"src/article/designMode.html#五、结构型",a:"五、结构型"},"4.29":{t:"5.1 装饰模式",p:`
装饰模式(Decorator Pattern) ：向一个现有的对象添加新的功能，同时又不改变其结构的设计模式被称为装饰器模 ...`,l:"src/article/designMode.html#_5-1-装饰模式",a:"_5-1-装饰模式"},"4.30":{t:"5.2 外观模式",p:`
外观模式(Facade Pattern)：外观模式定义了一个高层接口，为子系统中的一组接口提供一个统一的接口。使得子系统更 ...`,l:"src/article/designMode.html#_5-2-外观模式",a:"_5-2-外观模式"},"4.31":{t:"5.3 代理模式",p:`
代理模式(Proxy Pattern) ：为某个对象提供一个代理，并由这个代理对象控制对原对象的访问。

!
举例：
代理 ...`,l:"src/article/designMode.html#_5-3-代理模式",a:"_5-3-代理模式"},"4.32":{t:"5.4 享元模式",p:`
享元模式(Flyweight Pattern)：享元模式是一种优化程序性能的模式, 本质为减少对象创建的个数。运用共享技术 ...`,l:"src/article/designMode.html#_5-4-享元模式",a:"_5-4-享元模式"},"4.33":{t:"5.5 桥接模式",p:`
桥接模式(Simple Factory Pattern)：将抽象部分与它的实现部分分离,使它们都可以独立地变化。

!
举 ...`,l:"src/article/designMode.html#_5-5-桥接模式",a:"_5-5-桥接模式"},"4.34":{t:"5.6 适配器模式",p:`
适配器模式(Adapter Pattern) ：适配器模式是用来解决两个接口不兼容的情况，不需要改变已有的接口，通过包装一 ...`,l:"src/article/designMode.html#_5-6-适配器模式",a:"_5-6-适配器模式"},"4.35":{t:"六、行为型",p:"",l:"src/article/designMode.html#六、行为型",a:"六、行为型"},"4.36":{t:"6.1 职责链模式",p:`
职责链模式(Chain of Responsibility Pattern)：避免请求发送者与接收者耦合在一起，让多个对象 ...`,l:"src/article/designMode.html#_6-1-职责链模式",a:"_6-1-职责链模式"},"4.37":{t:"6.2 命令模式",p:`
命令模式(Command Pattern)：将一个请求封装为一个对象，从而让我们可用不同的请求对客户进行参数化；命令模式是 ...`,l:"src/article/designMode.html#_6-2-命令模式",a:"_6-2-命令模式"},"4.38":{t:"6.3 解释器模式",p:`
解释器模式(Interpreter Pattern)：定义一个语言的文法，并且建立一个解释器来解释该语言中的句子，这里的“ ...`,l:"src/article/designMode.html#_6-3-解释器模式",a:"_6-3-解释器模式"},"4.39":{t:"6.4 迭代器模式",p:`
迭代器模式(Iterator Pattern)：一个相对简单的模式，目前绝大多数语言都内置了迭代器，以至于大家都不觉得这是 ...`,l:"src/article/designMode.html#_6-4-迭代器模式",a:"_6-4-迭代器模式"},"4.40":{t:"6.5 中介者模式",p:`
中介者模式(Mediator Pattern)：对象和对象之间借助第三方中介者进行通信。用一个中介对象（中介者）来封装一系 ...`,l:"src/article/designMode.html#_6-5-中介者模式",a:"_6-5-中介者模式"},"4.41":{t:"6.6 备忘录模式",p:`
备忘录模式(Memento Pattern)：在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以 ...`,l:"src/article/designMode.html#_6-6-备忘录模式",a:"_6-6-备忘录模式"},"4.42":{t:"6.7 观察者模式",p:`
观察者模式(Observer Pattern)：定义对象之间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依 ...`,l:"src/article/designMode.html#_6-7-观察者模式",a:"_6-7-观察者模式"},"4.43":{t:"6.8 状态模式",p:`
状态模式(State Pattern)：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。其别名为状 ...`,l:"src/article/designMode.html#_6-8-状态模式",a:"_6-8-状态模式"},"4.44":{t:"6.9 策略模式",p:`
策略模式(Strategy Pattern)：定义一些列算法，把他们封装起来，并且可以相互替换。就是把看似毫无联系的代码提 ...`,l:"src/article/designMode.html#_6-9-策略模式",a:"_6-9-策略模式"},"4.45":{t:"6.10 模板方法模式",p:`
模板方法模式：定义一个操作中算法的框架，而将一些步骤延迟到子类中。模板方法模式使得子类可以不改变一个算法的结构即可重定义该 ...`,l:"src/article/designMode.html#_6-10-模板方法模式",a:"_6-10-模板方法模式"},"4.46":{t:"6.11 访问者模式",p:`
访问者模式(Visitor Pattern):提供一个作用于某对象结构中的各元素的操作表示，它使我们可以在不改变各元素的类 ...`,l:"src/article/designMode.html#_6-11-访问者模式",a:"_6-11-访问者模式"},"4.47":{t:"总结",p:"系统地学习设计模式后，你可以在过往的开发经历中发现，设计模式是无处不在的。在学习设计模式之前的很多时候我们是凭借过往经验和智 ...",l:"src/article/designMode.html#总结",a:"总结"},"4.48":{t:"参考资料",p:`
Study-Plan
javaScript 设计模式统计
ES6 系列之我们来聊聊装饰器
设计模式之生成器模式
https ...`,l:"src/article/designMode.html#参考资料",a:"参考资料"},"5.0":{t:"# 函数式编程",p:`
概述： 函数式编程(Functional Programming)FP就是编程规范之一，我们常听说的编程规范还有面向对象编 ...`,l:"src/article/functionalProgramming.html",a:"函数式编程"},"5.1":{t:"一. `JS`函数基本知识",p:`
函数可以储存在变量中
函数可以作为参数
函数可以作为返回值

在JavaScript中，函数就是一个普通的对象，(可以通过 ...`,l:"src/article/functionalProgramming.html#一-js-函数基本知识",a:"一-js-函数基本知识"},"5.2":{t:"二.高阶函数",p:`
高阶函数(Higher-order function)

可以把函数作为参数传递给另一个函数
可以把函数作为另一个函数的返 ...`,l:"src/article/functionalProgramming.html#二-高阶函数",a:"二-高阶函数"},"5.3":{t:"三.闭包",p:`概述:有权访问另一个函数作用域中的变量的函数
本质:函数执行的时候会入栈，当执行完后会移除栈，但是堆上的作用域成员因为被外部 ...`,l:"src/article/functionalProgramming.html#三-闭包",a:"三-闭包"},"5.4":{t:"四. 纯函数",p:`
概念：相同的输入永远会得到相同的输出，而且没有任何可观察的副作用，类似数学中的函数y=f(x)
例子：slice函数就是纯 ...`,l:"src/article/functionalProgramming.html#四-纯函数",a:"四-纯函数"},"5.5":{t:"五.柯里化(`Haskell Brooks Curry`)",p:`//解决上述硬编码的问题
function checkAge(min) {
  return function (age)  ...`,l:"src/article/functionalProgramming.html#五-柯里化-haskell-brooks-curry",a:"五-柯里化-haskell-brooks-curry"},"5.6":{t:"六.函数的组合",p:`
纯函数和柯里化很容易让我们写出洋葱代码，比如h(f(g(x)))

获取数组的最后一个元素并转化为大写字母，_.toUpp ...`,l:"src/article/functionalProgramming.html#六-函数的组合",a:"六-函数的组合"},"5.7":{t:"七.Point Free",p:"我们可以把数据处理的过程定义成与数据无关的合成运算，不需要用到代表数据的那个参数，只要把简单的运算步骤合成到一起，在使用这种 ...",l:"src/article/functionalProgramming.html#七-point-free",a:"七-point-free"},"5.8":{t:"八.`functor`(函子)",p:`
为什么要了解函子&lt;br /&gt;目前没有解决如何在函数式编程中，把副作用控制在可控的范围内，异常处理，异步操作等等 ...`,l:"src/article/functionalProgramming.html#八-functor-函子",a:"八-functor-函子"},"5.9":{t:"参考资料",p:`
函数式编程与异步编程
函数式编程初探
函数式编程入门教程

`,l:"src/article/functionalProgramming.html#参考资料",a:"参考资料"},"6.0":{t:"# imagemin 图片压缩源码分析",p:"",l:"src/article/imagemin.html",a:"imagemin-图片压缩源码分析"},"7.0":{t:"# 页面加载完成后事件",p:"",l:"src/article/javascript/domLoad.html",a:"页面加载完成后事件"},"7.1":{t:"window.onload",p:"",l:"src/article/javascript/domLoad.html#window-onload",a:"window-onload"},"7.2":{t:"DOMContentLoaded",p:`document.addEventListener('DOMContentLoaded', fun)

`,l:"src/article/javascript/domLoad.html#domcontentloaded",a:"domcontentloaded"},"7.3":{t:'`<body onload="fun()">`',p:"",l:"src/article/javascript/domLoad.html#body-onload-fun",a:"body-onload-fun"},"7.4":{t:"readyState",p:`document.readyState

document.onreadystatechange

一个文档的 readyS ...`,l:"src/article/javascript/domLoad.html#readystate",a:"readystate"},"8.0":{t:"# 数组长度做计数",p:`类型系统不是图灵完备，各种逻辑都能写么，但好像没发现数值相关的逻辑。
没错，数值相关的逻辑比较绕，被我单独摘了出来，就是这节 ...`,l:"src/article/typescript/calculate.html",a:"数组长度做计数"},"8.1":{t:"数组长度实现加减乘除",p:"",l:"src/article/typescript/calculate.html#数组长度实现加减乘除",a:"数组长度实现加减乘除"},"8.2":{t:"Add",p:`我们知道了数值计算要转换为对数组类型的操作，那么加法的实现很容易想到：
构造两个数组，然后合并成一个，取 length。
比 ...`,l:"src/article/typescript/calculate.html#add",a:"add"},"8.3":{t:"Subtract",p:`加法是构造数组，那减法怎么做呢？
减法是从数值中去掉一部分，很容易想到可以通过数组类型的提取来做。
比如 3 是 [unkn ...`,l:"src/article/typescript/calculate.html#subtract",a:"subtract"},"8.4":{t:"Multiply",p:`我们把加法转换为了数组构造，把减法转换为了数组提取。那乘法怎么做呢？
为了解释乘法，我去翻了下小学教材，找到了这样一张图：
 ...`,l:"src/article/typescript/calculate.html#multiply",a:"multiply"},"8.5":{t:"Divide",p:`乘法是递归的累加，那除法不就是递归的累减么？
我再去翻了下小学教材，找到了这样一张图：
我们有 9 个苹果，分给美羊羊 3  ...`,l:"src/article/typescript/calculate.html#divide",a:"divide"},"8.6":{t:"数组长度实现计数",p:"",l:"src/article/typescript/calculate.html#数组长度实现计数",a:"数组长度实现计数"},"8.7":{t:"StrLen",p:`数组长度可以取 length 来得到，但是字符串类型不能取 length，所以我们来实现一个求字符串长度的高级类型。
字符串 ...`,l:"src/article/typescript/calculate.html#strlen",a:"strlen"},"8.8":{t:"GreaterThan",p:`能够做计数了，那也就能做两个数值的比较。
我们往一个数组类型中不断放入元素取长度，如果先到了 A，那就是 B 大，否则是 A ...`,l:"src/article/typescript/calculate.html#greaterthan",a:"greaterthan"},"8.9":{t:"Fibonacci",p:`谈到了数值运算，就不得不提起经典的 Fibonacci 数列的计算。
Fibonacci 数列是 1、1、2、3、5、8、1 ...`,l:"src/article/typescript/calculate.html#fibonacci",a:"fibonacci"},"9.0":{t:"# TypeScript 的类型系统",p:"",l:"src/article/typescript/index.html",a:"typescript-的类型系统"},"9.1":{t:"一.类型是什么",p:"类型具体点来说就是指 number、boolean、string 等基础类型和 Object、Function 等复合类型， ...",l:"src/article/typescript/index.html#一-类型是什么",a:"一-类型是什么"},"9.2":{t:"二.类型系统的分类",p:"",l:"src/article/typescript/index.html#二-类型系统的分类",a:"二-类型系统的分类"},"9.3":{t:"1.简单的类型系统",p:`变量、函数、类等都可以声明类型，编译器会基于声明的类型做类型检查，类型不匹配时会报错。
这是最基础的类型系统，能保证类型安全 ...`,l:"src/article/typescript/index.html#_1-简单的类型系统",a:"_1-简单的类型系统"},"9.4":{t:"2.支持泛型的类型系统",p:`泛型的英文是 Generic Type，通用的类型，它可以代表任何一种类型，也叫做类型参数。
它给类型系统增加了一些灵活性， ...`,l:"src/article/typescript/index.html#_2-支持泛型的类型系统",a:"_2-支持泛型的类型系统"},"9.5":{t:"3.支持类型编程的类型系统",p:`在 Java 里面，拿到了对象的类型就能找到它的类，进一步拿到各种信息，所以类型系统支持泛型就足够了。
但是在 JavaSc ...`,l:"src/article/typescript/index.html#_3-支持类型编程的类型系统",a:"_3-支持类型编程的类型系统"},"9.6":{t:"4.类型安全和型变",p:"TypeScript 给 JavaScript 添加了一套静态类型系统，是为了保证类型安全的，也就是保证变量只能赋同类型的值 ...",l:"src/article/typescript/index.html#_4-类型安全和型变",a:"_4-类型安全和型变"},"9.7":{t:"协变（covariant）",p:`对具体成员的输出参数进行一次类型转换，且类型转换的准则是 “里氏替换原则”。
其中协变是很好理解的，比如我们有两个 inte ...`,l:"src/article/typescript/index.html#协变-covariant",a:"协变-covariant"},"9.8":{t:"逆变（contravariant）",p:`是对具体成员的输入参数进行一次类型转换，且类型转换的准则是&quot;里氏替换原则&quot;。
我们有这样两个函数：
le ...`,l:"src/article/typescript/index.html#逆变-contravariant",a:"逆变-contravariant"},"9.9":{t:"不变（invariant）",p:`逆变和协变都是型变，是针对父子类型而言的，非父子类型自然就不会型变，也就是不变：
非父子类型之间不会发生型变，只要类型不一样 ...`,l:"src/article/typescript/index.html#不变-invariant",a:"不变-invariant"},"9.10":{t:"三.TypeScript 类型系统",p:"",l:"src/article/typescript/index.html#三-typescript-类型系统",a:"三-typescript-类型系统"},"9.11":{t:"1.支持的类型",p:"静态类型系统的目的是把类型检查从运行时提前到编译时，那 TS 类型系统中肯定要把 JS 的运行时类型拿过来，也就是 numb ...",l:"src/article/typescript/index.html#_1-支持的类型",a:"_1-支持的类型"},"9.12":{t:"元组",p:`元组（Tuple）就是元素个数和类型固定的数组类型：
type Tuple = [number, string]

`,l:"src/article/typescript/index.html#元组",a:"元组"},"9.13":{t:"接口",p:`接口（Interface）可以描述函数、对象、构造器的结构：
对象：
interface IPerson {
  name: ...`,l:"src/article/typescript/index.html#接口",a:"接口"},"9.14":{t:"枚举",p:`枚举（Enum）是一系列值的复合：
enum Transpiler {
  Babel = 'babel',
  Postc ...`,l:"src/article/typescript/index.html#枚举",a:"枚举"},"9.15":{t:"2.类型的装饰",p:`除了描述类型的结构外，TypeScript 的类型系统还支持描述类型的属性，比如是否可选，是否只读等：
interface  ...`,l:"src/article/typescript/index.html#_2-类型的装饰",a:"_2-类型的装饰"},"9.16":{t:"3.类型运算",p:`我们知道了 TypeScript 类型系统里有哪些类型，那么可以对这些类型做什么类型运算呢？
`,l:"src/article/typescript/index.html#_3-类型运算",a:"_3-类型运算"},"9.17":{t:"条件：extends ?",p:`TypeScript 里的条件判断是 extends ? :，叫做条件类型（Conditional Type）比如：
typ ...`,l:"src/article/typescript/index.html#条件-extends",a:"条件-extends"},"9.18":{t:"推导：infer",p:`如何提取类型的一部分呢？答案是 infer。
比如提取元组类型的第一个元素：
type First&lt;Tuple ext ...`,l:"src/article/typescript/index.html#推导-infer",a:"推导-infer"},"9.19":{t:"联合：｜",p:`联合类型（Union）类似 js 里的或运算符 |，但是作用于类型，代表类型可以是几个类型之一。
type Union =  ...`,l:"src/article/typescript/index.html#联合",a:"联合"},"9.20":{t:"交叉：&",p:`交叉类型（Intersection）类似 js 中的与运算符 &amp;，但是作用于类型，代表对类型做合并。
type Ob ...`,l:"src/article/typescript/index.html#交叉",a:"交叉"},"9.21":{t:"映射类型",p:`对象、class 在 TypeScript 对应的类型是索引类型（Index Type），那么如何对索引类型作修改呢？
答案 ...`,l:"src/article/typescript/index.html#映射类型",a:"映射类型"},"9.22":{t:"四.判断类型的类型",p:"",l:"src/article/typescript/index.html#四-判断类型的类型",a:"四-判断类型的类型"},"9.23":{t:"IsAny",p:`如何判断一个类型是 any 类型呢？要根据它的特性来：
any 类型与任何类型的交叉都是 any，也就是 1 &amp; a ...`,l:"src/article/typescript/index.html#isany",a:"isany"},"9.24":{t:"IsEqual",p:`之前我们实现 IsEqual 是这样写的：
type IsEqual&lt;A, B&gt; = (A extends B  ...`,l:"src/article/typescript/index.html#isequal",a:"isequal"},"9.25":{t:"IsUnion",p:`还记得怎么判断 union 类型么？要根据它遇到条件类型时会分散成单个传入做计算的特性：
type IsUnion&lt;A ...`,l:"src/article/typescript/index.html#isunion",a:"isunion"},"9.26":{t:"IsNever",p:`never 在条件类型中也比较特殊，如果条件类型左边是类型参数，并且传入的是 never，那么直接返回 never：
typ ...`,l:"src/article/typescript/index.html#isnever",a:"isnever"},"9.27":{t:"IsTuple",p:`元组类型怎么判断呢？它和数组有什么区别呢？
元组类型的 length 是数字字面量，而数组的 length 是 number ...`,l:"src/article/typescript/index.html#istuple",a:"istuple"},"9.28":{t:"UnionToIntersection",p:"类型之间是有父子关系的，更具体的那个是子类型，比如 A 和 B 的交叉类型 A &amp; B 就是联合类型 A | B 的 ...",l:"src/article/typescript/index.html#uniontointersection",a:"uniontointersection"},"9.29":{t:"GetOptional",p:`如何提取索引类型中的可选索引呢？
这也要利用可选索引的特性：可选索引的值为 undefined 和值类型的联合类型。
过滤可 ...`,l:"src/article/typescript/index.html#getoptional",a:"getoptional"},"9.30":{t:"总结",p:`
any 类型与任何类型的交叉都是 any，也就是 1 &amp; any 结果是 any，可以用这个特性判断 any 类型 ...`,l:"src/article/typescript/index.html#总结",a:"总结"},"10.0":{t:"# 模式匹配提取",p:`字符串可以和正则做模式匹配，找到匹配的部分，提取子组，之后可以用 1,2 等引用匹配的子组。
'abc'.replace(/ ...`,l:"src/article/typescript/pattern.html",a:"模式匹配提取"},"10.1":{t:"1.数组类型",p:"",l:"src/article/typescript/pattern.html#_1-数组类型",a:"_1-数组类型"},"10.2":{t:"提取第一个元素",p:`数组类型想提取第一个元素的类型怎么做呢？
type arr = [1, 2, 3]

用它来匹配一个模式类型，提取第一个元素 ...`,l:"src/article/typescript/pattern.html#提取第一个元素",a:"提取第一个元素"},"10.3":{t:"提取最后一个元素",p:`可以提取第一个元素，当然也可以提取最后一个元素，修改下模式类型就行：
type GetLastValue&lt;Arr ex ...`,l:"src/article/typescript/pattern.html#提取最后一个元素",a:"提取最后一个元素"},"10.4":{t:"PopArr",p:`我们分别取了首尾元素，当然也可以取剩余的数组，比如取去掉了最后一个元素的数组：
type PopArr&lt;Arr ext ...`,l:"src/article/typescript/pattern.html#poparr",a:"poparr"},"10.5":{t:"ShiftArr",p:`同理可得 ShiftArr 的实现：
type ShiftArr&lt;Arr extends unknown[]&gt;  ...`,l:"src/article/typescript/pattern.html#shiftarr",a:"shiftarr"},"10.6":{t:"2.字符串类型",p:`字符串类型也同样可以做模式匹配，匹配一个模式字符串，把需要提取的部分放到 infer 声明的局部变量里。
`,l:"src/article/typescript/pattern.html#_2-字符串类型",a:"_2-字符串类型"},"10.7":{t:"StartsWith",p:`判断字符串是否以某个前缀开头，也是通过模式匹配：
type StartWith&lt;
  str extends stri ...`,l:"src/article/typescript/pattern.html#startswith",a:"startswith"},"10.8":{t:"Replace",p:`字符串可以匹配一个模式类型，提取想要的部分，自然也可以用这些再构成一个新的类型。
比如实现字符串替换：
type Repla ...`,l:"src/article/typescript/pattern.html#replace",a:"replace"},"10.9":{t:"Trim",p:`能够匹配和替换字符串，那也就能实现去掉空白字符的 Trim：
不过因为我们不知道有多少个空白字符，所以只能一个个匹配和去掉， ...`,l:"src/article/typescript/pattern.html#trim",a:"trim"},"10.10":{t:"3.函数",p:`函数同样也可以做类型匹配，比如提取参数、返回值的类型。
`,l:"src/article/typescript/pattern.html#_3-函数",a:"_3-函数"},"10.11":{t:"GetParameters",p:`函数类型可以通过模式匹配来提取参数的类型：
type GetParameters&lt;Func extends Funct ...`,l:"src/article/typescript/pattern.html#getparameters",a:"getparameters"},"10.12":{t:"GetReturnType",p:`能提取参数类型，同样也可以提取返回值类型：
type GetReturnType&lt;Func extends Funct ...`,l:"src/article/typescript/pattern.html#getreturntype",a:"getreturntype"},"10.13":{t:"GetThisParameterType",p:`方法里可以调用 this，比如这样：
class Dong {
  name: string

  constructor( ...`,l:"src/article/typescript/pattern.html#getthisparametertype",a:"getthisparametertype"},"10.14":{t:"4.构造器类型",p:`构造器和函数的区别是，构造器是用于创建对象的，所以可以被 new。
同样，我们也可以通过模式匹配提取构造器的参数和返回值的类 ...`,l:"src/article/typescript/pattern.html#_4-构造器类型",a:"_4-构造器类型"},"10.15":{t:"GetInstanceType",p:`构造器类型可以用 interface 声明，使用 new(): xx 的语法。
比如：
interface Person { ...`,l:"src/article/typescript/pattern.html#getinstancetype",a:"getinstancetype"},"10.16":{t:"GetConstructorParameters",p:`GetInstanceType 是提取构造器返回值类型，那同样也可以提取构造器的参数类型：
type GetConstruc ...`,l:"src/article/typescript/pattern.html#getconstructorparameters",a:"getconstructorparameters"},"10.17":{t:"索引类型",p:"索引类型也同样可以用模式匹配提取某个索引的值的类型，这个用的也挺多的，比如 React 的 index.d.ts 里的 Pr ...",l:"src/article/typescript/pattern.html#索引类型",a:"索引类型"},"11.0":{t:"# 重新构造做变换",p:`类型编程主要的目的就是对类型做各种转换，那么如何对类型做修改呢？
TypeScript 类型系统支持 3 种可以声明任意类型 ...`,l:"src/article/typescript/reconstruction.html",a:"重新构造做变换"},"11.1":{t:"重新构造",p:"TypeScript 的 type、infer、类型参数声明的变量都不能修改，想对类型做各种变换产生新的类型就需要重新构造。 ...",l:"src/article/typescript/reconstruction.html#重新构造",a:"重新构造"},"11.2":{t:"数组类型的重新构造",p:"",l:"src/article/typescript/reconstruction.html#数组类型的重新构造",a:"数组类型的重新构造"},"11.3":{t:"Push",p:`有这样一个元组类型：
type tuple = [1, 2, 3]

我想给这个元组类型再添加一些类型，怎么做呢？
Type ...`,l:"src/article/typescript/reconstruction.html#push",a:"push"},"11.4":{t:"Unshift",p:`可以在后面添加，同样也可以在前面添加：
type Unshift&lt;Arr extends unknown[], Ele ...`,l:"src/article/typescript/reconstruction.html#unshift",a:"unshift"},"11.5":{t:"Zip",p:`有这样两个元组：
type tuple1 = [1, 2]
type tuple2 = ['name', 'value']
 ...`,l:"src/article/typescript/reconstruction.html#zip",a:"zip"},"11.6":{t:"字符串类型的重新构造",p:"",l:"src/article/typescript/reconstruction.html#字符串类型的重新构造",a:"字符串类型的重新构造"},"11.7":{t:"CapitalizeStr",p:`我们想把一个字符串字面量类型的 'guang' 转为首字母大写的 'Guang'。
需要用到字符串类型的提取和重新构造：
t ...`,l:"src/article/typescript/reconstruction.html#capitalizestr",a:"capitalizestr"},"11.8":{t:"CamelCase",p:`我们再来实现 dong_dong_dong 到 dongDongDong 的变换。
同样是提取和重新构造：
type Cam ...`,l:"src/article/typescript/reconstruction.html#camelcase",a:"camelcase"},"11.9":{t:"DropSubStr",p:`可以修改自然也可以删除，我们再来做一个删除一段字符串的案例：删除字符串中的某个子串
type DropSubStr&lt;
 ...`,l:"src/article/typescript/reconstruction.html#dropsubstr",a:"dropsubstr"},"11.10":{t:"函数类型的重新构造",p:"",l:"src/article/typescript/reconstruction.html#函数类型的重新构造",a:"函数类型的重新构造"},"11.11":{t:"AppendArgument",p:`之前我们分别实现了参数和返回值的提取，那么重新构造就是用这些提取出的类型做下修改，构造一个新的类型即可。
比如在已有的函数类 ...`,l:"src/article/typescript/reconstruction.html#appendargument",a:"appendargument"},"11.12":{t:"索引类型的重新构造",p:`索引类型是聚合多个元素的类型，class、对象等都是索引类型，比如这就是一个索引类型：
type obj = {
  nam ...`,l:"src/article/typescript/reconstruction.html#索引类型的重新构造",a:"索引类型的重新构造"},"11.13":{t:"Mapping",p:`映射的过程中可以对 value 做下修改，比如：
type Mapping&lt;Obj extends object&gt ...`,l:"src/article/typescript/reconstruction.html#mapping",a:"mapping"},"11.14":{t:"UppercaseKey",p:`除了可以对 Value 做修改，也可以对 Key 做修改，使用 as，这叫做重映射：
比如把索引类型的 Key 变为大写。
 ...`,l:"src/article/typescript/reconstruction.html#uppercasekey",a:"uppercasekey"},"11.15":{t:"Record",p:`TypeScript 提供了内置的高级类型 Record 来创建索引类型：
type Record&lt;K extends ...`,l:"src/article/typescript/reconstruction.html#record",a:"record"},"11.16":{t:"ToReadonly",p:`索引类型的索引可以添加 readonly 的修饰符，代表只读。
那我们就可以实现给索引类型添加 readonly 修饰的高级 ...`,l:"src/article/typescript/reconstruction.html#toreadonly",a:"toreadonly"},"11.17":{t:"ToPartial",p:`同理，索引类型还可以添加可选修饰符：
type ToPartial&lt;T&gt; = {
  [Key in keyof ...`,l:"src/article/typescript/reconstruction.html#topartial",a:"topartial"},"11.18":{t:"ToMutable",p:`可以添加 readonly 修饰，当然也可以去掉：
type ToMutable&lt;T&gt; = {
  -reado ...`,l:"src/article/typescript/reconstruction.html#tomutable",a:"tomutable"},"11.19":{t:"ToRequired",p:`同理，也可以去掉可选修饰符：
type ToRequired&lt;T&gt; = {
  [Key in keyof T] ...`,l:"src/article/typescript/reconstruction.html#torequired",a:"torequired"},"11.20":{t:"FilterByValueType",p:`可以在构造新索引类型的时候根据值的类型做下过滤：
type FilterByValueType&lt;Obj extends ...`,l:"src/article/typescript/reconstruction.html#filterbyvaluetype",a:"filterbyvaluetype"},"12.0":{t:"# 递归复用",p:`递归是把问题分解为一系列相似的小问题，通过函数不断调用自身来解决这一个个小问题，直到满足结束条件，就完成了问题的求解。
Ty ...`,l:"src/article/typescript/recursion.html",a:"递归复用"},"12.1":{t:"Promise 的递归复用",p:"",l:"src/article/typescript/recursion.html#promise-的递归复用",a:"promise-的递归复用"},"12.2":{t:"DeepPromiseValueType",p:`先用 Promise 热热身，实现一个提取不确定层数的 Promise 中的 value 类型的高级类型。
type ttt ...`,l:"src/article/typescript/recursion.html#deeppromisevaluetype",a:"deeppromisevaluetype"},"12.3":{t:"数组类型的递归",p:"",l:"src/article/typescript/recursion.html#数组类型的递归",a:"数组类型的递归"},"12.4":{t:"ReverseArr",p:`有这样一个元组类型：
type arr = [1, 2, 3, 4, 5]

我们把它反过来，也就是变成：
type arr ...`,l:"src/article/typescript/recursion.html#reversearr",a:"reversearr"},"12.5":{t:"Includes",p:`既然递归可以做循环用，那么像查找元素这种自然也就可以实现。
比如查找 [1, 2, 3, 4, 5] 中是否存在 4，是就返 ...`,l:"src/article/typescript/recursion.html#includes",a:"includes"},"12.6":{t:"RemoveItem",p:`可以查找自然就可以删除，只需要改下返回结果，构造一个新的数组返回。
type RemoveItem&lt;
  Arr ex ...`,l:"src/article/typescript/recursion.html#removeitem",a:"removeitem"},"12.7":{t:"BuildArray",p:`我们学过数组类型的构造，如果构造的数组类型元素个数不确定，也需要递归。
比如传入 5 和元素类型，构造一个长度为 5 的该元 ...`,l:"src/article/typescript/recursion.html#buildarray",a:"buildarray"},"12.8":{t:"字符串类型的递归",p:"",l:"src/article/typescript/recursion.html#字符串类型的递归",a:"字符串类型的递归"},"12.9":{t:"ReplaceAll",p:`学模式匹配的时候，我们实现过一个 Replace 的高级类型：
type ReplaceStr&lt;
  Str exte ...`,l:"src/article/typescript/recursion.html#replaceall",a:"replaceall"},"12.10":{t:"StringToUnion",p:"我们想把字符串字面量类型的每个字符都提取出来组成联合类型，也就是把 'dong' 转为 'd' | 'o' | 'n' |  ...",l:"src/article/typescript/recursion.html#stringtounion",a:"stringtounion"},"12.11":{t:"ReverseStr",p:`我们实现了数组的反转，自然也可以实现字符串类型的反转。
同样是递归提取和构造。
type ReverseStr&lt;
   ...`,l:"src/article/typescript/recursion.html#reversestr",a:"reversestr"},"12.12":{t:"对象类型的递归",p:"",l:"src/article/typescript/recursion.html#对象类型的递归",a:"对象类型的递归"},"12.13":{t:"DeepReadonly",p:`对象类型的递归，也可以叫做索引类型的递归。
我们之前实现了索引类型的映射，给索引加上了 readonly 的修饰：
type ...`,l:"src/article/typescript/recursion.html#deepreadonly",a:"deepreadonly"},"13.0":{t:"# 分布式条件类型",p:"当类型参数为联合类型，并且在条件类型左边直接引用该类型参数的时候，TypeScript 会把每一个元素单独传入来做类型运算， ...",l:"src/article/typescript/unionType.html",a:"分布式条件类型"},"13.1":{t:"CamelcaseUnion",p:`Camelcase 我们实现过，就是提取字符串中的字符，首字母大写以后重新构造一个新的。
type Camelcase&lt ...`,l:"src/article/typescript/unionType.html#camelcaseunion",a:"camelcaseunion"},"13.2":{t:"IsUnion",p:`判断联合类型我们会这样写：
type IsUnion&lt;A, B = A&gt; = A extends A ? ([B ...`,l:"src/article/typescript/unionType.html#isunion",a:"isunion"},"13.3":{t:"BEM",p:"bem 是 css 命名规范，用 block__element--modifier 的形式来描述某个区块下面的某个元素的某个 ...",l:"src/article/typescript/unionType.html#bem",a:"bem"},"13.4":{t:"AllCombinations",p:`我们再来实现一个全组合的高级类型，也是联合类型相关的：
希望传入 'A' | 'B' 的时候，能够返回所有的组合： 'A'  ...`,l:"src/article/typescript/unionType.html#allcombinations",a:"allcombinations"},"13.5":{t:"总结",p:"联合类型中的每个类型都是相互独立的，TypeScript 对它做了特殊处理，也就是遇到字符串类型、条件类型的时候会把每个类型 ...",l:"src/article/typescript/unionType.html#总结",a:"总结"},"14.0":{t:"# 二叉树的定义",p:"在计算机科学中，二叉树（Binary tree）是每个节点最多只有两个分支（即不存在分支度大于 2 的节点）的树结构。通常分 ...",l:"src/common_tools/binaryTree/index.html",a:"二叉树的定义"},"14.1":{t:"满二叉树",p:`一棵深度为 k 且有 2k-1 个节点的二叉树称为满二叉树。
除最后一层无任何子节点外，每一层上的所有结点都有两个子结点的二 ...`,l:"src/common_tools/binaryTree/index.html#满二叉树",a:"满二叉树"},"14.2":{t:"完全二叉树",p:"一棵深度为 k 的有 n 个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为 i（1≤i≤n）的结点 ...",l:"src/common_tools/binaryTree/index.html#完全二叉树",a:"完全二叉树"},"14.3":{t:"二叉搜索树",p:"二叉搜索树（BST）又称二叉查找树或二叉排序树。它或者是一棵空树，或者是具有下列性质的二叉树： 若它的左子树不空，则左子树上 ...",l:"src/common_tools/binaryTree/index.html#二叉搜索树",a:"二叉搜索树"},"14.4":{t:"平衡二叉树",p:`平衡二叉树(AVL)一定是二叉搜索树，且左子树和右子树的高度差的绝对值不超过 1。
!平衡二叉树
`,l:"src/common_tools/binaryTree/index.html#平衡二叉树",a:"平衡二叉树"},"14.5":{t:"B 树",p:`B 树属于多叉树又名平衡多路查找树（查找路径不只两个）
`,l:"src/common_tools/binaryTree/index.html#b-树",a:"b-树"},"14.6":{t:"B+树",p:`B+树是 B 树的变体，也是一种多路搜索树。
`,l:"src/common_tools/binaryTree/index.html#b-树",a:"b-树"},"14.7":{t:"B\\*树",p:"B* 树是 B+树的变体，在 B+树的非根和非叶子结点再增加指向兄弟的指针；B* 树定义了非叶子结点关键字个数至少为(2/3 ...",l:"src/common_tools/binaryTree/index.html#b-树",a:"b-树"},"14.8":{t:"红黑树",p:"红黑树是一种平衡二叉查找树的变体，它的左右子树高差有可能大于 1，所以红黑树不是严格意义上的平衡二叉树（AVL），但对它进行 ...",l:"src/common_tools/binaryTree/index.html#红黑树",a:"红黑树"},"14.9":{t:"堆",p:`遍历
`,l:"src/common_tools/binaryTree/index.html#堆",a:"堆"},"14.10":{t:"前序遍历",p:"",l:"src/common_tools/binaryTree/index.html#前序遍历",a:"前序遍历"},"14.11":{t:"后序遍历",p:"",l:"src/common_tools/binaryTree/index.html#后序遍历",a:"后序遍历"},"14.12":{t:"中序遍历",p:"",l:"src/common_tools/binaryTree/index.html#中序遍历",a:"中序遍历"},"14.13":{t:"层序遍历",p:`常见算法题
`,l:"src/common_tools/binaryTree/index.html#层序遍历",a:"层序遍历"},"14.14":{t:"镜像二叉树",p:"",l:"src/common_tools/binaryTree/index.html#镜像二叉树",a:"镜像二叉树"},"14.15":{t:"重建二叉树",p:"",l:"src/common_tools/binaryTree/index.html#重建二叉树",a:"重建二叉树"},"14.16":{t:"二叉树深度",p:"",l:"src/common_tools/binaryTree/index.html#二叉树深度",a:"二叉树深度"},"14.17":{t:"二叉树节点总数",p:"",l:"src/common_tools/binaryTree/index.html#二叉树节点总数",a:"二叉树节点总数"},"14.18":{t:"判断二叉树子结构",p:`输入两棵二叉树 A 和 B，判断 B 是不是 A 的子结构。（ps：约定空树不是任意一个树的子结构）
参考文档

维基百科二 ...`,l:"src/common_tools/binaryTree/index.html#判断二叉树子结构",a:"判断二叉树子结构"},"15.0":{t:"# Bundler",p:`Bundler的使用：
传入 options 参数
function build(options: Options):Pro ...`,l:"src/common_tools/bundler/index.html",a:"bundler"},"16.0":{t:"# 文件操作函数",p:"",l:"src/common_tools/file/index.html",a:"文件操作函数"},"16.1":{t:"watchFile",p:`观察一个文件是否改变
`,l:"src/common_tools/file/index.html#watchfile",a:"watchfile"},"16.2":{t:"API",p:"",l:"src/common_tools/file/index.html#api",a:"api"},"16.3":{t:"Return",p:`
Promise




参数
说明
类型
描述




status
文件是否被改变
boolean
true 文件改变  ...`,l:"src/common_tools/file/index.html#return",a:"return"},"16.4":{t:"Options",p:`


参数
说明
类型
默认值




path
文件路径，需要监听的文件
string
undefined


inter ...`,l:"src/common_tools/file/index.html#options",a:"options"},"18.0":{t:"# 封装 Promise.allSettled()",p:"Promise.allSettled()方法接受一个数组作为参数，数组的每个成员都是一个 Promise 对象，并返回一个新 ...",l:"src/common_tools/method/allSettled.html",a:"封装-promise-allsettled"},"18.1":{t:"1.代码实现",p:"export function useDictOptions&lt;T = any&gt;(options: Options ...",l:"src/common_tools/method/allSettled.html#_1-代码实现",a:"_1-代码实现"},"18.2":{t:"2.使用方法",p:`const { optionsData } = useDictOptions&lt;{
  PARAM_1: any[];
 ...`,l:"src/common_tools/method/allSettled.html#_2-使用方法",a:"_2-使用方法"},"18.3":{t:"3.参数说明",p:`


参数
说明
必填
类型
默认值




PARAM_1、PARAM_2
声明变量，必须和下面的对应起来
是
array ...`,l:"src/common_tools/method/allSettled.html#_3-参数说明",a:"_3-参数说明"},"19.0":{t:"# 字符串大小写转换\r",p:`字符串大小写转换
`,l:"src/common_tools/method/changeCase.html",a:"字符串大小写转换"},"19.1":{t:"1.代码实现\r",p:`function changeCase(str, type) {
  type = type || 4;
  switch  ...`,l:"src/common_tools/method/changeCase.html#_1-代码实现",a:"_1-代码实现"},"19.2":{t:"2.使用方法\r",p:`changeCase(STR, TYPE);

`,l:"src/common_tools/method/changeCase.html#_2-使用方法",a:"_2-使用方法"},"19.3":{t:"3.参数说明\r",p:`


参数
说明
必填
类型
默认值




STR
需要转换的字符串
是
string
无


TYPE
1: 首字母大写 ...`,l:"src/common_tools/method/changeCase.html#_3-参数说明",a:"_3-参数说明"},"20.0":{t:"# 截取 url 参数",p:`截取地址栏中 url 问号后面的参数
`,l:"src/common_tools/method/index.html",a:"截取-url-参数"},"20.1":{t:"1.代码实现",p:`function getUrlParam(name) {
  //构造一个含有目标参数的正则表达式对象
  var reg  ...`,l:"src/common_tools/method/index.html#_1-代码实现",a:"_1-代码实现"},"20.2":{t:"2.使用方法",p:`getUrlParam(NAME);

`,l:"src/common_tools/method/index.html#_2-使用方法",a:"_2-使用方法"},"20.3":{t:"3.参数说明",p:`


参数
说明
必填
类型
默认值




NAME
要截取的参数名
是
string
无



`,l:"src/common_tools/method/index.html#_3-参数说明",a:"_3-参数说明"},"21.0":{t:"# 时间格式化\r",p:"时间格式化 &lt;br/&gt;yyyy:mm:dd 、 yyyy:mm 、 yyyy 年 mm 月 dd 日 、 yyy ...",l:"src/common_tools/method/timeFormat.html",a:"时间格式化"},"21.1":{t:"1.代码实现\r",p:`/**
 * @description 时间格式化
 * @param dateTime { number } 时间戳
 * ...`,l:"src/common_tools/method/timeFormat.html#_1-代码实现",a:"_1-代码实现"},"21.2":{t:"2.使用方法\r",p:`timeFormat(DATETIME, FMT);

`,l:"src/common_tools/method/timeFormat.html#_2-使用方法",a:"_2-使用方法"},"21.3":{t:"3.参数说明\r",p:`


参数
说明
必填
类型
默认值




DATETIME
时间戳
否
date
当前时间


FMT
时间格式 &lt ...`,l:"src/common_tools/method/timeFormat.html#_3-参数说明",a:"_3-参数说明"},"22.0":{t:"# 冒泡排序（Bubble Sort）",p:"冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工 ...",l:"src/common_tools/sort/bubble/index.html",a:"冒泡排序-bubble-sort"},"22.1":{t:"算法描述",p:`
比较相邻的元素。如果第一个比第二个大，就交换它们两个；
对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在 ...`,l:"src/common_tools/sort/bubble/index.html#算法描述",a:"算法描述"},"22.2":{t:"动图演示",p:`!冒泡排序
`,l:"src/common_tools/sort/bubble/index.html#动图演示",a:"动图演示"},"22.3":{t:"代码演示",p:`function bubbleSort(arr) {
  var len = arr.length
  for (var i ...`,l:"src/common_tools/sort/bubble/index.html#代码演示",a:"代码演示"},"23.0":{t:"# 桶排序 (Bucket Sort）",p:"高效与否的关键在于这个分桶函数。将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶 ...",l:"src/common_tools/sort/bucket/index.html",a:"桶排序-bucket-sort"},"23.1":{t:"算法描述",p:`
设置一个定量的数组当作空桶；
遍历输入数据，并且把数据一个一个放到对应的桶里去；
对每个不是空的桶进行排序；
从不是空的桶 ...`,l:"src/common_tools/sort/bucket/index.html#算法描述",a:"算法描述"},"23.2":{t:"代码演示",p:"const count = (list: Array&lt;number&gt;, max: number = 100):  ...",l:"src/common_tools/sort/bucket/index.html#代码演示",a:"代码演示"},"23.3":{t:"算法分析",p:"桶排序最好情况下使用线性时间 O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复 ...",l:"src/common_tools/sort/bucket/index.html#算法分析",a:"算法分析"},"24.0":{t:"# 计数排序（ Count Sort ）",p:"计数排序（counting sort）就是一种牺牲内存空间来换取低时间复杂度的排序算法，同时它也是一种不基于比较的算法。这里 ...",l:"src/common_tools/sort/count/index.html",a:"计数排序-count-sort"},"24.1":{t:"算法描述",p:`
找出待排序的数组中最大和最小的元素；
统计数组中每个值为 i 的元素出现的次数，存入数组 C 的第 i 项；
对所有的计数 ...`,l:"src/common_tools/sort/count/index.html#算法描述",a:"算法描述"},"24.2":{t:"动图演示",p:`!计数排序
`,l:"src/common_tools/sort/count/index.html#动图演示",a:"动图演示"},"24.3":{t:"代码演示",p:`const getMax = (list: Array&lt;number&gt;) =&gt; {
  let max = ...`,l:"src/common_tools/sort/count/index.html#代码演示",a:"代码演示"},"24.4":{t:"算法分析",p:"计数排序是一个稳定的排序算法。当输入的元素是 n 个 0 到 k 之间的整数时，时间复杂度是 O(n+k)，空间复杂度也是  ...",l:"src/common_tools/sort/count/index.html#算法分析",a:"算法分析"},"25.0":{t:"# 堆排序（Heap Sort）",p:"堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质： ...",l:"src/common_tools/sort/heap/index.html",a:"堆排序-heap-sort"},"25.1":{t:"算法描述",p:`
将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；
将堆顶元素 R[1]与最后一个元素 R[n ...`,l:"src/common_tools/sort/heap/index.html#算法描述",a:"算法描述"},"25.2":{t:"动图演示",p:`!堆排序
`,l:"src/common_tools/sort/heap/index.html#动图演示",a:"动图演示"},"25.3":{t:"代码演示",p:`class Heap {
  arr: Array&lt;number&gt;
  size: number
  const ...`,l:"src/common_tools/sort/heap/index.html#代码演示",a:"代码演示"},"26.0":{t:"# 十大经典排序",p:`十种常见排序算法可以分为两大类：

比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破 O(nlogn)， ...`,l:"src/common_tools/sort/index.html",a:"十大经典排序"},"27.0":{t:"# 插入排序（Insert Sort）",p:"表现稳定的排序算法，因为无论什么数据进去都是 O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好。优点是不占用额外的 ...",l:"src/common_tools/sort/insert/index.html",a:"插入排序-insert-sort"},"27.1":{t:"算法描述",p:`
从第一个元素开始，该元素可以认为已经被排序；
取出下一个元素，在已经排序的元素序列中从后向前扫描；
如果该元素（已排序）大 ...`,l:"src/common_tools/sort/insert/index.html#算法描述",a:"算法描述"},"27.2":{t:"动图演示",p:`!插入排序
`,l:"src/common_tools/sort/insert/index.html#动图演示",a:"动图演示"},"27.3":{t:"代码演示",p:"const insert = (list: Array&lt;string&gt;): Array&lt;string&gt ...",l:"src/common_tools/sort/insert/index.html#代码演示",a:"代码演示"},"27.4":{t:"算法分析",p:"插入排序在实现上，通常采用 in-place 排序（即只需用到 O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反 ...",l:"src/common_tools/sort/insert/index.html#算法分析",a:"算法分析"},"28.0":{t:"# 归并排序（Merge Sort）",p:"归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应 ...",l:"src/common_tools/sort/merge/index.html",a:"归并排序-merge-sort"},"28.1":{t:"算法描述",p:`
把长度为 n 的输入序列分成两个长度为 n/2 的子序列；
对这两个子序列分别采用归并排序；
将两个排序好的子序列合并成一 ...`,l:"src/common_tools/sort/merge/index.html#算法描述",a:"算法描述"},"28.2":{t:"动图演示",p:`!归并排序
`,l:"src/common_tools/sort/merge/index.html#动图演示",a:"动图演示"},"28.3":{t:"代码演示",p:"const combine = (left: Array&lt;number&gt;, right: Array&lt;nu ...",l:"src/common_tools/sort/merge/index.html#代码演示",a:"代码演示"},"28.4":{t:"算法分析",p:"归并排序是一种稳定的排序方法。和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(n ...",l:"src/common_tools/sort/merge/index.html#算法分析",a:"算法分析"},"29.0":{t:"# 快速排序（Quick Sort）",p:"快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部 ...",l:"src/common_tools/sort/quick/index.html",a:"快速排序-quick-sort"},"29.1":{t:"算法描述",p:`快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：

从数列中挑出一个元素，称为 ...`,l:"src/common_tools/sort/quick/index.html#算法描述",a:"算法描述"},"29.2":{t:"动图演示",p:`!快速排序
`,l:"src/common_tools/sort/quick/index.html#动图演示",a:"动图演示"},"29.3":{t:"代码演示",p:`/**
 * @description: 设置基准值pivot
 * @param {Array} list
 * @par ...`,l:"src/common_tools/sort/quick/index.html#代码演示",a:"代码演示"},"30.0":{t:"# 基数排序（Radix Sort）",p:"基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低 ...",l:"src/common_tools/sort/radix/index.html",a:"基数排序-radix-sort"},"30.1":{t:"算法描述",p:`
取得数组中的最大数，并取得位数；
arr 为原始数组，从最低位开始取每个位组成 radix 数组；
对 radix 进行计 ...`,l:"src/common_tools/sort/radix/index.html#算法描述",a:"算法描述"},"30.2":{t:"动图演示",p:`!基数排序
`,l:"src/common_tools/sort/radix/index.html#动图演示",a:"动图演示"},"30.3":{t:"代码演示",p:`const getMax = (list: Array&lt;number&gt;) =&gt; {
  let max = ...`,l:"src/common_tools/sort/radix/index.html#代码演示",a:"代码演示"},"30.4":{t:"算法分析",p:"基数排序基于分配排序，所以是稳定的。但基数排序的性能比桶排序要略差，每一次关键字的桶分配都需要 O(n)的时间复杂度，而且分 ...",l:"src/common_tools/sort/radix/index.html#算法分析",a:"算法分析"},"31.0":{t:"# 选择排序（Selection Sort）",p:"选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到 ...",l:"src/common_tools/sort/select/index.html",a:"选择排序-selection-sort"},"31.1":{t:"算法描述",p:`n 个记录的直接选择排序可经过 n-1 趟直接选择排序得到有序结果。具体算法描述如下：

初始状态：无序区为 R[1..n] ...`,l:"src/common_tools/sort/select/index.html#算法描述",a:"算法描述"},"31.2":{t:"动图演示",p:`!选择排序
`,l:"src/common_tools/sort/select/index.html#动图演示",a:"动图演示"},"31.3":{t:"代码实现",p:`function selectionSort(arr) {
  var len = arr.length
  var min ...`,l:"src/common_tools/sort/select/index.html#代码实现",a:"代码实现"},"31.4":{t:"算法分析",p:"表现最稳定的排序算法之一，因为无论什么数据进去都是 O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可 ...",l:"src/common_tools/sort/select/index.html#算法分析",a:"算法分析"},"32.0":{t:"# 希尔排序（Shell Sort）",p:"1959 年 Shell 发明，第一个突破 O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优 ...",l:"src/common_tools/sort/shell/index.html",a:"希尔排序-shell-sort"},"32.1":{t:"算法描述",p:`先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：

选择一个增量序列 t1，t2，…，tk，其 ...`,l:"src/common_tools/sort/shell/index.html#算法描述",a:"算法描述"},"32.2":{t:"动图演示",p:`!希尔排序
`,l:"src/common_tools/sort/shell/index.html#动图演示",a:"动图演示"},"32.3":{t:"代码实现",p:`/**
 * @description: 希尔排序，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远 ...`,l:"src/common_tools/sort/shell/index.html#代码实现",a:"代码实现"},"32.4":{t:"算法分析",p:"希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第 4 ...",l:"src/common_tools/sort/shell/index.html#算法分析",a:"算法分析"},"33.0":{t:"# CSS - 开发技巧\r",p:"\r",l:"src/other/css.html",a:"css-开发技巧"},"33.1":{t:"1.定位居中\r",p:`.dom {
  position: absolute;
  left: 50%;
  top: 50%;
  transf ...`,l:"src/other/css.html#_1-定位居中",a:"_1-定位居中"},"33.2":{t:"2.禁止选中文本\r",p:`.dom {
  -moz-user-select: none;
  -webkit-user-select: none;
 ...`,l:"src/other/css.html#_2-禁止选中文本",a:"_2-禁止选中文本"},"33.3":{t:"3.文本超出部分以省略号形式出现\r",p:`.dom {
  white-space: nowrap;
  overflow: hidden;
  text-overf ...`,l:"src/other/css.html#_3-文本超出部分以省略号形式出现",a:"_3-文本超出部分以省略号形式出现"},"34.0":{t:"# JS - 开发技巧\r",p:"\r",l:"src/other/index.html",a:"js-开发技巧"},"34.1":{t:"1.截取字符串\r",p:`//截取字符串，并且返回一个新的字符串
//strJoin：要截取的字符串
var strSplit = strJoin.s ...`,l:"src/other/index.html#_1-截取字符串",a:"_1-截取字符串"},"34.2":{t:"2.去除末尾最后一个逗号\r",p:`//截取字符串，并且返回一个新的字符串
//strJoin：要截取的字符串
var reg = /,$/gi;
consol ...`,l:"src/other/index.html#_2-去除末尾最后一个逗号",a:"_2-去除末尾最后一个逗号"},"34.3":{t:"3.桌面通知\r",p:`//桌面通知，只有chrome，firefox浏览器支持桌面API
Notification.requestPermissi ...`,l:"src/other/index.html#_3-桌面通知",a:"_3-桌面通知"},"34.4":{t:"4.冒泡排序\r",p:`/*	
	实现思路：
		1、比较相邻的两个元素，如果前一个比后一个大，则交换位置。
		2、比较完第一轮的时候，最后一个元 ...`,l:"src/other/index.html#_4-冒泡排序",a:"_4-冒泡排序"},"34.5":{t:"5.根据数组中某一项进行排序\r",p:`var arr = [
  { name: &quot;LL&quot;, age: 5 },
  { name: &quo ...`,l:"src/other/index.html#_5-根据数组中某一项进行排序",a:"_5-根据数组中某一项进行排序"},"34.6":{t:"6.禁用 F12\r",p:`document.onkeydown = function () {
  if (window.event &amp;&am ...`,l:"src/other/index.html#_6-禁用-f12",a:"_6-禁用-f12"},"34.7":{t:"7.禁用鼠标右键\r",p:"document.oncontextmenu = new Function(&quot;event.returnValue= ...",l:"src/other/index.html#_7-禁用鼠标右键",a:"_7-禁用鼠标右键"},"34.8":{t:"8.if 判断逻辑优化\r",p:`//Longhand
if (x === &quot;abc&quot; || x === &quot;def&quot;  ...`,l:"src/other/index.html#_8-if-判断逻辑优化",a:"_8-if-判断逻辑优化"},"34.9":{t:"9.switch 逻辑优化\r",p:`// Longhand
switch (data) {
  case1:
    test1();
  break;

   ...`,l:"src/other/index.html#_9-switch-逻辑优化",a:"_9-switch-逻辑优化"},"34.10":{t:"10.数组合并 - 扩展运算符简写\r",p:`//longhand
// joining arrays using concat
const data = [1, 2,  ...`,l:"src/other/index.html#_10-数组合并-扩展运算符简写",a:"_10-数组合并-扩展运算符简写"},"34.11":{t:"11.根据数组对象属性查找特定对象\r",p:`const data = [
  {
    type: &quot;test1&quot;,
    name: &quo ...`,l:"src/other/index.html#_11-根据数组对象属性查找特定对象",a:"_11-根据数组对象属性查找特定对象"},"34.12":{t:"12.将对象转换为对象数组\r",p:"const data = { test1: &quot;abc&quot;, test2: &quot;cde&quot;, ...",l:"src/other/index.html#_12-将对象转换为对象数组",a:"_12-将对象转换为对象数组"},"34.13":{t:"13.在数组中查找最大值和最小值\r",p:`const arr = [1, 2, 3];
Math.max(…arr); // 3
Math.min(…arr); // ...`,l:"src/other/index.html#_13-在数组中查找最大值和最小值",a:"_13-在数组中查找最大值和最小值"},"34.14":{t:"14.下载文件\r",p:`downloadFile(&quot;url&quot;, &quot;name&quot;);

//下载文件
funct ...`,l:"src/other/index.html#_14-下载文件",a:"_14-下载文件"},"34.15":{t:"15.下载文件.xlsx\r",p:`//添加ajax参数 responseType: 'arraybuffer',
//data: application/vn ...`,l:"src/other/index.html#_15-下载文件-xlsx",a:"_15-下载文件-xlsx"},"34.16":{t:"16.数据类型检测\r",p:`function checkType(target) {
  return Object.prototype.tostrin ...`,l:"src/other/index.html#_16-数据类型检测",a:"_16-数据类型检测"},"34.17":{t:"17.数组去重\r",p:`function unique(arr) {
  return [...new Set(arr)];
}

`,l:"src/other/index.html#_17-数组去重",a:"_17-数组去重"},"34.18":{t:"18.字符串去重\r",p:`function uniq(str) {
    return str.replace(/(\\w)\\1+/g，'$1')
} ...`,l:"src/other/index.html#_18-字符串去重",a:"_18-字符串去重"},"34.19":{t:"19.取消冒泡\r",p:`取消冒泡的兼容代码
function stopBubble(e) {
  if (e &amp;&amp; e.stopPr ...`,l:"src/other/index.html#_19-取消冒泡",a:"_19-取消冒泡"},"34.20":{t:"19.获得滚动条的滚动距离\r",p:`function getScrolloffset() {
    if (window.pageX0ffset) {
    ...`,l:"src/other/index.html#_19-获得滚动条的滚动距离",a:"_19-获得滚动条的滚动距离"},"34.21":{t:"20.生成随机数范围\r",p:`function setRandom(min，max){
    if (arguments.length === 2) { ...`,l:"src/other/index.html#_20-生成随机数范围",a:"_20-生成随机数范围"},"35.0":{t:"# yarn 的安装和使用\r",p:"\r",l:"src/other/yarn.html",a:"yarn-的安装和使用"},"35.1":{t:"1.简介\r",p:`Yarn 是 facebook 发布的一款取代 npm 的包管理工具。
`,l:"src/other/yarn.html#_1-简介",a:"_1-简介"},"35.2":{t:"2.特点\r",p:`
速度快、安全、可靠
Yarn 缓存了每个下载过的包，所以再次使用时无需重复下载。 同时利用并行下载以最大化资源利用率，因此 ...`,l:"src/other/yarn.html#_2-特点",a:"_2-特点"},"35.3":{t:"3.安装\r",p:`安装
npm install -g yarn

查看版本
yarn --version

`,l:"src/other/yarn.html#_3-安装",a:"_3-安装"},"35.4":{t:"4.常用命令\r",p:`#安装yarn
npm install -g yarn
#安装成功后，查看版本号：
yarn --version
#创建文件 ...`,l:"src/other/yarn.html#_4-常用命令",a:"_4-常用命令"},"35.5":{t:"5.npm 与 yarn 命令比较\r",p:`
在你安装 A 的时候需要安装依赖 C 和 D，很多依赖不会指定版本号，默认会安装最新的版本，这样就会出现问题：比如今天安装 ...`,l:"src/other/yarn.html#_5-npm-与-yarn-命令比较",a:"_5-npm-与-yarn-命令比较"},"36.0":{t:"# Button 按钮",p:`按钮用于开始一个即时操作。
`,l:"src/ranui/button/index.html",a:"button-按钮"},"36.1":{t:"代码演示",p:`&lt;r-button&gt;Button&lt;/r-button&gt;
 &lt;r-button &gt;Butt ...`,l:"src/ranui/button/index.html#代码演示",a:"代码演示"},"36.2":{t:"属性",p:"",l:"src/ranui/button/index.html#属性",a:"属性"},"36.3":{t:"类型`type`",p:`按钮有四种类型
&lt;div style=&quot;display:inline-block;margin-right: ...`,l:"src/ranui/button/index.html#类型-type",a:"类型-type"},"36.4":{t:"不可用状态`disabled`",p:`添加 disabled 属性即可让按钮处于不可用状态，同时按钮样式也会改变。
&lt;div style=&quot;dis ...`,l:"src/ranui/button/index.html#不可用状态-disabled",a:"不可用状态-disabled"},"36.5":{t:"图标`icon`",p:`当需要在 Button 内嵌入 Icon 时，可以设置 icon 属性，或者直接在 Button 内使用 Icon 组件。
 ...`,l:"src/ranui/button/index.html#图标-icon",a:"图标-icon"},"36.6":{t:"特效 effect",p:`如果需要纯净的 Button ，可以加上 effect = false ，屏蔽点击时候的水波纹特效
&lt;r-button ...`,l:"src/ranui/button/index.html#特效-effect",a:"特效-effect"},"37.0":{t:"# Icon 图标",p:`语义化的矢量图形
`,l:"src/ranui/icon/index.html",a:"icon-图标"},"37.1":{t:"代码演示",p:`&lt;div style='display:flex'&gt;
&lt;r-icon name=&quot;lock&qu ...`,l:"src/ranui/icon/index.html#代码演示",a:"代码演示"},"37.2":{t:"属性",p:"",l:"src/ranui/icon/index.html#属性",a:"属性"},"37.3":{t:"名称`name`",p:`根据名称选择不同的图标
&lt;div style='display:flex'&gt;
&lt;r-icon name=& ...`,l:"src/ranui/icon/index.html#名称-name",a:"名称-name"},"37.4":{t:"尺寸`size`",p:`&lt;div style='display:flex;align-items: flex-end;'&gt;
&lt;r- ...`,l:"src/ranui/icon/index.html#尺寸-size",a:"尺寸-size"},"37.5":{t:"颜色`color`",p:`&lt;div style='display:flex'&gt;
&lt;r-icon name=&quot;lock&qu ...`,l:"src/ranui/icon/index.html#颜色-color",a:"颜色-color"},"37.6":{t:"旋转`spin`",p:`设置 spin 开启旋转，传入数字控制旋转的速度，数字越小旋转越快
&lt;div style='display:flex' ...`,l:"src/ranui/icon/index.html#旋转-spin",a:"旋转-spin"},"37.7":{t:"图标列表",p:`&lt;div style=&quot;display: flex;
align-items: center;
justif ...`,l:"src/ranui/icon/index.html#图标列表",a:"图标列表"},"38.0":{t:"# Image 图片",p:"",l:"src/ranui/image/index.html",a:"image-图片"},"38.1":{t:"代码演示",p:" &lt;r-img src=&quot;&quot; fallback=&quot;&quot;&gt;&lt;/r-im ...",l:"src/ranui/image/index.html#代码演示",a:"代码演示"},"38.2":{t:"属性",p:"",l:"src/ranui/image/index.html#属性",a:"属性"},"38.3":{t:"图片加载地址`src`",p:`图片的地址
`,l:"src/ranui/image/index.html#图片加载地址-src",a:"图片加载地址-src"},"38.4":{t:"图片加载失败`fallback`",p:`src配置的图片加载失败，兜底的图片地址，下面是默认加载失败图片
&lt;r-img fallback=&quot;data ...`,l:"src/ranui/image/index.html#图片加载失败-fallback",a:"图片加载失败-fallback"},"39.0":{t:"# ranui",p:`基于 Web Components UI组件库
`,l:"src/ranui/index.html",a:"ranui"},"39.1":{t:"Feature 特点",p:`
基于Web Components开发，能做到跨框架复用，统一所有情况。
采用Typescript开发，有声明和类型文件。
 ...`,l:"src/ranui/index.html#feature-特点",a:"feature-特点"},"39.2":{t:"Situation 项目情况",p:"&lt;a style=&quot;display:inline-block;margin-left: 4px;&quot; ...",l:"src/ranui/index.html#situation-项目情况",a:"situation-项目情况"},"39.3":{t:"Import 导入方式",p:`支持按需引入
import 'ranui/button'

对于一些全局展示的组件，比如 preview 和 message ...`,l:"src/ranui/index.html#import-导入方式",a:"import-导入方式"},"39.4":{t:"Usage 使用",p:`大多数情况都可以像原生的 div 标签一样使用。
接下来是一些使用例子

html
js
jsx
vue
tsx

`,l:"src/ranui/index.html#usage-使用",a:"usage-使用"},"39.5":{t:"`html`",p:`

&lt;body&gt;
  &lt;r-button&gt;Button&lt;/r-button&gt;
&lt;/ ...`,l:"src/ranui/index.html#html",a:"html"},"39.6":{t:"`js`",p:`import 'ranui'

const Button = document.createElement('r-butto ...`,l:"src/ranui/index.html#js",a:"js"},"39.7":{t:"`jsx`",p:`import 'ranui'
const App = () =&gt; {
  return (
    &lt;&gt;
 ...`,l:"src/ranui/index.html#jsx",a:"jsx"},"39.8":{t:"`vue`",p:`&lt;template&gt;
  &lt;r-button&gt;Button&lt;/r-button&gt;
&lt ...`,l:"src/ranui/index.html#vue",a:"vue"},"39.9":{t:"`tsx`",p:`// react 18 
import type { SyntheticEvent } from 'react';
impo ...`,l:"src/ranui/index.html#tsx",a:"tsx"},"39.10":{t:"Component overview",p:`
Button

&lt;div style=&quot;display:inline-block;margin-right ...`,l:"src/ranui/index.html#component-overview",a:"component-overview"},"39.11":{t:"Compatibility 兼容性",p:`
不支持 IE，其他均有较好支持
!

`,l:"src/ranui/index.html#compatibility-兼容性",a:"compatibility-兼容性"},"39.12":{t:"相关资源",p:`
优秀的组件设计
在线生成 CSS 渐变色
优秀设计作品，有 psd 和 sketch
3D UI 设计，类似于 3D 版的 ...`,l:"src/ranui/index.html#相关资源",a:"相关资源"},"39.13":{t:"协议和标准",p:`
RFCs
ECMA
w3c

`,l:"src/ranui/index.html#协议和标准",a:"协议和标准"},"40.0":{t:"# Input 输入框",p:`通过鼠标或键盘输入内容，是最基础的表单域的包装。
`,l:"src/ranui/input/index.html",a:"input-输入框"},"40.1":{t:"代码演示",p:`&lt;div style=&quot;width:300px;&quot;&gt;
输入框：&lt;r-input&gt; ...`,l:"src/ranui/input/index.html#代码演示",a:"代码演示"},"40.2":{t:"属性",p:"",l:"src/ranui/input/index.html#属性",a:"属性"},"40.3":{t:"标签`label`",p:`提供类似于 Metiral Design 的输入体验。
&lt;r-input label=&quot;user&quot; ...`,l:"src/ranui/input/index.html#标签-label",a:"标签-label"},"40.4":{t:"占位`placeholder`",p:`与原生placeholder一致。
&lt;r-input placeholder=&quot;user&quot;&gt; ...`,l:"src/ranui/input/index.html#占位-placeholder",a:"占位-placeholder"},"40.5":{t:"禁用`disabled`",p:`通过disabled可以禁用输入框，禁用后该按钮上的事件失效。
&lt;r-input label=&quot;user&q ...`,l:"src/ranui/input/index.html#禁用-disabled",a:"禁用-disabled"},"40.6":{t:"值`value`",p:`设置或返回输入框的value属性值。
&lt;r-input value=&quot;1234&quot;&gt;&lt;/ ...`,l:"src/ranui/input/index.html#值-value",a:"值-value"},"40.7":{t:"类型`type`",p:`目前支持password、number这几种类型，设置后会出现额外的ui控件。
`,l:"src/ranui/input/index.html#类型-type",a:"类型-type"},"40.8":{t:"密码输入框",p:`支持密码明文和密文切换。
&lt;r-input icon=&quot;lock&quot; type=&quot;pass ...`,l:"src/ranui/input/index.html#密码输入框",a:"密码输入框"},"40.9":{t:"图标`icon`",p:`可以设置一个icon来表示标签标识。
&lt;r-input icon=&quot;user&quot;&gt;&lt;/r ...`,l:"src/ranui/input/index.html#图标-icon",a:"图标-icon"},"40.10":{t:"数字输入框",p:`数字输入框，类似于原生input[type=number]，支持min、max、step属性，支持键盘上下键切换数字。
&l ...`,l:"src/ranui/input/index.html#数字输入框",a:"数字输入框"},"40.11":{t:"name 属性名",p:`跟 form 组件联动的时候有效，form 提交时收集的字段名字
`,l:"src/ranui/input/index.html#name-属性名",a:"name-属性名"},"40.12":{t:"status 状态",p:`
error

默认色值: #ff4d4f
&lt;div&gt;
&lt;r-input status=&quot;err ...`,l:"src/ranui/input/index.html#status-状态",a:"status-状态"},"40.13":{t:"事件`event`",p:`常见的回调事件。
`,l:"src/ranui/input/index.html#事件-event",a:"事件-event"},"40.14":{t:"onchange",p:`文本改变的时候触发。
&lt;r-input onchange=&quot;console.log(this.value)& ...`,l:"src/ranui/input/index.html#onchange",a:"onchange"},"40.15":{t:"oninput",p:`输入时触发。
&lt;r-input oninput=&quot;console.log(this.value)&quot; ...`,l:"src/ranui/input/index.html#oninput",a:"oninput"},"41.0":{t:"# message 全局提示",p:`全局展示操作反馈信息。
`,l:"src/ranui/message/index.html",a:"message-全局提示"},"41.1":{t:"代码演示",p:"&lt;div style=&quot;display:inline-block;margin-right: 8px;mar ...",l:"src/ranui/message/index.html#代码演示",a:"代码演示"},"41.2":{t:"属性",p:"",l:"src/ranui/message/index.html#属性",a:"属性"},"41.3":{t:"类型`type`",p:`不同的提示类型
&lt;div style=&quot;display:inline-block;margin-right: ...`,l:"src/ranui/message/index.html#类型-type",a:"类型-type"},"41.4":{t:"方法",p:`组件提供了一些静态方法，使用方式和参数如下：

可以只传一个参数，提示的内容，默认提示 3000 毫秒

message.i ...`,l:"src/ranui/message/index.html#方法",a:"方法"},"43.0":{t:"# preview 文件预览",p:`支持docx，pptx，pdf,xlsx文件的预览
`,l:"src/ranui/preview/index.html",a:"preview-文件预览"},"43.1":{t:"代码演示",p:`&lt;div style=&quot;width: 100px; margin-top:10px&quot;&gt;
&l ...`,l:"src/ranui/preview/index.html#代码演示",a:"代码演示"},"43.2":{t:"属性",p:"",l:"src/ranui/preview/index.html#属性",a:"属性"},"43.3":{t:"资源地址`src`",p:`有 src 地址即可打开弹窗，没有src就不展示
&lt;r-preview src=&quot;&quot;&gt;&lt ...`,l:"src/ranui/preview/index.html#资源地址-src",a:"资源地址-src"},"43.4":{t:"是否可关闭`closeable`",p:`closeable 默认为 true ，可以关闭，设置成 false 时， 表示不可关闭，将不会展示右上角的关闭按钮
&lt ...`,l:"src/ranui/preview/index.html#是否可关闭-closeable",a:"是否可关闭-closeable"},"44.0":{t:"# skeleton 骨架屏",p:`在需要等待加载内容的位置提供一个占位图形组合。
`,l:"src/ranui/skeleton/index.html",a:"skeleton-骨架屏"},"44.1":{t:"代码演示",p:`骨架长度跟随父级元素的长度
&lt;div style=&quot;width: 100px;margin-top:10px ...`,l:"src/ranui/skeleton/index.html#代码演示",a:"代码演示"},"45.0":{t:"# Tab 图标",p:`标签页，其中r-tab需要和r-tabs搭配使用
`,l:"src/ranui/tab/index.html",a:"tab-图标"},"45.1":{t:"代码演示",p:`&lt;div style=&quot;width:100%;&quot;&gt;
&lt;r-tabs &gt;
&lt; ...`,l:"src/ranui/tab/index.html#代码演示",a:"代码演示"},"45.2":{t:"属性",p:"",l:"src/ranui/tab/index.html#属性",a:"属性"},"45.3":{t:"标签名`label`",p:`r-tab的属性，设置标签的名称
&lt;div style=&quot;width:100%;&quot;&gt;
&lt ...`,l:"src/ranui/tab/index.html#标签名-label",a:"标签名-label"},"45.4":{t:"活跃标签`active`，标签的唯一标识`ranKey`",p:`
ranKey是r-tab的属性，用于确定同一个r-tabs下r-tab的唯一值。如果ranKey没有设置，默认等于inde ...`,l:"src/ranui/tab/index.html#活跃标签-active-标签的唯一标识-rankey",a:"活跃标签-active-标签的唯一标识-rankey"},"45.5":{t:"不可操作`disabled`",p:`设置不可点击的标签
&lt;div style=&quot;width:100%;&quot;&gt;
&lt;r-tabs ...`,l:"src/ranui/tab/index.html#不可操作-disabled",a:"不可操作-disabled"},"45.6":{t:"类型`type`",p:`r-tabs属性，设置标签页的种类。如果不设置，默认为flat

flat

&lt;div style=&quot;wid ...`,l:"src/ranui/tab/index.html#类型-type",a:"类型-type"},"45.7":{t:"对齐方式`align`",p:`设置标签的对齐方式，默认align=&quot;start&quot;

start

&lt;div style=&quo ...`,l:"src/ranui/tab/index.html#对齐方式-align",a:"对齐方式-align"},"46.0":{t:"# Tab",p:"",l:"src/ranui/tabs/index.html",a:"tab"},"46.1":{t:"代码展示",p:`&lt;r-tabs&gt;
&lt;r-tab label=&quot;tab1&quot;&gt;tab1&lt;/r- ...`,l:"src/ranui/tabs/index.html#代码展示",a:"代码展示"},"46.2":{t:"属性",p:"",l:"src/ranui/tabs/index.html#属性",a:"属性"},"46.3":{t:"名称`label`",p:`每个r-tab需要指定一个名称label，用于显示标签头。
&lt;r-tabs&gt;
&lt;r-tab label=& ...`,l:"src/ranui/tabs/index.html#名称-label",a:"名称-label"},"46.4":{t:"禁用`disabled`",p:`每个r-tab可以指定disabled属性，用来禁用该标签页。
&lt;r-tabs&gt;
&lt;r-tab label ...`,l:"src/ranui/tabs/index.html#禁用-disabled",a:"禁用-disabled"},"46.5":{t:"标识`key`,`active`",p:`每个r-tab需要指定一个标识key，没有会默认以序列号为key，
active作用在r-tabs上，可以指定切换到具体标签 ...`,l:"src/ranui/tabs/index.html#标识-key-active",a:"标识-key-active"},"46.6":{t:"图标`icon`",p:`每个r-tab可以指定icon，配合label实现图标加文字的效果。
&lt;r-tabs&gt;
&lt;r-tab la ...`,l:"src/ranui/tabs/index.html#图标-icon",a:"图标-icon"},"46.7":{t:"风格`type`",p:`风格有 text，clean,
`,l:"src/ranui/tabs/index.html#风格-type",a:"风格-type"},"46.8":{t:"对齐`align`",p:"",l:"src/ranui/tabs/index.html#对齐-align",a:"对齐-align"},"46.9":{t:"事件`event`",p:"",l:"src/ranui/tabs/index.html#事件-event",a:"事件-event"},"46.10":{t:"onchange",p:`切换完成时触发。
`,l:"src/ranui/tabs/index.html#onchange",a:"onchange"},"47.0":{t:"# TypeScript 类型系统中的类型",p:`
基本类型： number、boolean、string、object、bigint、symbol、undefined、nu ...`,l:"src/types/TS类型.html",a:"typescript-类型系统中的类型"},"47.1":{t:"Tuple",p:`元组（Tuple）就是元素个数和类型固定的数组类型：
type Tuple = [number, string];

`,l:"src/types/TS类型.html#tuple",a:"tuple"},"47.2":{t:"Interface",p:`接口（Interface）可以描述函数、对象、构造器的结构：

对象


interface IPerson {
    n ...`,l:"src/types/TS类型.html#interface",a:"interface"},"47.3":{t:"Enum",p:`枚举（Enum）是一系列值的复合：
enum Transpiler {
    Babel = 'babel',
    P ...`,l:"src/types/TS类型.html#enum",a:"enum"},"47.4":{t:"void",p:`代表空，可以是 undefined 或 never。
`,l:"src/types/TS类型.html#void",a:"void"},"47.5":{t:"never",p:`代表不可达，比如函数抛异常的时候，返回值就是 never。
`,l:"src/types/TS类型.html#never",a:"never"},"47.6":{t:"any",p:`是任意类型，任何类型都可以赋值给它，它也可以赋值给任何类型（除了 never）。
`,l:"src/types/TS类型.html#any",a:"any"},"47.7":{t:"unknown",p:`是未知类型，任何类型都可以赋值给它，但是它不可以赋值给别的类型。
`,l:"src/types/TS类型.html#unknown",a:"unknown"},"47.8":{t:"类型的装饰",p:`除了描述类型的结构外，TypeScript 的类型系统还支持描述类型的属性，比如是否可选，是否只读等：
interface  ...`,l:"src/types/TS类型.html#类型的装饰",a:"类型的装饰"},"48.0":{t:"# 模式匹配",p:`Typescript 的类型也同样可以做模式匹配。
比如这样一个 Promise 类型：
type p = Promise& ...`,l:"src/types/模式匹配.html",a:"模式匹配"},"48.1":{t:"数组类型",p:`数组类型想提取第一个元素的类型怎么做呢？
type arr = [1, 2, 3]

用它来匹配一个模式类型，提取第一个元素 ...`,l:"src/types/模式匹配.html#数组类型",a:"数组类型"},"48.2":{t:"Trim",p:`能够匹配和替换字符串，那也就能实现去掉空白字符的 Trim：
不过因为我们不知道有多少个空白字符，所以只能一个个匹配和去掉， ...`,l:"src/types/模式匹配.html#trim",a:"trim"},"48.3":{t:"函数",p:`函数同样也可以做类型匹配，比如提取参数、返回值的类型。
`,l:"src/types/模式匹配.html#函数",a:"函数"},"48.4":{t:"GetParameters",p:`函数类型可以通过模式匹配来提取参数的类型：
type GetParameters&lt;T extends Function ...`,l:"src/types/模式匹配.html#getparameters",a:"getparameters"},"48.5":{t:"GetReturnType",p:"type GetReturnType&lt;T extends Function&gt; = T extends (...a ...",l:"src/types/模式匹配.html#getreturntype",a:"getreturntype"},"48.6":{t:"GetThisParameterType",p:`方法里可以调用 this，用对象.方法名的方式调用的时候，this 就指向那个对象。
但是方法也可以用 call 或者 ap ...`,l:"src/types/模式匹配.html#getthisparametertype",a:"getthisparametertype"},"48.7":{t:"构造器",p:`构造器和函数的区别是，构造器是用于创建对象的，所以可以被 new。
同样，我们也可以通过模式匹配提取构造器的参数和返回值的类 ...`,l:"src/types/模式匹配.html#构造器",a:"构造器"},"48.8":{t:"GetInstanceType",p:`构造器类型可以用 interface 声明，使用 new(): xx 的语法。
interface Person {
    ...`,l:"src/types/模式匹配.html#getinstancetype",a:"getinstancetype"},"49.0":{t:"# TypeScript 类型系统中的类型运算",p:"",l:"src/types/类型运算.html",a:"typescript-类型系统中的类型运算"},"49.1":{t:"条件：`extends ? :`",p:`TypeScript 里的条件判断是 extends ? :，叫做条件类型（Conditional Type）比如：

ty ...`,l:"src/types/类型运算.html#条件-extends",a:"条件-extends"},"49.2":{t:"推导：infer",p:`如何提取类型的一部分呢？答案是 infer。
比如提取元组类型的第一个元素：
type FirstTupleItem&lt; ...`,l:"src/types/类型运算.html#推导-infer",a:"推导-infer"},"49.3":{t:"联合：｜",p:`联合类型（Union）类似 js 里的或运算符 |，但是作用于类型，代表类型可以是几个类型之一。
type Union =  ...`,l:"src/types/类型运算.html#联合",a:"联合"},"49.4":{t:"交叉：&",p:`交叉类型（Intersection）类似 js 中的与运算符 &amp;，但是作用于类型，代表对类型做合并。
type Ob ...`,l:"src/types/类型运算.html#交叉",a:"交叉"},"49.5":{t:"映射类型",p:`对象、class 在 TypeScript 对应的类型是索引类型（Index Type），那么如何对索引类型作修改呢？
答案 ...`,l:"src/types/类型运算.html#映射类型",a:"映射类型"},"50.0":{t:"# TypeScript 内置的高级类型",p:`

`,l:"src/types/高级类型.html",a:"typescript-内置的高级类型"},"50.1":{t:"Parameters",p:`Parameters 用于提取函数类型的参数类型。
`,l:"src/types/高级类型.html#parameters",a:"parameters"},"50.2":{t:"ReturnType",p:`ReturnType 用于提取函数类型的返回值类型。
`,l:"src/types/高级类型.html#returntype",a:"returntype"},"50.3":{t:"ConstructorParameters",p:`构造器类型和函数类型的区别就是可以被 new。
Parameters 用于提取函数参数的类型，而 ConstructorPa ...`,l:"src/types/高级类型.html#constructorparameters",a:"constructorparameters"},"50.4":{t:"InstanceType",p:`提取了构造器参数的类型，自然也可以提取构造器返回值的类型，就是 InstanceType。
`,l:"src/types/高级类型.html#instancetype",a:"instancetype"},"50.5":{t:"ThisParameterType",p:`

`,l:"src/types/高级类型.html#thisparametertype",a:"thisparametertype"},"50.6":{t:"OmitThisParameter",p:"",l:"src/types/高级类型.html#omitthisparameter",a:"omitthisparameter"},"50.7":{t:"Partial",p:"",l:"src/types/高级类型.html#partial",a:"partial"},"50.8":{t:"Required",p:"",l:"src/types/高级类型.html#required",a:"required"},"50.9":{t:"Readonly",p:"",l:"src/types/高级类型.html#readonly",a:"readonly"},"50.10":{t:"Pick",p:"",l:"src/types/高级类型.html#pick",a:"pick"},"50.11":{t:"Record",p:"",l:"src/types/高级类型.html#record",a:"record"},"50.12":{t:"Exclude",p:"",l:"src/types/高级类型.html#exclude",a:"exclude"},"50.13":{t:"Extract",p:"",l:"src/types/高级类型.html#extract",a:"extract"},"50.14":{t:"Omit",p:"",l:"src/types/高级类型.html#omit",a:"omit"},"50.15":{t:"Awaited",p:"",l:"src/types/高级类型.html#awaited",a:"awaited"},"50.16":{t:"NonNullable",p:"",l:"src/types/高级类型.html#nonnullable",a:"nonnullable"},"50.17":{t:"Uppercase",p:"",l:"src/types/高级类型.html#uppercase",a:"uppercase"},"50.18":{t:"Lowercase",p:"",l:"src/types/高级类型.html#lowercase",a:"lowercase"},"50.19":{t:"Capitalize",p:"",l:"src/types/高级类型.html#capitalize",a:"capitalize"},"50.20":{t:"Uncapitalize",p:"",l:"src/types/高级类型.html#uncapitalize",a:"uncapitalize"},"50.21":{t:"总结",p:"比如用模式匹配可以实现：Parameters、ReturnType、ConstructorParameters、Instan ...",l:"src/types/高级类型.html#总结",a:"总结"}},n={previewLength:62,buttonLabel:"搜索",placeholder:"搜索文档",allow:[],ignore:[]},r={INDEX_DATA:t,PREVIEW_LOOKUP:e,Options:n};export{r as default};
